---
title: 深入理解计算机系统读书笔记（三）
date: 2025-04-14 10:33:52
tags:
- 深入理解计算机系统
categories:
  - [读书笔记]
description: 本文介绍了 深入理解计算机系统
---

- 无符号数的加法：当两个无符号数相加的时候可能发生溢出，如果0<=x,y<2\*\*w  w为字长，那么0<=x\*y <= 2\*\*w-2，这样结果的字长就可能膨胀到w+1位，当然如果0<=x\*y<=2\*\*w-1的时候是不会发生字长膨胀的，只有当2\*\*w<=x\*y<=2\*\*-2时才会发生字长膨胀，也就是一个4位的数可能膨胀到5位，此时就发生了整数溢出。溢出的值发生最高位截断，比如9+12 = 21，大于了4位无符号整数的最大值15，其结果肯定会发生溢出，我们知道21的5位二进制便是为10101，最高位丢弃后的结果为0101，转换为十进制就是5，注意到5=21-2\*\*4，那么是否具有普适规律？我们知道4位如果膨胀到5位那么就是发生了进位，增加了权重1\*2\*\*4 = 16，相应的截断后就是减去16，看来该规律是具有普适性的。
- 无符号数加法溢出的检测：如果s=x+y，s<x或者x<y那么则发生了溢出，原理为当s发生溢出后有等式s=x+y-2*\*w w为字长，我们知道y肯定是小于为2*\*w的那么y-2*\*w则必定为负数，那么s=x+（负数），结果s肯定小于x，同理可推导处s<y，因此该方式可以作为检测的依据。
- 补码加法：同理补码加法同样可能发生溢出，不过其溢出可能有两个方向，即正溢出与负溢出。当-(2**(w-1)) <=x,y<=2**(w-1)-2时，可能发生溢出，当x+y> =2**(w-1)时发生正溢出，当x+y<-2**(w-1)时发生负溢出，取中间时正常不会发生溢出，同样的道理当发生溢出是时产生了进位。那么当结果是正溢出时则把最高位的正权丢失了，于是结果为x+y-2*\*w，当发生负溢出的时候，相当于减去了负权，也就是加上正权，于是结果为x+y+2*\*w
- 部门加法溢出的判断：当两正数相加得到负数的时候、两负数相加得到正数的时候发生溢出。
- 加法逆元：无符号数的加法逆元，即求非，对于任意一个w位的无符号整数x，总有一个数-x满足-x+x = 0。毫无疑问的当x为0的时候其加法逆元则为0，当x>0时其加法逆元为2*\*w-x，当然对于无符号数来说是没有负数的那么怎样才能得出这个结论呢，我们使用2*\*-x+x = 2**w，该数大于了w位无符号数的最大值将会发生溢出，其结果为2*\*w-2*\*w = 0，刚好满足加法逆元的定义。对于有符号数求非，当x不是有符号数的最小值的时候，很明显其结果就为-x，当x为最小值的时候没有一个-x与其对应则不能简单的这样运算，不过当两个最小值相加时有x+x = -2*\*(w-1)+(-2*\*(w-1)) = -2*\*w此时讲发生负溢出，根据前面的攻势此时x+x=-2*\*w+2*\*w=0，也就是说无符号数最小值的加法逆元为其本身。
- 一个补码表示的数如何取非，有两种方式，第一种，对该数的位级表示每一位取补，然后讲结果+1，如4位补码-6的位级表示为1010，每一位取补为0101，转为整数为5，然后加1位6，为补码-6的非。如果是-8呢？同样的位级表示为1000，取反0111位7加1为8，问题来了我们知道4位补码的最小值为-8，其非应该为其本身即-8才对，这里算出来确实8，怎么回事？？我也不知道呢。。。。第二种方式对于一个非0的补码数来说，总能找到其最右边的1，那么我们只需对这个对左边的数取反就可以了，还是对于整数-6来说1010，运算后就是0110，转为十进制整数为6，即-6的非为6，那么对于-8来说呢，1000运算后变成了1000，还是-8，这个就正常了。。
- 无符号数的乘法：同样的对于0<=x,y<=2*\*(w-1)来说，x*y产生的结果可能发生溢出，其结果范围为0<s<=2*\*(2*w)-2**(w+1)+1，这可能需要2*w位来表示s，同样的计算结果将发生高位截断，高w位被丢弃只留下低w位，那么运算的结果则为x*y = (x.y)mod 2*\*w，怎么推导的呢？书上没写哦，不过我想也不难的，高位截断就是 减去(2*\*w+...+2*\*(2w-1))这个值模2*\*w为(0+2*\*1+....+2*\*w-1)，这个结果看着是不是很眼熟，这不就是w位整数的表示方法吗？这里观察到一个规律，一个w位的数发生了字长膨胀计算算术结果为s，那么截断后的值为s mod 2*\*w，这是因为膨胀的位的权重mod 2*\*w结果都为0,有因为位的最大值也不可能大于2*\*w，那么这部分将作为余数被保留，高位则全部被整除了。
- 有符号数的乘法，与无符号数的乘法规则是一样的，推导过程也是一样的。
- 补码乘法与有符号乘法的位级等价性证明：太他妈复杂了，首先我们有两个位级向量a与b，那么其无符号数表示未x = B2U(a)与y = B2U(b)，补码表示为w = B2T(a)与z = B2T(b)那么就有T2B(a*b) = U2B(a*b)成立。在进行无符号数与补码转换时我们有公式x=w+2*\*k	 ，现在有(x*y) mod 2**k = ((w+2*\*k)(z+2*\*k)) mod 2*\*k = (w*z+(w+z)2*\*k+2*\*(2*k)) mod 2*\*k = (w*z) mod 2*\*k，即(x*y) mod 2*\*k =(w*z) mod 2*\*k，根据补码乘法原则有w.z = U2T(w*z mod 2*\*k) 两边同时应用函数T2U化简后得到T2U(w.z) = w*z mod 2*\*k 那么上式转换为T2U(w.z) = (w*z) mod 2*\*k = (x*y) mod 2*\*k = x.y，两边同时应用U2B为 U2B(T2U(w.z)) = U2B(x.y)就是T2B(w.z)=U2B(x.y)，到此证明完毕，无符号数与补码乘法有位级等价性质。举个例子对于3位无符号数5[101]其补码表示为-3 [101]，无符号数3[011] 其补码表示为3[011]，两个无符号数相乘3*5 = 15产生了溢出，按照公式除以8取模为7[111]，两个补码相乘-3*3=-9产生了溢出，按照截断原则除以8取模余-1[111]，可以看到两个结果虽然十进制表示结果不同但拥有相同的位级表示。
-   x 向左移动k位的推导过程，当然k不能大于等于w。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/10f375e86f624938362e3be5689c52d7.png)
- 因为直接计算整数的乘法相当慢，所有计算机采用了另一种方式，通过移位加加减法的方式来提升计算速度，通过生面的式子推导我们已经知道向左移位就是乘以2*\*k 同理向又移位就是除，那么我们就可以将乘法操作转换为移位和加减法操作了，如x*14，我们在计算的时候14=2*\*3+2*\*2+2*\*1，于是上面的式子变成了x<<3+x<<2+x<<1，如此便实现了乘法运算的转换。
- 对于乘法来说，无论是补码还会无符号数通过移位得到的结果总是满足上面的规律，如4位补码-5*2=-10[10110]，产生了溢出截取最高位之后的值为 6[0110] 通过移位-5[1011] 之后为6[0110]，结果一致。
- 对于除法同样可以采用向右移位的方式，不过其情况更为复杂，对于无符号数来说简单的移位就可以搞定，但是对于有符号数则要复杂得多。不过还需要考虑的直接进行除法是会得到小数的，而移位操作是不会产生小数的，那么这个冲突怎么解决的呢？正的小数发生向下舍入，负的小数发生向上舍入。
-  无符号数的除法，因为除法运算会产生小数，在计算时我们需要进行舍入。现有w位表示的数x，如果有一个数k,取值范围为1<=k<w，那么1~k位的数表示为u，k+1到w位的数表示为y，那么x可以表示为x=u+y*2*\*k 那么x/2*\*k = u/2*\*k+y，我们知道u肯定是小于2*\*k的，不会发生整除，其作为余数被舍去，所以舍入之后有等式x/2*\*k = y，即k+1到w位的数，当我们将x右移k位，高k位填充0，低w-k位的值就是最开始k+1到w位的值。位计数从0开始。这就是除法移位的计算方法推导。比如4位无符号数5[0101]除以2结果为2，通过移位需要移动1位即[00101]最低位舍去得到2[0010]
- 有符号数的除法。对于有符号数在进行除法操作时因为移位会导致符号位为1时被填充为0，那么结果的符号就变化了，而我们知道除法运算是不是改变符号的，这与事实不符，所以简单的逻辑移位是不对的，这时候需要用到算术移位，当然了，补码正数的运算方法还是和无符号数一样的。所谓算术唯一就是右移的时候高位不是填充0而是填充1，如-5[1011]除以2得到-3，通过移位为[11011]舍去低位得到-3[1101]，这个推导过程我没看懂这儿就不写了。
- 浮点数的二进制表示3/4=1/4+2/4=1/4+1/2=2*\*(-1)+2*\*(-2) = 0.11 ，不过这种方式不便于表示大数，数据较大的时候会导致存储数据消耗巨大的存储空间，所以有了IEEE标准的浮点数表示方法，对于单精度浮点数用32位表示1个符号位，8个阶码，23个位数位，数按进度浮点数用64位表示，一个符号位，11个阶码，52个尾数。符号位1表示负数0表示正数，阶码有三种格式中时不包含全是0与全是1的规格化值，一种是全是0的非规格话的值，另一种是全是1的无穷大的值。当使用规格化的值的时候，位级表示=浮点数的指数尾数（阶码）+偏置值，这个偏置值对于单精度浮点数来说为127，对双精度来说为1023，所以对单精度来说最多可以表示的指数位为-126~127，双精度为-1022 ~ 1023。尾数这部分怎么计算的我还没看明白。对于特殊值的阶码来说，当小数位全为0的时候表示无求大，正无穷还是负无穷由符号位控制。对于非规格化阶码，其提供了0的表示方法，因为规格化的表示尾数必须大于1，则不可能表示0，同样的这种方式表示的0的符号由符号位控制也就是产生了正0与负0两种结果，这两种结果在有些情况下相等在有些情况下不相等。
- 
