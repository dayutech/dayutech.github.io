---
title: 深入剖析Log4j2调用流程
tags:
  - log4j
categories:
  - - 漏洞原理
abbrlink: a60aa68e
date: 2025-04-14 10:33:52
---
@[TOC](深入剖析Log4j2调用流程)

><b><font color="red">申明：</font></b>本文只做学习交流使用，严禁任何组织和个人通过转发、转载等方式进行传播，因此导致的法律后果与本文作者无关。

小菜鸡昨晚正在积极进补雷神大大的课程的时候：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7a29e750df12950a939abb3ac4b60a21.png)
老板的消息划破了寂静的夜空，也打断了我学习的脚步：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/512baf9e23209af67cd6f42175fa1b99.png)
按照我的尿性，这种时候我肯定偷偷装死没跑了。
不过这个漏洞还是引起了我的兴趣，毕竟热度就那么多，蹭一蹭就没有了，我肯定也要蹭一蹭了。于是在昨晚瞎整了一晚上没结果后，今天上班的时候划水就把这整个利用过程给跑通了.....
果然上班划水才是生产力啊。
<!--more-->
首先，我们使用maven进行项目管理，搭建漏洞环境：
在pom.xml中引入下面的两个依赖：
```xml
<dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.12.1</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.12.1</version>
        </dependency>
```
漏洞存在的版本就懒得说了，反正不是最新版就对了，手动狗头！！
然后写个小页面：
```java
package com.armandhe.log4j2;


import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Log4j2Test {
    private static final Logger logger =  LogManager.getLogger();
    public static void main(String[] args) {
        logger.error("payload手动打码");
    }
}
```
然后打断点直接开始调试：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/92ef54f1b81f34febe364524cf063e15.png)
跳进去，懂的都懂：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1679d2a2bc9c9de40ecf28d36a1070cc.png)
到了这儿后据说是一个非常重要的步骤，调用`logIfEnabled`方法判断是否启用日志记录，这里的日志记录分为不同的等级，可以在log4j2的配置文件log4j2.properties中进行配置日志记录的级别。
我们继续跟进该方法：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/729130e9fa14957c6e2b815d1b31c7c6.png)
虽然不知道`logMessage`函数干什么的，不过肯定不是我们需要的，继续跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f31c2dfe441cc6dfb5b1e9c32bdb7a1a.png)
`logMessageSafely`函数，翻译一下就是日志信息安全性，猜一下可能是进行安全性判断的吧？因为是从零开始的期间我还跟进了newMessage函数，发现是将我们的message封装成了一个对象，对我们的目标没有大的影响， 跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/55b52ab3475ace84ea0be5261d33948a.png)
就想这样，将message封装进了一个`ReusableSimpleMessage`对象，继续回到`logMessageSafely`函数跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/02c3d13d06be439ccfff0bc1e451d194.png)
跟进`logMessageTrackRecursion`函数，不懂就问recursion什么意思？所以我抽空去有道查了一下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6cdb98d468bfff0259e7da92d31b8c95.png)
函数名翻译过来就是日志信息跟踪递归，什么意思？俺也不知道，继续跟进：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/701069406622e415d2b25b3c7798b2d3.png)
哦豁，原来就在下面，跟进函数`tryLogMessage`，老规矩还是翻译一下，捕获日志信息，还是不知道什么意思，但是又有什么关系呢，继续跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/98636e80eb9cc3fce6b1e17cf058713a.png)
管他什么呢，无脑继续跟：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/39d5b64d2dba6ca930f9611576bfc86d.png)
又能怎么样呢，继续：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/60380af23a7bfce5738d606173e194ec.png)
好烦啊，无限套娃：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b789a326b70d2fb87c02d77bf7556660.png)
先进去看看：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c4facdffe086a4b185b4df31b00f32d9.png)
好像做了很多，又好像什么也没做，就是setMessage哪儿换了个对象封装message：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9c674c83442ac5e197f1d9db190fac1f.png)
意义不大，所以我们继续单步执行：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0369eb8151f77750a1d36fc269eb7747.png)
到这儿后跟进`this.log`
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5af6633b2ea10974dae5f3fd0eb3a151.png)
然后进入`processLogEvent`：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c817be2d6cc1bcaf4b9f3e216de576fa.png)
到了这儿后，如果我们直接单步向下会发现处理发生了延迟，这就是我们的主机在请求dns解析产生的延迟，我也是在发现了这个特点之后才能在这又臭又长的调用链中坚持到最后，继续跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/00286cb7c1ef331c295df7fa35613128.png)
这儿很关键啊，兄弟们，不信我们往下看：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/82528d1fa8e3932a8ba4b2543307a737.png)
继续：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2a77c16aef24c107051f88dd1fd25798.png)
这儿是挨着的两次调用：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0d1cb474302bf5ec825c0722d332e4b5.png)
继续：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0af7a6a5af6786246a7db5c3bc915d46.png)
这儿三重套娃：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8f85f1a45d1dbb0ca01e8cb7425fbc5c.png)
二重套娃：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/acb65f312ca7767ba09307778fc8f515.png)
刚才说错了兄弟们，前面不重要，这儿很重要啊，这儿有11重循环，当循环到第8层的时候会有惊喜，所以我们至今到第8次循环让你们见识见识什么他么的叫他么的惊喜：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a2dcf295b6dbcbcb38531c4b5ad0c9d9.png)
好了看到i等于8了吗：
跟进去咯：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/22983898aa9728d1ef3af6c3adf236e2.png)
继续咯，不用我教你吧：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b29b5f9fe7a9a8b2aaa875a07bff652e.png)
亲，敲黑板划重点了啊！！！！！
这里有个进入的前提条件：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0369aa95ff29a7c9fe14bc8aa05010c0.png)
`this.config`不为空，且`this.noLookups`为`false`,这也是为什么你在各种各样的公众号看到的该漏洞的一个解决方案就是将`noLookups`的值设置为true的原因。

`workingBuiler`是个啥？我也不知道啊，怎么可能，这玩意就是一个`stringBuilder`，所以你懂了吧？
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/52031b353660b11cecfe36d09ce1ee31.png)
因为他娘的在这个声明过了，那么问题来了，长度80，也就是我的日志长度不能超过80？扯淡呢吧？当然超过80了，搞不懂搞不懂。
进入的条件判断有一个offset调试后发现是59，查了一下发现是$，也就是说message前面的58个字符的长度是固定的咯，我们输入的信息从第59个开始：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/95d37546a76a8458337d2d73f41c4196.png)
然后判断连续两个字符是是否为`\${`,如果是进入正题，截取了从59到后面的所有字符赋值给`value`，然后给我们的`workingBuilder`设置了长度并将截取的value进行处理之后赋值给他，在这里我利用了前面说到的延时特性观察到命令执行就发生在这里的对value处理过程中，所以我们跟进这个处理过程：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/77e72d743f92e20ce96f1ff90ce87a50.png)
source就是value的值，继续跟进：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1bad77b2aceba1bb205a5a23c2bfab76.png)
又开始套娃了：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7102cb38abd72eb84a66f10353cf72dc.png)
这个`substitute`函数可以说是写的又臭又长，总结一下左右就是提取那个啥？就那个我们的payload就对了，一直单步到这儿：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/777e4b23c5e9cb4f1dbdb1f9a9c8fdd7.png)
进去：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/85de273e4cebfbfdbdaeff7c550bbc55.png)
到这儿后其实`variableName`就是我们的payload主体了，继续：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0313841f9f36678dd7e4d637817783b1.png)
这里有两个重要的操作，一个是获得了协议前缀，一个是获取了具体的paload内容，`this.strLookupMap`里面定义了很多支持的协议，我们可以看一下：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cd6baa92469583faac3fc24c6b7b5550.png)
进入进入断点，判断event是否为空，肯定不为空啊，所以进入的是`lookup.lookup(name)`：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2457f1acef53a78931a280628fc472c8.png)
到了这里就有意思而了，第一个红框是获取一个`JndiManager`，但是在我调试的时候这里面好像是报错了还是怎么了，总是进不到第二个红框里面，而执行命令的代码又恰好在第二个红框里面，你说奇怪不奇怪？
是有意我直接强行跟踪到了第二个红框里面的代码：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/99a6eb1527f821e09afa691c4f89d85d.png)
重中之重就在这里了哈！！！lookup函数，看到这个你想到了什么？不确定吗？那来看看`this.context`是什么，`InitialContext`有没有想起点什么？？？？
打完收工！！！！！
