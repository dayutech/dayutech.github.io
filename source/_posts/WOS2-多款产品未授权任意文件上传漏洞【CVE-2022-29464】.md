---
title: WOS2 多款产品未授权任意文件上传漏洞【CVE-2022-29464】
tags:
  - 任意文件上传
  - WOS2
  - CVE-2022-29464
categories:
  - - 漏洞分析
abbrlink: 193abed6
date: 2025-04-14 10:33:52
---
全公司最大的黑阔在群里发了一张截图是老外发的关于这个漏洞复现的截图，于是我昨天看了很久他的源码，开始还是很难受的，可以知道的信息就是这是一个文件上传漏洞，看了最新发布的版本的修改
> [https://github.com/wso2/carbon-kernel/pull/3152/files](https://github.com/wso2/carbon-kernel/pull/3152/files)
<!--more-->
这部分是对文件上传的实现代码的修改，其实我看了感觉这儿其实还并不重要，因为也没修改啥内容，另一处修改就是添加了权限验证的代码
> [https://github.com/wso2/carbon-identity-framework/pull/3864/files](https://github.com/wso2/carbon-identity-framework/pull/3864/files)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/61f6f3da8298c1792d1a080fc1988d13.png)
我一开始很疑惑，因为不知道这里面每个标签的具体功能，标签属性的定义是啥，这就很无耐。这应该是一个权限控制的xml文件
resource标签的context为路由， secured为是否开启权限认证，如果为false的话则不开启，也就是可以未授权访问。这里注意到红色部分，对`"(.*)/fileupload(.*)`的定义是设置的为`false`的，也就是这个接口是可以未授权访问的，看名字很明显是一个未授权访问的接口。但是关于这个接口的映射关系，最终调用的是哪个类我开始一直很迷惑，因为这个的项目结构没有接触过，每个xml文件的作用域调用过程我都不是很熟悉，就很烦。
最新版还有一处修改就是
> [https://github.com/wso2-extensions/identity-carbon-auth-rest/pull/167/files](https://github.com/wso2-extensions/identity-carbon-auth-rest/pull/167/files)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e0f17ada21a096f036fe5b8dcef66711.png)

阅读代码可以发现其实并没有什么打的变化，这里就是判断cookie是否是有效的，换了一种实现方式而已，对漏洞的修复感觉影响不大。这里去到最重要的部分，也就是第一处的修改
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6009bcdcad8f0affccd116e95b3d615b.png)
这里删除了很多的映射关系，可以看到是两个文件上传的执行器，那么我们其实可以去看看这连个执行器是怎么写的，当然现在我们不看这个，还有另一个文件被修改了

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5efcf5a4234b867a72be55dca8db4b41.png)
主要的修改有两处
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8425b889449e7c0dae5a19361722a934.png)
这里对`uploadFile`的赋值进行了修改，添加了一个函数`verifyCanonicalDestination`对`fileName`进行检查，这个函数是新增加的，
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/71238db3876c7a36f19eda14010c3118.png)
大概的意思就是
首先使用`getCanonical`函数对`dirs`进行规范化，这个函数处理会将类似'../../../../'这种给干掉直接获取最终的路径，这种时候如果我们使用目录穿越将会使得最终获取的路径产生变化，然后使用`extraFileLocation`变量新建一个File对象，然后也调用`getCanonicalPath`函数进行规范化，然后调用`startsWith`函数判断后生成的`canonicalDestinationFile`是否以`canonicalDestinationPath`开头，如果不是的话就抛出异常，很明显如果我们对`canonicalDestinationPaht`使用了目录穿越的话那么将必然导致抛出异常，那么文件上传也就失败了。但是这里我还有个疑惑，这里`canonicalDestinationPath`的获取是使用`extraFileLocation`拼接了`fileName`的我们可以控制的只有`fileName`，我们看看`fileName`怎么来的
> String fileName = getFileName(fileItem.getFileName());

这里首先使用`fileItem.getFileName()`获取了一遍，这时候获去的文件名如果有目录穿越的特征是会影响到上传目的地的，但是这里还调用了当前类的方法`getFileName`就不一样了，我们看看这个函数怎么定义的
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f9d8f8ea56387625b386d2fe36708dd7.png)
最新的代码只是修改了实现方式，当然还是有一点区别，主要是新的代码里对空字节截断进行了处理，当然这并不影响什么，这里只取了最后一个`\\`或者`/`后面的内容，也就是说目录穿越在这里就已经被避免掉了，我实在没想明白为什么后面要再进行一次处理。
当然走到这里其实我的思路已经出了问题，我看的这个文件是`FielUploadServer.java`而我们在路径映射文件中看到的实际处理文件上传的类为
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/172058099f83306af784c92f4834621c.png)
害，所以我们应该去找到这个类：
> [https://github.com/bhagyasakalanka/carbon-kernel/blob/release-4.4.9/core/org.wso2.carbon.ui/src/main/java/org/wso2/carbon/ui/transports/fileupload/ToolsAnyFileUploadExecutor.java](https://github.com/bhagyasakalanka/carbon-kernel/blob/release-4.4.9/core/org.wso2.carbon.ui/src/main/java/org/wso2/carbon/ui/transports/fileupload/ToolsAnyFileUploadExecutor.java)

```java
/*
*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
*
*  WSO2 Inc. licenses this file to you under the Apache License,
*  Version 2.0 (the "License"); you may not use this file except
*  in compliance with the License.
*  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
package org.wso2.carbon.ui.transports.fileupload;

import org.apache.commons.collections.bidimap.TreeBidiMap;
import org.wso2.carbon.CarbonException;
import org.wso2.carbon.utils.FileItemData;
import org.wso2.carbon.utils.ServerConstants;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;

public class ToolsAnyFileUploadExecutor extends AbstractFileUploadExecutor {

	@Override
	public boolean execute(HttpServletRequest request,
			HttpServletResponse response) throws CarbonException, IOException {
		PrintWriter out = response.getWriter();
        try {
        	Map fileResourceMap =
                (Map) configurationContext
                        .getProperty(ServerConstants.FILE_RESOURCE_MAP);
        	if (fileResourceMap == null) {
        		fileResourceMap = new TreeBidiMap();
        		configurationContext.setProperty(ServerConstants.FILE_RESOURCE_MAP,
                                             fileResourceMap);
        	}
            List<FileItemData> fileItems = getAllFileItems();
            //String filePaths = "";

            for (FileItemData fileItem : fileItems) {
                String uuid = String.valueOf(
                        System.currentTimeMillis() + Math.random());
                String serviceUploadDir =
                        configurationContext
                                .getProperty(ServerConstants.WORK_DIR) +
                                File.separator +
                                "extra" + File
                                .separator +
                                uuid + File.separator;
                File dir = new File(serviceUploadDir);
                if (!dir.exists()) {
                    dir.mkdirs();
                }
                File uploadedFile = new File(dir, fileItem.getFileItem().getFieldName());
                try (FileOutputStream fileOutStream = new FileOutputStream(uploadedFile)) {
                    fileItem.getDataHandler().writeTo(fileOutStream);
                    fileOutStream.flush();
                }
                response.setContentType("text/plain; charset=utf-8");
                //filePaths = filePaths + uploadedFile.getAbsolutePath() + ",";
                fileResourceMap.put(uuid, uploadedFile.getAbsolutePath());
                out.write(uuid);
            }
            //filePaths = filePaths.substring(0, filePaths.length() - 1);
            //out.write(filePaths);
            out.flush();
        } catch (Exception e) {
            log.error("File upload FAILED", e);
            out.write("<script type=\"text/javascript\">" +
                    "top.wso2.wsf.Util.alertWarning('File upload FAILED. File may be non-existent or invalid.');" +
                    "</script>");
        } finally {
            out.close();
        }
        return true;
	}

}
```
这里主要是调用`execute`函数来处理文件上传请求。这里就不是获取的文件名而是`FieldName`也就是文件上传请求的`name`参数的值进行拼接
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/09cb5f27e9889018181e9417a894e4a5.png)
这里很明显是有路径穿越的问题的，所以到这里所有的问题基本就被打通了。但还有一个困扰我的问题，就是这个路由的写法，可能只有对这个产品比较了解的人才能很好的把这个高清楚吧，放一张复现的截图
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7e28e8967577e71f88f0f07d96b1556a.png)
不用管那个403，我做了别的测试，具体的poc就不发了，没意义，还是要懂原理才好。

当然其实在github上已经有大哥进行了详细的分析，但我还没有仔细去看
> [https://github.com/hakivvi/CVE-2022-29464](https://github.com/hakivvi/CVE-2022-29464)

官方说明
> [https://docs.wso2.com/display/Security/Security+Advisory+WSO2-2021-1738](https://docs.wso2.com/display/Security/Security+Advisory+WSO2-2021-1738)
> 





