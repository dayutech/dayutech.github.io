---
title: PostgreSQL JDBC Driver RCE&任意文件写入漏洞
date: 2025-04-14 10:33:52
tags:
- 任意文件写
- Postgre
- SQL注入
categories:
  - [漏洞分析]
---


上班没有任务你们都干什么，反正我是不会摸鱼的，这辈子都不可能摸鱼的，复现这个漏洞的初衷是看了某公众号关于Vmware Workspace One Access的jdbc注入漏洞，文中值分析到jdbc url可控的部分，但是我不太清楚为什么jdbc可控就会导致任意文件写入，于是上网搜了jdbc注入的文章，于是找到了这儿：
<!--more-->
> [https://paper.seebug.org/1832/](https://paper.seebug.org/1832/)

这篇文章里介绍了Mysql 的JDBC驱动可能导致的漏洞的分析，不过这好像不是我需要的，不过我还是学习了一波，具体的调用流程我还没有看，准备咋写完这篇就去看看。后来我又在刚才提到的公众号里找到了另一篇将PostGreSQL的注入分析，于是我就跟着分析了一波。这篇文章里介绍了两个漏洞一个是RCE，另一个是任意文件写入漏洞。
# RCE
首先我们创建一个MAVEN项目，然后引入相关的依赖：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5ced078929b993db8057524c1e367ab0.png)
然后编写一个漏洞利用POC。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/32449109031c3fc2a331e246a6cacf49.png)
很明显导致漏洞的是jdbcURL的socketFactory与socketFactoryArg这两个参数，在jdbcURL的定义中，参数部分一般被称作扩展参数，其总用是指定连接数据库的一些特性。大胆cancel导致漏洞的就是这两个参数，而这个漏洞的kick-off就是DriverManager.getConnection这个类方法。那么我们接下来要做的就是不断跟踪这个函数的Chain最终找到sink点。直接开干，毫无疑问我们要使用调试模式将代码跑起来，然后键入到getConnection函数里面。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/064c6d4ca7a7331a6e695e5d01c6a6d2.png)
无意义的部分我就直接放图片了，需要关注的地方我会说明
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7392fcc25dc3f316af36782dc20f0293.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ccbaeb08422697f7a4fb4670f23057dd.png)
这里注意注意第151行
> this.setupLoggerFromProperties(props);

这与我们的任意文件写入有关，当然现在我们不关注他，这个时候我们可以看一下props的值
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/ab3aaf9cdbd7f4e7a764c52c68ff5b62.png)
存储的都是jdbcRUL含有的一些关键信息，具体的实现步骤我当然是一步一步看了的，有新区的可以自己看看。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d9714883310a8c2d83f1b6538fcdf8b6.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/9c41a90e6a0b2680b1ba52b62aa8cff6.png)
这里对props进行了处理，最终生成的是一个hostSpecs类型的数组，hostSpecs对象存储了数据库连接的hostnae, port以及一个扩展参数localSocketAddress，
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8e662319025a149bd51fcb4a54792ca8.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/371c3ab18de2f8e22781466536dc56e4.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/dd9ed18eb4931c726f21b622b0886322.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6ac4cbac510fe44fe69ab979e601d56d.png)
这个时候可以看一波这个info存储的信息了
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/403ae02a564320dedc0f27f2c54d2a05.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/df2ae255020b698ba90dea5bf60ce140.png)
这里注意第三个参数`PGProperty.SOCKET_FACTORY_ARG`，PGProperty是一个枚举类型，其内部定义了get方法，实现的功能是对判断枚举项的值有没有在传入的properties中，如果在则查找返回，如果不在则返回默认值。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7ce33e988bcb94a35fd158b484e500f9.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1a4f33fffdfd9632bb4a02a46150e3ae.png)
可以看到有很多的枚举项，这些内容很大一部分都是JDBC的扩展参数的可选值。
在我们的代码中这个值就是`args`也就是我们最开始poc设置的参数`socketFactoryArg`
还可以看一看第一个参数的值
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/56340d55a62456873cb62038ab7c52f3.png)
就是最开始设置的参数`socketFactoryClass`
然后跟进这个函数`instantiate`
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/90be4014a268634cde7e700a2425fda1.png)
很明显的反射调用，第一个参数作为类名，第三个参数作为构造方法的参数，那么这个函数`ObjectFactory.instantiate`就是我们的sink点了。
现在我们要找到一个gadget能够在在类实例化的过程中实现RCE，作者根据jackson的历史漏洞`CVE-2017-17485`找到这么一个类
`org.springframework.context.support.ClassPathXmlApplicationContext` 该类在实例化的时候会下载出入的参数指定的xml文件然后获取java bean，然后通过jpel表达式执行恶意代码。
完整的poc长这样
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2281dffccbdcbb3e7ef26beb6c41b4d6.png)
当然过去jdbc连接的用户名根本不用填，根本用不上。
xml文件长这样：
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d32339c5218d29b8d0b34a29ee52d131.png)
然后直接运行代码
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f5ff4c93c580108a6d0240e6a85db852.png)
完美
# 任意文件写
这个也比较简单，上面有提到过，重点在`this.setupLoggerFromProperties(props);`里面设置了日志处理器，在调用该logger的时候就会使用该处理器将日志记录到指定的日志文件中。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2163e134a61bb522243e3e445f0eeca2.png)
这里注意要设置jdbc扩展参数`logger_level`设置日志记录的级别，当然不能为off，
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/829303d5d04f95aadbb7c8cb22f66df3.png)
设置扩展参数`logger_file`指定日志文件的路径，这里没有对路径进行过滤，所以可以进行目录穿越，将文件指定到想要的位置。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/763faa16a6ecaf5bf292864d963eb372.png)
这个文件处理器最终被添加到了`Parent_LOGGER`这个日志记录器中
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/a9a2b6ea66b5222132b9b34ef86ba49e.png)
在执行完`setupLoggerFromProperties(props)`后，马上就有记录日志的操作，该操作将整个jdbcUrl记录到日志中。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/10dcb0eb1dd3852c53c60fd860fbd202.png)
注意到这里的日志记录器并不是`PARENT_LOGGER`而是`LOGGER`，那么他是怎么调用到父记录器的呢，这个可以自己跟一下log的流程看一下怎么获取的，最终的poc与效果
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1f0bd72347a1eb74e185be6a2a08c8f9.png)


























