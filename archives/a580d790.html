<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/dayu/dayu-apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/dayu/dayu-web-app-manifest-512x512.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/dayu/dayu-web-app-manifest-192x192.png">
  <link rel="mask-icon" href="/images/dayu/dayu-favicon.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dayutech.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java Gadgets 搜索工具是如何工作的（Gadget Inspector）Gadget Inspector 由 Ian Haken 于 2018 年 8 月在  DEF CON 上发布，其发布开创了Gadget 自动化挖掘的先河。Gadget Inspector 依靠Java ASM技术，通过静态模拟 Java 程序运行过程中操作数栈以及局部变量表的动态变化来进行数据流跟踪从而实现污点分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Gadgets搜索工具是如何工作的-Gadget Inspector">
<meta property="og:url" content="https://dayutech.github.io/archives/a580d790.html">
<meta property="og:site_name" content="Dayu Technology Co., LTD">
<meta property="og:description" content="Java Gadgets 搜索工具是如何工作的（Gadget Inspector）Gadget Inspector 由 Ian Haken 于 2018 年 8 月在  DEF CON 上发布，其发布开创了Gadget 自动化挖掘的先河。Gadget Inspector 依靠Java ASM技术，通过静态模拟 Java 程序运行过程中操作数栈以及局部变量表的动态变化来进行数据流跟踪从而实现污点分析">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-11T03:19:48.000Z">
<meta property="article:modified_time" content="2025-07-29T09:02:06.992Z">
<meta property="article:author" content="Arliya">
<meta property="article:tag" content="反序列化">
<meta property="article:tag" content="Java Gadgets">
<meta property="article:tag" content="Gadget Inspector">
<meta property="article:tag" content="反序列化利用链">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dayutech.github.io/archives/a580d790.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style><style>
#needsharebutton-float {
  bottom: 88px;
  cursor: pointer;
  left: -8px;
  position: fixed;
  z-index: 9999;
}
#needsharebutton-float .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 4px;
  padding: 0 10px 0 14px;
}
</style>
  <title>Java-Gadgets搜索工具是如何工作的-Gadget Inspector | Dayu Technology Co., LTD</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Dayu Technology Co., LTD" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dayu Technology Co., LTD</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">大禹科技股份有限公司</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/dayutech/dayutech.github.io" class="github-corner" title="Dayu GitHub" aria-label="Dayu GitHub" rel="noopener external nofollow noreferrer" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dayutech.github.io/archives/a580d790.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/dayu/avatar.png">
      <meta itemprop="name" content="Arliya">
      <meta itemprop="description" content="主要从事Web漏洞挖掘工作，涉猎编程语言包括Java、Scala、C/C++、PHP、Python、C#、Golang，涉及领域包括Web以及二进制漏洞挖掘，二进制比较菜，平时喜欢在金融市场消费">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dayu Technology Co., LTD">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-Gadgets搜索工具是如何工作的-Gadget Inspector
        </h1>

        <div class="post-meta">
		  
            <i class="fa fa-thumb-tack"></i>
            <font color=FF0000>置顶</font>
            <span class="post-meta-divider"> | </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-11 11:19:48" itemprop="dateCreated datePublished" datetime="2025-04-11T11:19:48+08:00">2025-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-07-29 17:02:06" itemprop="dateModified" datetime="2025-07-29T17:02:06+08:00">2025-07-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BC%8F%E6%8C%96%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">漏挖工具</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>36 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java-Gadgets-搜索工具是如何工作的（Gadget-Inspector）"><a href="#Java-Gadgets-搜索工具是如何工作的（Gadget-Inspector）" class="headerlink" title="Java Gadgets 搜索工具是如何工作的（Gadget Inspector）"></a>Java Gadgets 搜索工具是如何工作的（Gadget Inspector）</h1><p>Gadget Inspector 由 Ian Haken 于 2018 年 8 月在  DEF CON 上发布，其发布开创了Gadget 自动化挖掘的先河。Gadget Inspector 依靠Java ASM<br>技术，通过静态模拟 Java 程序运行过程中操作数栈以及局部变量表的动态变化来进行数据流跟踪从而实现污点分析进而进行Gadgets探测。  </p>
<h3 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h3><p>Gadget Inspector 的核心逻辑包含5个步骤，分别是类信息分析、数据传播分析、调用图构造、入口探测以及Gadgets串联。<br>在第一步中 Gadget Inspector 利用 MethodDiscovery 类对 当前环境中所有类的方法、成员、继承结构进行解析并集中存储在特定的数据结构中以便后续进行<br>数据传播分析以及调用图构造。<br>在第二步中 Gadget Inspector 利用 PassthroughDiscovery 类运用 深度优先算法、逆拓扑排序等方式进行数据流分析从而确认方法入参与返回值的关系，<br>即入参是否能够污染到返回值，其根本目的在于确认关键参数是否可以被攻击者控制。<br>在第三步中 Gadget Inspector 通过 Java ASM 技术构造方法调用图，其目的在于确认主调方法与被调用方法参数之间的关系。<br>第四步中 Gadget Inspector 通过 SourceDiscovery 针对不同的夫序列化类型进行分发，通过对比第一步中形成的methodMap中存储的方法信息与预定义<br>的反序列化 Gadget Source点进行比较，从而确定当前项目中可被使用的反序列化入口方法。<br>在第五步中 Gadget  Inspector 开始从Source点开始遍历调用图，直到找到一个方法与预定义的sink点相匹配则说明Gadget Inspector 找到了一条可以<br>使用的反序列化调用链。  </p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Perform the various discovery steps</span></span><br><span class="line">        <span class="comment">// 对类结构进行分析 包括类的方法信息  成员信息等</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;classes.dat&quot;</span>)) || !Files.exists(Paths.get(<span class="string">&quot;methods.dat&quot;</span>))</span><br><span class="line">                || !Files.exists(Paths.get(<span class="string">&quot;inheritanceMap.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Running method discovery...&quot;</span>);</span><br><span class="line">            <span class="type">MethodDiscovery</span> <span class="variable">methodDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodDiscovery</span>();</span><br><span class="line">            methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">            methodDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对方法的入参与返回值的关系进行分析</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;passthrough.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Analyzing methods for passthrough dataflow...&quot;</span>);</span><br><span class="line">            <span class="type">PassthroughDiscovery</span> <span class="variable">passthroughDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDiscovery</span>();</span><br><span class="line">            passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">            passthroughDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对方法调用之间参数的关系进行分析</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Analyzing methods in order to build a call graph...&quot;</span>);</span><br><span class="line">            <span class="type">CallGraphDiscovery</span> <span class="variable">callGraphDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallGraphDiscovery</span>();</span><br><span class="line">            callGraphDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">            callGraphDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据预定义规则查找所有的source点</span></span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">&quot;sources.dat&quot;</span>))) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;Discovering gadget chain source methods...&quot;</span>);</span><br><span class="line">            <span class="type">SourceDiscovery</span> <span class="variable">sourceDiscovery</span> <span class="operator">=</span> config.getSourceDiscovery();</span><br><span class="line">            sourceDiscovery.discover();</span><br><span class="line">            sourceDiscovery.save();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 查找 gadget chain</span></span><br><span class="line">            LOGGER.info(<span class="string">&quot;Searching call graph for gadget chains...&quot;</span>);</span><br><span class="line">            <span class="type">GadgetChainDiscovery</span> <span class="variable">gadgetChainDiscovery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainDiscovery</span>(config);</span><br><span class="line">            gadgetChainDiscovery.discover();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;Analysis complete!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="类结构分析"><a href="#类结构分析" class="headerlink" title="类结构分析"></a>类结构分析</h4><p>Gadget Inspector 针对项目中的类的结构分析开始于 MethodDiscovery 类的 discover 方法。<br>classResourceEnumerator 类存储了当前项目中所有被指定的需要分析的类信息，包括用户指定的jar包、JDK原生的依赖库。通过获取每一个类的字节码流将其传递给<br>ASM框架的ClassVisitor对每一个类进行解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> classResource.getInputStream()) &#123;</span><br><span class="line">                <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(in);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cr.accept(<span class="keyword">new</span> <span class="title class_">MethodDiscoveryClassVisitor</span>(), ClassReader.EXPAND_FRAMES);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Exception analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MethodDiscoveryClassVisitor 类是 ASM 框架 ClassVisitor 类的实现类，在当前步骤中 MethodDiscoveryClassVisitor 主要通过实现 ClassVistor<br>的 visit visitField visitMethod visitEnd 方法类对类的字段、方法进行分析。<br>上述四个方法将按照顺序依次调用，首先是visit方法被调用，用于访问类的基本信息（如版本、访问标志、类名、父类名、接口等），它标志着类的开始。<br>需要特别说明的是 ClassReference.Handle 表示某一个类的处理句柄，Gadget Inspector将类名封装到该类中用以作为后续步骤中从各种数据结构中访问类信息的句柄<br>不仅类名被封装通过句柄访问，后续类方法以及类成员信息同样被封装为句柄。与类不同方法句柄将不经包含方法名信息，还将包括方法签名、返回值等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span> <span class="params">( <span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[]interfaces)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.superName = superName;</span><br><span class="line">            <span class="built_in">this</span>.interfaces = interfaces;</span><br><span class="line">            <span class="built_in">this</span>.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.members = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.classHandle = <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(name);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当 visit 方法调用完毕后，visitField方法会被调用，用于访问类中的每个字段。如果存在多个字段，visitField会为每个字段单独调用依次。<br>该重载方法中对字段的访问修饰符进行了判断，如果当前字段的访问修饰符为 ACC_STATIC 即被 static 关键词修饰则步记录该字段到 members 变量中。<br>这是因为静态字段在类加载时被初始化不能被攻击者所控制修改，于反序列化漏洞无益。针对引用数据类型Object以及Array，Gadget Inspector只获取其内部类型<br>而不必获取其完整的类型描述符，如：变量 String s，其类型描述符为 Ljava&#x2F;lang&#x2F;String;，而其内部类型为 java&#x2F;lang&#x2F;String。<br>类成员信息最终被封装为 ClassReference.Member 类并存储在 members 变量中，该类封装了字段名、访问修饰符以及字段类型。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">                                       String signature, Object value)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                String typeName;</span><br><span class="line">                <span class="keyword">if</span> (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;</span><br><span class="line">                    typeName = type.getInternalName();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typeName = type.getDescriptor();</span><br><span class="line">                &#125;</span><br><span class="line">                members.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member(name, access, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(typeName)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>在所有字段都被访问完后，visitMethod 方法会被调用，用于访问类中的每个方法。如果有多个方法，visitMethod 会为每个方法依次调用一次。<br>visitMethod方法将当前类中所有的方法封装为 MethodReference 类，并最终被存储在 discoveredMethods 变量中。<br>需要特别注意的是在进行方法信息存储是存储了当前方法是否是类方法，该信息主要在后续进行数据流传播分析时对静态方法进行特殊处理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc, String signature, String[] exceptions)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isStatic</span> <span class="operator">=</span> (access &amp; Opcodes.ACC_STATIC) != <span class="number">0</span>;</span><br><span class="line">            discoveredMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>(</span><br><span class="line">                    classHandle,</span><br><span class="line">                    name,</span><br><span class="line">                    desc,</span><br><span class="line">                    isStatic));</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>当类的所有字段和方法都被访问完毕后，visitEnd 方法会被调用，表示类访问的结束。<br>该方法将已经访问的类信息封装为ClassReference对象存储在 discoveredClasses 变量中，用于标识已经被访问过的类。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitEnd</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ClassReference</span> <span class="variable">classReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReference</span>(</span><br><span class="line">                    name,</span><br><span class="line">                    superName,</span><br><span class="line">                    interfaces,</span><br><span class="line">                    isInterface,</span><br><span class="line">                    members.toArray(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Member[members.size()]));</span><br><span class="line">            discoveredClasses.add(classReference);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitEnd();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上述四个方法调用完毕后，我们便可通过 MethodDiscovery 对象的 discoveredClasses 以及 discoveredMethods 变量获取到当前类中所有字段以及方法信息。<br>为了方便后续过程使用这一步生成的信息，Gadget Inspector 调用 MethodDiscovery 的 save 方法将这些信息保存到本地文件中分别为 classes.dat 以及 methods.dat<br>用以存储类信息以及方法信息。<br>classes.dat的数据存储结构为：<br>全类名|父类名|接口列表|是否是接口|成员列表<br>methods.dat的数据存储结构为：<br>所属类全类名|方法名|方法描述符|是否是静态方法<br>类基本信息存储完毕后 Gadget Inspector 将利用 discoveredClasses 变量中存储的类信息计算类的继承树并将其存储到 inheritanceMap.dat 文件中。<br>首先从 ClassReference 对象中获取父类以及接口信息，再从classMap中获取到当前类的父类与接口的 ClassReference 对象，最后进行递归调用，获得基类的所有<br>父类以及接口。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getAllParents</span><span class="params">(ClassReference classReference, Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Set&lt;ClassReference.Handle&gt; allParents)</span> &#123;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; parents = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (classReference.getSuperClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">        parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(classReference.getSuperClass()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String iface : classReference.getInterfaces()) &#123;</span><br><span class="line">        parents.add(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(iface));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle immediateParent : parents) &#123;</span><br><span class="line">        <span class="type">ClassReference</span> <span class="variable">parentClassReference</span> <span class="operator">=</span> classMap.get(immediateParent);</span><br><span class="line">        <span class="keyword">if</span> (parentClassReference == <span class="literal">null</span>) &#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;No class id for &quot;</span> + immediateParent.getName());</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        allParents.add(parentClassReference.getHandle());</span><br><span class="line">        getAllParents(parentClassReference, classMap, allParents);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最终 inheritanceMap.dat 的数据存储结构为：<br>当前类全类名|父类以及接口列表  </p>
<h4 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h4><p>数据流分析是 Gadget Inspector 中最核心的模块，其目的是对数据流进行传播分析，从而确定方法入参与返回值的关系。数据流分析整体上分为3步，即构造方法调用图、<br>对所有方法进行逆拓扑排序、计算数据传播流图。  </p>
<h5 id="分析方法调用关系"><a href="#分析方法调用关系" class="headerlink" title="分析方法调用关系"></a>分析方法调用关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, <span class="keyword">final</span> GIConfig config)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">        <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line">        List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line">        passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">                config.getSerializableDecider(methodMap, inheritanceMap));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法调用图的构造只是简单得使用 MethodCallDiscoveryClassVisitor 这个 ClassVisitor 通过对其重写的 visitMethod 方法进行调用时通过引入<br>MethodCallDiscoveryMethodVisitor 这个  MehtodVisitor，通过其 visitMethodInsn 方法的调用从而记录当前类的每一个方法在用过程中发起了哪些其他的方法调用。<br>visitMethodInsn 方法监听的方法调用类型包括 INVOKEVIRTUAL、INVOKESPECIAL、INVOKESTATIC、INVOKEINTERFACE，<br>即实例方法调用、（构造函数，私有方法，父类方法）、静态方法调用、接口方法调用。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            calledMethods.add(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这些方法调用最终会被记录到 methodCalls 变量中并通过对应的方法句柄进行索引。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span><br><span class="line"><span class="params">                                           <span class="keyword">final</span> String owner, String name, String desc)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(api, mv);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.calledMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            methodCalls.put(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc), calledMethods);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><p>在了解Gadget Inspector 的逆拓扑排序方法之前，我们首先需要了解以下什么是拓扑排序，当前情境下为什么需要拓扑排序。  </p>
<h6 id="图相关概念"><a href="#图相关概念" class="headerlink" title="图相关概念"></a>图相关概念</h6><p>假设存在一个二元组 G &#x3D; (V, E)，其中V是一系列点的集合，E是一系列边的集合，其中V &#x3D; {v1, v2, v3, v4, v5}，E &#x3D; {(v1, v2), (v2, v3), (v3, v4), (v4, v5), (v5, v1)}，那么G就是一个图。<br>我们将V中的某一个点称为这个图的顶点，与该顶点相关联的边的条数称为该顶点的度，例如：在图G中，与顶点 v1 相关的边为(v1, v2) 和 (v5, v1)，故其度为2。<br>度又分为入度与出度，一个顶点的入度指的是以该顶点为终点的边数，出度指的是以该顶点为起点的边数，故顶点 V1 的入度与出度均为1。<br>在图G中，每一条边均是有方向的，被记作(u, v)，故称图G是一个有向图。在一个图中一系列相互连接的边被称为一条途径，若边两两不同则被称为一条迹，若点也两两不同，则被称为一条路径。<br>对于一条迹，如果其起点与终点一致，那么该迹称为一条回路。对于一条回路，如果其起点与终点是唯一相同的点，则称该回路是一个环。<br>所谓有向无环图则必须满足两个条件，其一该图是一个有向图；其二该图不存在环。<br>有向无环图存在两个性质，其一能进行拓扑排序的图，一定是有向无环图；其二有向无环图一定能进行拓扑排序。  </p>
<h6 id="为什么需要将所有方法进行拓扑排序"><a href="#为什么需要将所有方法进行拓扑排序" class="headerlink" title="为什么需要将所有方法进行拓扑排序"></a>为什么需要将所有方法进行拓扑排序</h6><p>拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。<br>在本项目中，我们需要求解的是方法的参数与返回值的关系，而一个方法调用中可能存在另外一个方法调用，该方法可能会接受外层方法的参数同时其返回值可能会影响外层方法的局部变量，<br>而该局部变量又可能会影响外层方法的返回值， 故我们在对外层方法的入参与返回值的关系进行求解时需要先对内层被调用方法的入参与返回值的关系进行求解。<br>在下面的例子中，我们如果需要判断方法a的参数arg会不会污染其返回值。因为返回值br来自于方法b的执行结果，故我们需要先判断方法b的入参arg2会不会污染其返回值。<br>在方法b中因为形参arg2会污染方法b的返回值，故在方法a中arg1作为方法b的实参被传入，故br会被arg1污染，即方法a的返回值会被方法a的参数arg1污染。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">a</span><span class="params">(String arg1)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">br</span> <span class="operator">=</span> b(arg1);</span><br><span class="line">        <span class="keyword">return</span> br;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">b</span><span class="params">(String arg2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arg2 + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将不同的方法看作不同的点，所有的方法构成一个点集，将方法的调用关系看作边，调用者作为起点，被调用者作为终点从而形成一个有向的边集形成一个有向图。<br>因为 Java 方法调用的特殊性，其往往存在各种循环调用，典型的就是递归调用，故方法调用图并不是一个典型的有向无环图。一般来说这样的图是不能进行拓扑排序的，<br>不过 Gadget Inspector 通过引入中间变量并增加逻辑判断的方式来避免了这个问题。  </p>
<h6 id="如何对方法调用进行拓扑排序"><a href="#如何对方法调用进行拓扑排序" class="headerlink" title="如何对方法调用进行拓扑排序"></a>如何对方法调用进行拓扑排序</h6><p>在前一节中通过 discoverMethodCalls 方法的调用获取了一个以 MethodReference.Handle 方法句柄为Key，Set&lt;MethodReference.Handle&gt; 为值的一个Map并赋值给变量methodCalls。<br>在进行拓扑排序是首先将methodCalls变量的值进行拷贝到 outgoingReferences 中，然后定义了三个变量 dfsStack，visitNodes，sortedMethods<br>分别用于记录搜索栈，已访问节点集合，以及最终的排序结果集合。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">            MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            outgoingReferences.put(method, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Topological sort methods</span></span><br><span class="line">        LOGGER.debug(<span class="string">&quot;Performing topological sort...&quot;</span>);</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; dfsStack = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; visitedNodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;MethodReference.Handle&gt; sortedMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(outgoingReferences.size());</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">            dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(String.format(<span class="string">&quot;Outgoing references %d, sortedMethods %d&quot;</span>, outgoingReferences.size(), sortedMethods.size()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sortedMethods;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>stack 变量是用来跟踪方法调用深度的栈，每当发生方法调用时便将该方法压入到栈中，当方法调用结束时将该方法从栈中弹出，当栈为空时表示一次排序结束。<br>visitedNodes 变量用于表示当前节点已经被访问过了，当某个节点出现在visitedNotes中时将不必继续进行递归而是直接返回，因为该节点已经被排序存储到 sortedMethods 中。<br>通过 visitedNodes 集合的引入，Gadget Inspector 有效地避免了有向图拓扑排序过程中环的问题。<br>sortedMethods 存储最终的排序结果，所有的方法都将被存储在该列表中。<br>在整个排序过程中 stack 变量可能为空，因为其只存储了一次方法调用排序的堆栈变化关系，当当前方法调用结束后 stack 变量为空，则表示一次排序结束。<br>visitedNodes 过程中不会为空而是不断地增长，因为其存储的是所有被访问过的方法，随着排序的进行其容量会不断扩大。sortedMethods 列表会随着排序的进行增长，因为其存储的是排序的结果。<br>visitedNodes 集合的引入是为了处理有向图中出现的环的问题。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfsTsort</span><span class="params">(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span></span><br><span class="line"><span class="params">                                    List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span></span><br><span class="line"><span class="params">                                    Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visitedNodes.contains(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">        <span class="keyword">if</span> (outgoingRefs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.add(node);</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle child : outgoingRefs) &#123;</span><br><span class="line">            dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.remove(node);</span><br><span class="line">        visitedNodes.add(node);</span><br><span class="line">        sortedMethods.add(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="构造数据传播流图"><a href="#构造数据传播流图" class="headerlink" title="构造数据传播流图"></a>构造数据传播流图</h5><p>本节是 Gadget Inspector 的精华，它通过静态模拟程序运行过程中局部变量表以及操作数栈的变换来进行污点分析，从而确认方法入参与返回值之间的关系。<br>在下面的方法中首先对 <clinit> 方法做了排除，因为它是类的构造方法，在类的加载过程中由JVM执行，负责类静态代码块的执行以及类成员变量的初始化等操作。<br>该过程不受攻击者控制。<br>然后通过方法句柄获取到其所属类并读取该类的字节码流，并使用 PassthroughDataflowClassVisitor 对字节码流进行解析。 PassthroughDataflowClassVisitor 是一个 ClassVisitor，<br>其 visitMethod 会依次处理该类的所有方法，并使用 MethodVisitor 对方法进行解析。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; calculatePassthroughDataflow(Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName,</span><br><span class="line">                                                                                          Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span><br><span class="line">                                                                                          InheritanceMap inheritanceMap,</span><br><span class="line">                                                                                          List&lt;MethodReference.Handle&gt; sortedMethods,</span><br><span class="line">                                                                                          SerializableDecider serializableDecider) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;&lt;clinit&gt;&quot;</span>)) &#123; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ClassResourceEnumerator.<span class="type">ClassResource</span> <span class="variable">classResource</span> <span class="operator">=</span> classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> classResource.getInputStream()) &#123;</span><br><span class="line">                <span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(inputStream);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">PassthroughDataflowClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PassthroughDataflowClassVisitor</span>(classMap, inheritanceMap,</span><br><span class="line">                            passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">                    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                     passthroughDataflow.put(method, cv.getReturnTaint());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Exception analyzing &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Unable to analyze &quot;</span> + method.getClassReference().getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> passthroughDataflow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 是一个 MethodVisitor，其会访问一个方法调用的各种信息。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String desc,</span></span><br><span class="line"><span class="params">        String signature, String[] exceptions)</span> &#123;</span><br><span class="line">        <span class="comment">// 访问指定的方法   方法名与方法描述符必须一致  避免方法重载带来的冲突</span></span><br><span class="line">        <span class="keyword">if</span> (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflowMethodVisitor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Constructing passthroughDataflowMethodVisitor twice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodVisitor</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        <span class="comment">// 访问类的某一个方法的详细信息</span></span><br><span class="line">        passthroughDataflowMethodVisitor = <span class="keyword">new</span> <span class="title class_">PassthroughDataflowMethodVisitor</span>(</span><br><span class="line">        classMap, inheritanceMap, <span class="built_in">this</span>.passthroughDataflow, serializableDecider,</span><br><span class="line">        api, mv, <span class="built_in">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSRInlinerAdapter</span>(passthroughDataflowMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 继承自 TaintTrackingMethodVisitor 两者一同实现了操作数栈以及局部变量表的静态模拟。<br>PassthroughDataflowMethodVisitor 主要负责污点传播分析， TaintTrackingMethodVisitor 主要负责在分析过程中调整操作数栈以及局部变量表。<br>在 MethodVisitor 中针对字节码不同的行为均有相应的方法进行处理，如当方法中出现无操作数字节码调用时，如：RETURN, IRETURN, ATHROW，将会触发 visitInsn 方法调用，<br>当出现方法调用指令时，如： INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE ，将触发 visitMethodInsn 方法调用。<br>Gadget Inspector 将在对应的方法中同步记录这些指令调用时操作数栈以及局部变量表的变化情况。<br>下面我们将通过几个方法的调用举例展示，Gadget Inspector 时如何进行模拟的。  </p>
<p>visitCode 方法是最先被执行的方法，其将负责局部变量表空间的开辟，并设置相应的污点。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 开辟局部变量表空间</span></span><br><span class="line">            <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 设置污点  也可以理解成设置形参在局部变量表中的位置 形成的数据类似</span></span><br><span class="line">            <span class="comment">// 假如有这样一个实例方法</span></span><br><span class="line">            <span class="comment">// (String,long,int)</span></span><br><span class="line">            <span class="comment">// 对应的局部变量表为 long 的索引为2 占据两个槽位</span></span><br><span class="line">            <span class="comment">// | 0 | 1 | 2 |   | 3 |</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 第0个局部变量被第0个参数污染</span></span><br><span class="line">                setLocalTaint(localIndex, argIndex);</span><br><span class="line">                localIndex += <span class="number">1</span>;</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 依次类推 设置参数的污染 根据参数的类型调整局部变量表索引，因为 long Double 类型占据两个槽位</span></span><br><span class="line">            <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">                setLocalTaint(localIndex, argIndex);</span><br><span class="line">                localIndex += argType.getSize();</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>PassthroughDataflowMethodVisitor 父类 TaintTrackingMethodVisitor 的 visitCode 方法，主要作用是开辟局部变量表空间。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.visitCode();</span><br><span class="line">        savedVariableState.localVars.clear();</span><br><span class="line">        savedVariableState.stackVars.clear();</span><br><span class="line">        <span class="comment">// 方法的访问修饰符部位 static  为局部变量表开辟一个空间 因为实例方法第一个参数为this, 占据一个槽位</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            savedVariableState.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据方法描述符获取到参数类型 不同的参数类型占据不同的槽位 一般的类型为1个槽位  long double 占据两个槽位</span></span><br><span class="line">        <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">            <span class="comment">// 根据参数类型开辟不同大小的空间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argType.getSize(); i++) &#123;</span><br><span class="line">                savedVariableState.localVars.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当方法中出现字段访问时会调用 visitFieldInsn 方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="comment">// 静态的操作不了</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 从字段取值</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                    <span class="comment">// 占据一个槽位的字段</span></span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                        <span class="comment">// 判断字段是否能实例化 经典java序列化的条件 是 实现了serialize接口且类型没有在黑名单中</span></span><br><span class="line">                        <span class="comment">// 如果不能被序列化 则 isTransient 标记为true</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取当前字段所属类 的所有成员变量 进行遍历</span></span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果当前字段所属类的成员变量与当前字段相等</span></span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        <span class="comment">// 如果当前字段是被transient修饰 则被标记为   isTransient</span></span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 父类也要被找一遍 多态的原因</span></span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;Integer&gt; taint;</span><br><span class="line">                        <span class="comment">// 字段如果不是瞬态的 需要从栈上去一个值</span></span><br><span class="line">                        <span class="comment">// getField 会先从栈顶取出对象的引用</span></span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            taint = getStackTaint(<span class="number">0</span>); <span class="comment">// 只取不删</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 字段如果是瞬态的 虽然也需要从栈上取对象的引用 但并不会产生污点 只需设置一个空集合即可</span></span><br><span class="line">                            <span class="comment">// 或者说 污点传播链被中断了</span></span><br><span class="line">                            taint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 模拟堆栈变化</span></span><br><span class="line">                        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">// 取值完成后要将值重新压入到栈中 以便继续使用 即污点被压栈了</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, taint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// putField 与 两个槽数据的getField 堆栈变化放到这里了</span></span><br><span class="line">            <span class="comment">// 只会引起堆栈变化并不影响污点的变化</span></span><br><span class="line">            <span class="comment">// 静态操作不受控制 不影响污点传播</span></span><br><span class="line">            <span class="comment">// putField 操作前污点值已经咋栈上 执行完毕后改值会被弹出，不需要额外设置</span></span><br><span class="line">            <span class="comment">// long 和 double 类型数据传播到sink点也没啥价值，这里直接忽略掉了</span></span><br><span class="line">            <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>TaintTrackingMethodVisitor 的方法 visitFieldInsn 主要负责模拟指令执行时栈帧的变化  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">typeSize</span> <span class="operator">=</span> Type.getType(desc).getSize();</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 从class中读数据 然后将读取的数据 压入栈</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    push();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 从栈上弹出数据 然后给class对象指定的变量赋值</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 取值会 先从栈上弹出对象的引用 然后将取出的字段压入栈中</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    push();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 先从栈上将数据弹出来 然后弹出要被赋值的对象的引用 最后进行赋值</span></span><br><span class="line">            <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; typeSize; i++) &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                &#125;</span><br><span class="line">                pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line"></span><br><span class="line">        sanityCheck();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当出现方法调用时会调用 visitMethodInsn 方法   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">            <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123; <span class="comment">// 处理实例方法调用的 this，将 this 加入到参数列表中</span></span><br><span class="line">                Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">                extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">                argTypes = extendedArgTypes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回值大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">retSize</span> <span class="operator">=</span> Type.getReturnType(desc).getSize();</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; resultTaint;</span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                    <span class="comment">// 初始化 参数污点列表</span></span><br><span class="line">                    <span class="keyword">final</span> List&lt;Set&lt;Integer&gt;&gt; argTaint = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;Integer&gt;&gt;(argTypes.length);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        argTaint.add(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 调用方法前 方法的参数都会被先压到栈上 所以这里先从栈上将污点取出来</span></span><br><span class="line">                    <span class="comment">// 从这里可以看出  参数是从右往左压栈的</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">argType</span> <span class="operator">=</span> argTypes[i];</span><br><span class="line">                        <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            argTaint.set(argTypes.length - <span class="number">1</span> - i, getStackTaint(stackIndex + argType.getSize() - <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        stackIndex += argType.getSize();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 构造方法将被第一个参数污染</span></span><br><span class="line">                    <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                        <span class="comment">// parameters</span></span><br><span class="line">                        resultTaint = argTaint.get(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resultTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当前方法是否已经被分析过了 参数与返回值的传播关系</span></span><br><span class="line">                    Set&lt;Integer&gt; passthrough = passthroughDataflow.get(<span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc));</span><br><span class="line">                    <span class="comment">// 如果已经被分析过了 直接获取已有的结果</span></span><br><span class="line">                    <span class="keyword">if</span> (passthrough != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Integer passthroughDataflowArg : passthrough) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get(passthroughDataflowArg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果没有分析过 那就是前面的方法调用拓扑排序存在异常，这种情况基本不可能出现</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理方法调用过程中的操作数栈变化</span></span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">            <span class="comment">// 如果存在返回值</span></span><br><span class="line">            <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 补充而不是设置 因为时集合的缘故，重复的值会被剔除掉</span></span><br><span class="line">                getStackTaint(retSize-<span class="number">1</span>).addAll(resultTaint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>处理方法调用过程中的操作数栈变化  同时进行污点跟踪 与 PassthroughDataflowMethodVisitor 的 visitMethodInsn 有重复的逻辑。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> MethodReference.<span class="type">Handle</span> <span class="variable">methodHandle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc);</span><br><span class="line"></span><br><span class="line">        Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">            Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">            System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">            extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">            argTypes = extendedArgTypes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> Type.getReturnType(desc);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">retSize</span> <span class="operator">=</span> returnType.getSize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">            <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                <span class="comment">// 定义参数列表</span></span><br><span class="line">                <span class="keyword">final</span> List&lt;Set&lt;T&gt;&gt; argTaint = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;T&gt;&gt;(argTypes.length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                    argTaint.add(<span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法调用完后会恢复栈帧，将方法的参数弹出栈</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">argType</span> <span class="operator">=</span> argTypes[i];</span><br><span class="line">                    <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 占两个槽的 数据需要先弹一次 因为污点数据存储在更下层的槽位中 </span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; argType.getSize() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                            pop();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将栈上的污点压入被调用方法的参数污点列表中</span></span><br><span class="line">                        argTaint.set(argTypes.length - <span class="number">1</span> - i, pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;T&gt; resultTaint;</span><br><span class="line">                <span class="comment">// 构造方法的返回值会被第一个参数污染</span></span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">&quot;&lt;init&gt;&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">                    <span class="comment">// parameters</span></span><br><span class="line">                    resultTaint = argTaint.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resultTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If calling defaultReadObject on a tainted ObjectInputStream, that taint passes to &quot;this&quot;</span></span><br><span class="line">                <span class="keyword">if</span> (owner.equals(<span class="string">&quot;java/io/ObjectInputStream&quot;</span>) &amp;&amp; name.equals(<span class="string">&quot;defaultReadObject&quot;</span>) &amp;&amp; desc.equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    savedVariableState.localVars.get(<span class="number">0</span>).addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已知的一些预定义的污染关系</span></span><br><span class="line">                <span class="keyword">for</span> (Object[] passthrough : PASSTHROUGH_DATAFLOW) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (passthrough[<span class="number">0</span>].equals(owner) &amp;&amp; passthrough[<span class="number">1</span>].equals(name) &amp;&amp; passthrough[<span class="number">2</span>].equals(desc)) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; passthrough.length; i++) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get((Integer)passthrough[i]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在已分析的传播流数据</span></span><br><span class="line">                <span class="keyword">if</span> (passthroughDataflow != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 尝试从其中取出当前方法的污点传播流数据</span></span><br><span class="line">                    Set&lt;Integer&gt; passthroughArgs = passthroughDataflow.get(methodHandle);</span><br><span class="line">                    <span class="comment">// 如果当前方法的污点传播流已经被分析过了</span></span><br><span class="line">                    <span class="keyword">if</span> (passthroughArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 遍历得到当前方法会被哪些参数污染</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> arg : passthroughArgs) &#123;</span><br><span class="line">                            <span class="comment">// 从入参中取出对应位置的污点 放到 resultTaint 中 resultTaint 表示当前方法的返回值会被哪个入参污染</span></span><br><span class="line">                            resultTaint.addAll(argTaint.get(arg));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Heuristic; if the object implements java.util.Collection or java.util.Map, assume any method accepting an object</span></span><br><span class="line">                <span class="comment">// taints the collection. Assume that any method returning an object returns the taint of the collection.</span></span><br><span class="line">                <span class="comment">// 如果不是静态方法调用 且第一个参数非基本数据类型</span></span><br><span class="line">                <span class="comment">// 针对集合以及映射做的特殊处理</span></span><br><span class="line">                <span class="comment">// 假设任意接受对象的方法均会污染集合 假设任意返回对象的方法都会返回集合的污点</span></span><br><span class="line">                <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC &amp;&amp; argTypes[<span class="number">0</span>].getSort() == Type.OBJECT) &#123;</span><br><span class="line">                    Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.getSuperClasses(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(argTypes[<span class="number">0</span>].getClassName().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)));</span><br><span class="line">                    <span class="keyword">if</span> (parents != <span class="literal">null</span> &amp;&amp; (parents.contains(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/util/Collection&quot;</span>)) ||</span><br><span class="line">                            parents.contains(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/util/Map&quot;</span>)))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; argTaint.size(); i++) &#123;</span><br><span class="line">                            argTaint.get(<span class="number">0</span>).addAll(argTaint.get(i));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (returnType.getSort() == Type.OBJECT || returnType.getSort() == Type.ARRAY) &#123;</span><br><span class="line">                            resultTaint.addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 方法调用完需要如果需要返回数据 则需要先将返回值压栈</span></span><br><span class="line">                <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    push(resultTaint);</span><br><span class="line">                    <span class="comment">// 如果返回值占据两个槽位则还要压一次</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; retSize; i++) &#123;</span><br><span class="line">                        push();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line"></span><br><span class="line">        sanityCheck();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当方法执行完毕需要返回时 调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitInsn</span><span class="params">(<span class="type">int</span> opcode)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">                <span class="comment">// 这些指令操作的数据在操作数栈上只占据一个槽位</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.IRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.FRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.ARETURN:</span><br><span class="line">                    <span class="comment">// 从污点栈上取出最上面的一个数据 设置到 returnTaint 中</span></span><br><span class="line">                    <span class="comment">// 如果污点栈上的数据与形参存在关联则证明 该参数可以影响方法的返回值</span></span><br><span class="line">                    returnTaint.addAll(getStackTaint(<span class="number">0</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 同样的 这些指令占据两个槽位</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.LRETURN:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.DRETURN:</span><br><span class="line">                    returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// void</span></span><br><span class="line">                <span class="keyword">case</span> Opcodes.RETURN:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitInsn(opcode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>最终数据传播流图的的分析结果将被存储在字段 gadgetinspector.PassthroughDiscovery.passthroughDataflow，该字段的签名为 Map&lt;MethodReference.Handle, Set<Integer>&gt;，<br>即一个通过方法名句柄索引结果的 Map 映射，Map 的值为会污染该方法返回值的形参位置集合。<br>passthroughDataflow 最终会被保存在文件 passthrough.dat 中，数据的存储格式为<br>方法所属类全类名|方法名|方法描述符|污染的参数位置1,污染的参数位置2,污染的参数位置3…<br>如：<br>javax&#x2F;swing&#x2F;plaf&#x2F;nimbus&#x2F;OptionPanePainter	decodeEllipse1	()Ljava&#x2F;awt&#x2F;geom&#x2F;Ellipse2D;	0,  </p>
<h4 id="构造调用图"><a href="#构造调用图" class="headerlink" title="构造调用图"></a>构造调用图</h4><p>上一步的 passthroughDataflow生成是宏观的方法参数与返回值的关系并没有关系到方法内部的污染关系，若要形成 Gadgets 链还需确定父方法与子方法之间的参数传递关系。<br>这一步主要是分析方法的参数与其调用的子方法之间的关系，即子方法的参数是否会被其父方法的参数所污染。<br>因为涉及到方法内部的细节处理，所以这里仍然需要使用 MethodVisitor， 对应的方法访问器实现类为 ModelGeneratorMethodVisitor。<br>ModelGeneratorMethodVisitor 也是继承自 TaintTrackingMethodVisitor，其单独重写了visitCode visitFieldInsn 以及 visitMethodInsn 方法。  </p>
<p>该方法整体流程与数据传播流图分析时的 visitCode 方法一致，区别在于局部变量表中存储的数据。数据流图分析时局部变量表中存储的是参数的索引，<br>此时存储的是一个以<code>arg</code>开头并追加参数索引的字符串，如：arg0，arg1。这样做的目的在于分析父方法与被调用子方法之间的形参传递时，<br>能够通过检查子方法的参数值是否以<code>arg</code> 来头来判断父方法的形参是否传递到了子方法中。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">localIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">                localIndex += <span class="number">1</span>;</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">                setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">                localIndex += argType.getSize();</span><br><span class="line">                argIndex += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>针对字段访问相关的字节码指令进行处理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitFieldInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.GETFIELD:</span><br><span class="line">                    <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> Type.getType(desc);</span><br><span class="line">                    <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">Boolean</span> <span class="variable">isTransient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                        <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                            isTransient = Boolean.TRUE;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="type">ClassReference</span> <span class="variable">clazz</span> <span class="operator">=</span> classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner));</span><br><span class="line">                            <span class="keyword">while</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                        isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (isTransient != <span class="literal">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                clazz = classMap.get(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(clazz.getSuperClass()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;String&gt; newTaint = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                            <span class="comment">// 栈顶放的时对象的引用 构造污点标识符</span></span><br><span class="line">                            <span class="comment">// 如果对象来自父方法的入参 则 s 为 arg1.fieldName</span></span><br><span class="line">                            <span class="keyword">for</span> (String s : getStackTaint(<span class="number">0</span>)) &#123;</span><br><span class="line">                                newTaint.add(s + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 模拟操作数栈变化</span></span><br><span class="line">                        <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                        <span class="comment">// 将取字段的结果放入到栈顶 即 arg1.fieldName</span></span><br><span class="line">                        setStackTaint(<span class="number">0</span>, newTaint);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟操作数栈变化</span></span><br><span class="line">            <span class="built_in">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>针对方法访问进行处理  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitMethodInsn</span><span class="params">(<span class="type">int</span> opcode, String owner, String name, String desc, <span class="type">boolean</span> itf)</span> &#123;</span><br><span class="line">            Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line">            <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">                Type[] extendedArgTypes = <span class="keyword">new</span> <span class="title class_">Type</span>[argTypes.length+<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">                extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">                argTypes = extendedArgTypes;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">                <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">                    <span class="type">int</span> <span class="variable">stackIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">argIndex</span> <span class="operator">=</span> argTypes.length-<span class="number">1</span>-i;</span><br><span class="line">                        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> argTypes[argIndex];</span><br><span class="line">                        <span class="comment">// 此时从栈顶向下的数据均为被调用方法的入参</span></span><br><span class="line">                        <span class="comment">// 根据栈索引从栈上取得参数</span></span><br><span class="line">                        Set&lt;String&gt; taint = getStackTaint(stackIndex);</span><br><span class="line">                        <span class="comment">// 如果该参数有污点标识符 </span></span><br><span class="line">                        <span class="keyword">if</span> (taint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 遍历污点标识符</span></span><br><span class="line">                            <span class="keyword">for</span> (String argSrc : taint) &#123;</span><br><span class="line">                                <span class="comment">// 如果参数的污点标识符 不是arg开头 则直接报错退出，即调用方法的参数无法影响被调用方法的入参</span></span><br><span class="line">                                <span class="comment">// 这里直接抛出异常 是否存在问题</span></span><br><span class="line">                                <span class="comment">// 第一个参数不被受主调方法入参影响，直接退出针对该方法的分析，那么第二个参数如果受影响呢？</span></span><br><span class="line">                                <span class="keyword">if</span> (!argSrc.substring(<span class="number">0</span>, <span class="number">3</span>).equals(<span class="string">&quot;arg&quot;</span>)) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid taint arg: &quot;</span> + argSrc);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 确定`.`号的位置</span></span><br><span class="line">                                <span class="comment">// </span></span><br><span class="line">                                <span class="type">int</span> <span class="variable">dotIndex</span> <span class="operator">=</span> argSrc.indexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                <span class="type">int</span> srcArgIndex;</span><br><span class="line">                                String srcArgPath;</span><br><span class="line">                                <span class="comment">// 如果点号不存在则证明被调用方法的污点标识符由调用方法的参数直接传递</span></span><br><span class="line">                                <span class="keyword">if</span> (dotIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 计算参数索引</span></span><br><span class="line">                                    srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>));</span><br><span class="line">                                    <span class="comment">// 参数路径为空 </span></span><br><span class="line">                                    srcArgPath = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 计算参数索引 因为存在点号 证明该参数由对象间接传递 非直接传递</span></span><br><span class="line">                                    srcArgIndex = Integer.parseInt(argSrc.substring(<span class="number">3</span>, dotIndex));</span><br><span class="line">                                    <span class="comment">// 记录被调用方法的参数来自主调方法的参数的哪个属性</span></span><br><span class="line">                                    srcArgPath = argSrc.substring(dotIndex+<span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 构造调用图</span></span><br><span class="line">                                <span class="comment">// 主调方法句柄  被调用方法句柄   主调方法参数索引 主调方法参数传递路径  被调方法参数索引</span></span><br><span class="line">                                discoveredCalls.add(<span class="keyword">new</span> <span class="title class_">GraphCall</span>(</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="built_in">this</span>.owner), <span class="built_in">this</span>.name, <span class="built_in">this</span>.desc),</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(<span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(owner), name, desc),</span><br><span class="line">                                        srcArgIndex,</span><br><span class="line">                                        srcArgPath,</span><br><span class="line">                                        argIndex));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 增加栈索引 继续获取下一个参数</span></span><br><span class="line">                        stackIndex += type.getSize();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>形成的方法间调用图将被存储在 CallGraphDiscovery.discoveredCalls 字段中，最终被持久化到 callgraph.dat 文件中。存储格式如下<br>主调方法所属类全类名|主调方法名|主调方法描述符|被调方法所属类全类名|被调方法名|被调方法描述符|主调方法参数索引|主调方法参数传递路径|被调方法参数索引<br>如：<br>com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;impl&#x2F;dtd&#x2F;XMLDTDDescription	<init>	(Lcom&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;xni&#x2F;XMLResourceIdentifier;Ljava&#x2F;lang&#x2F;String;)V	com&#x2F;sun&#x2F;org&#x2F;apache&#x2F;xerces&#x2F;internal&#x2F;xni&#x2F;XMLResourceIdentifier	getBaseSystemId	()Ljava&#x2F;lang&#x2F;String;	1		0<br>我们看 XMLDTDDescription 对应的构造函数，被调用的子方法是 id.getBaseSystemId()。getBaseSystemId的调用者id来自 XMLDTDDescription 构造函数的第一个参数，<br>即索引1。getLiteralSystemId 也有一个参数 this, 索引为0。 XMLDTDDescription的第一个参数将影响 getBaseSystemId 方法的第0个参数且是直接影响并无参数路径。<br>故形成的污染路径为 <code>1		0</code>   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XMLDTDDescription</span><span class="params">(XMLResourceIdentifier id, String rootName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setValues(id.getPublicId(), id.getLiteralSystemId(), id.getBaseSystemId(), id.getExpandedSystemId());</span><br><span class="line">        <span class="built_in">this</span>.fRootName = rootName;</span><br><span class="line">        <span class="built_in">this</span>.fPossibleRoots = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Source-点探测"><a href="#Source-点探测" class="headerlink" title="Source 点探测"></a>Source 点探测</h4><p>不同的反序列化类型具有不同的入口，Gadget Inspector 默认提供了两种类型的入口点探测类，分别是 JacksonSourceDiscovery 以及 SimpleSourceDiscovery。<br>我们以最常用的Java原生反序列化为例，即 SimpleSourceDiscovery。<br>逻辑就是根据已知的反序列化入口点取匹配被探测的方法，然后形成一个列表。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span><br><span class="line"><span class="params">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span><br><span class="line"><span class="params">                         InheritanceMap inheritanceMap)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SerializableDecider</span> <span class="variable">serializableDecider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSerializableDecider</span>(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;finalize&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;readObject&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/io/ObjectInputStream;)V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>))) &#123;</span><br><span class="line">                MethodReference.<span class="type">Handle</span> <span class="variable">method</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodReference</span>.Handle(</span><br><span class="line">                        clazz, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects</span></span><br><span class="line">        <span class="comment">// into a HashMap.</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()I&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> <span class="title class_">ClassReference</span>.Handle(<span class="string">&quot;groovy/lang/Closure&quot;</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">&quot;call&quot;</span>) || method.getName().equals(<span class="string">&quot;doCall&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> <span class="title class_">Source</span>(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终形成的source点列表将被持久化存储在 sources.dat 文件中。文件格式如下：<br>方法所属类全类名|方法名|方法描述|污点参数索引  </p>
<h4 id="Gadget-Chain-构造"><a href="#Gadget-Chain-构造" class="headerlink" title="Gadget Chain 构造"></a>Gadget Chain 构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">        <span class="type">InheritanceMap</span> <span class="variable">inheritanceMap</span> <span class="operator">=</span> InheritanceMap.load();</span><br><span class="line">        <span class="comment">// 查找方法的所有实现</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ImplementationFinder</span> <span class="variable">implementationFinder</span> <span class="operator">=</span> config.getImplementationFinder(</span><br><span class="line">                methodMap, methodImplMap, inheritanceMap);</span><br><span class="line">        <span class="comment">// 持久化</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> Files.newBufferedWriter(Paths.get(<span class="string">&quot;methodimpl.dat&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">                writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getDesc());</span><br><span class="line">                writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getClassReference().getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getDesc());</span><br><span class="line">                    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加载调用图并合并</span></span><br><span class="line">        <span class="comment">// graphCallMap 通过主调方法名句柄映射其所有被调方法调用图的集合</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">GraphCall</span>.Factory())) &#123;</span><br><span class="line">            MethodReference.<span class="type">Handle</span> <span class="variable">caller</span> <span class="operator">=</span> graphCall.getCallerMethod();</span><br><span class="line">            <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">                Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                graphCalls.add(graphCall);</span><br><span class="line">                graphCallMap.put(caller, graphCalls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graphCallMap.get(caller).add(graphCall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// exploredMethods 记录所有被查找过的方法 避免重复搜索</span></span><br><span class="line">        Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录需要查找的source方法 每个source被当作一条GadgetChain</span></span><br><span class="line">        LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 加载入口点</span></span><br><span class="line">        <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> <span class="title class_">Source</span>.Factory())) &#123;</span><br><span class="line">            <span class="comment">// 封装入口点为一个link</span></span><br><span class="line">            <span class="type">GadgetChainLink</span> <span class="variable">srcLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将source点封装的 GadgetChain 加入到预处理列表中</span></span><br><span class="line">            methodsToExplore.add(<span class="keyword">new</span> <span class="title class_">GadgetChain</span>(Arrays.asList(srcLink)));</span><br><span class="line">            <span class="comment">// 将入口点加入到已查找集合中</span></span><br><span class="line">            exploredMethods.add(srcLink);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">iteration</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 迭代1000次记录一次</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;Iteration &quot;</span> + iteration + <span class="string">&quot;, Search space: &quot;</span> + methodsToExplore.size());</span><br><span class="line">            &#125;</span><br><span class="line">            iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">GadgetChain</span> <span class="variable">chain</span> <span class="operator">=</span> methodsToExplore.pop();</span><br><span class="line">            <span class="comment">// 取得链中最后一个link</span></span><br><span class="line">            <span class="type">GadgetChainLink</span> <span class="variable">lastLink</span> <span class="operator">=</span> chain.links.get(chain.links.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 从link中获取到方法句柄，根据方法句柄获取到调用图集合</span></span><br><span class="line">            Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">            <span class="keyword">if</span> (methodCalls != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历调用图</span></span><br><span class="line">                <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                    <span class="comment">// 如果调用这的参数索引与链中最后一个link的taintedArgIndex不同，则该方法调用不符合要求。</span></span><br><span class="line">                    <span class="comment">// 即需要调用者的参数可控</span></span><br><span class="line">                    <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 从调用图中找到被调用方法的句柄，然后查找该方法的所有重载方法</span></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line">                    <span class="comment">// 遍历所有重载方法</span></span><br><span class="line">                    <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                        <span class="comment">// 将该方法重新封装成一个link 第一个参数为方法名句柄  第二个参数表示该方法哪一个参数可以被污染</span></span><br><span class="line">                        <span class="comment">// 在寻找下一个节点时需要保证 第二个参数 出现在调用图图中</span></span><br><span class="line">                        <span class="type">GadgetChainLink</span> <span class="variable">newLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChainLink</span>(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                        <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 形成新的GadgetChain </span></span><br><span class="line">                        <span class="type">GadgetChain</span> <span class="variable">newChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GadgetChain</span>(chain, newLink);</span><br><span class="line">                        <span class="comment">// 如果该链的最后一个link是sink点，且满足污染关系 则认为找到了一条反序列化Gadgets链</span></span><br><span class="line">                        <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                            discoveredGadgets.add(newChain);</span><br><span class="line">                            <span class="comment">// 否则继续寻找</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 将新链加入到需要寻找的列表中</span></span><br><span class="line">                            methodsToExplore.add(newChain);</span><br><span class="line">                            <span class="comment">// 将新的方法节点加入到已经被查找过的方法集合中</span></span><br><span class="line">                            exploredMethods.add(newLink);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">             <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">                printGadgetChain(writer, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">&quot;Found &#123;&#125; gadget chains.&quot;</span>, discoveredGadgets.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>关于如何 连接Gadget Chain，这里举例说明。<br>以下两个类A与类B分别实现了 Serializable 接口，并且都重写了 readObject 方法。 这里将类A的 readObject 方法作为 Source 点。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">var2</span> <span class="operator">=</span> (B) var1.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">ObjectInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> var1.readUTF();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行 Gadget Chain 构造时首先会将 A 类的 readObject 方法封装为一个 GadgetChainLink 对象，其第一个参数为 readObject 方法名的句柄，<br>第二个参数为参数污点索引（1）。然后将这个 GadgetChainLink 添加到一个数组中再封装到 GadgetChain 中。<br>搜索时先从 GadgetChain 中取出列表中最后一个 link，也就是 A 类 readObject 方法封装的 GadgetChainLink 对象。然后获取到方法名，<br>并从调用图映射中通过方法名取得类A方法readObject 的所有调用图，我们的例子中只有一个，即调用类B的readObject方法。<br>这个调用图在 callgraph.dat 中是这样的：<br>A   readObject  (Ljava&#x2F;io&#x2F;ObjectInputStream;)V  B   readObject   ()Ljava&#x2F;lang&#x2F;Object;     1         0<br>取得了调用图后会比较类A的 readObject 方法的参数污点索引（1）是否与调用图中的调用者参数索引（1）一致，在给出的例子中两者均为1，表明污点可以传递下去。<br>然后查找类B的所有实现类是否重写了readObject方法，如果存在重写，则所有的重写方法都将被封装为新的 GadgetChainLink 对象，并将它们添加到 GadgetChain 中。<br>这个新的 GadgetChain 接受两个参数，第一个参数为前一个链，第二个参数为当前链的最后一个link。 然后判断该链的最后一个link是否是sink点，如果是则认为找到了一条反序列化Gadgets链，否则继续寻找。<br>新生成的 GadgetChain 会被添加到 methodsToExplore 中参加下一轮循环。  </p>

    </div>

    
    
    <div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
        <div class="reward-container">
  <div>Buy me a coffee.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Arliya 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Arliya 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Arliya
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dayutech.github.io/archives/a580d790.html" title="Java-Gadgets搜索工具是如何工作的-Gadget Inspector">https://dayutech.github.io/archives/a580d790.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 反序列化</a>
              <a href="/tags/Java-Gadgets/" rel="tag"><i class="fa fa-tag"></i> Java Gadgets</a>
              <a href="/tags/Gadget-Inspector/" rel="tag"><i class="fa fa-tag"></i> Gadget Inspector</a>
              <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE/" rel="tag"><i class="fa fa-tag"></i> 反序列化利用链</a>
          </div>
		  
          <script data-pjax>
	var tagsall=document.getElementsByClassName("post-tags")
	for (var i = tagsall.length - 1; i >= 0; i--){
		var tags=tagsall[i].getElementsByTagName("a");
		for (var j = tags.length - 1; j >= 0; j--) {
			var golden_ratio = 0.618033988749895;
			var s = 0.5;
			var v = 0.999;
			var h = golden_ratio + Math.random()*0.8 - 0.5;
			var h_i = parseInt(h * 6);
			var f = h * 6 - h_i;
			var p = v * (1 - s);
			var q = v * (1 - f * s);
			var t = v * (1 - (1 - f) * s);
			var r, g, b;
			switch (h_i) {
				case 0:
					r = v;
					g = t;
					b = p;
					break;
				case 1:
					r = q;
					g = v;
					b = p;
					break;
				case 2:
					r = p;
					g = v;
					b = t;
					break;
				case 3 :
					r = p;
					g = q;
					b = v;
					break;
				case 4:
					r = t;
					g = p;
					b = v;
					break;
				case 5:
					r = v;
					g = p;
					b = q;
					break;
				default:
					r = 1;
					g = 1;
					b = 1;
			  }
			tags[j].style.background = "rgba("+parseInt(r*255)+","+parseInt(g*255)+","+parseInt(b*255)+","+0.5+")";
		}
	}          
                         
            </script>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/2a377379.html" rel="prev" title="Scala代码审计从入门到入坟">
      <i class="fa fa-chevron-left"></i> Scala代码审计从入门到入坟
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/42623881.html" rel="next" title="通过Tomcat BeanFactory 绕过高版本JDK CodeBase限制实现JNDI注入">
      通过Tomcat BeanFactory 绕过高版本JDK CodeBase限制实现JNDI注入 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  <!-- needsharebutton Javascript file -->
<script src="js/needsharebutton.min.js"></script>
<!-- needsharebutton CSS file -->
<link href="css/needsharebutton.min.css" rel="stylesheet" />
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-Gadgets-%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%88Gadget-Inspector%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Java Gadgets 搜索工具是如何工作的（Gadget Inspector）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.1.</span> <span class="nav-text">检测原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">类结构分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">数据流分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">1.0.1.2.1.</span> <span class="nav-text">分析方法调用关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.1.2.2.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.0.1.2.2.1.</span> <span class="nav-text">图相关概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%86%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.1.2.2.2.</span> <span class="nav-text">为什么需要将所有方法进行拓扑排序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%BF%9B%E8%A1%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">1.0.1.2.2.3.</span> <span class="nav-text">如何对方法调用进行拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E6%92%AD%E6%B5%81%E5%9B%BE"><span class="nav-number">1.0.1.2.3.</span> <span class="nav-text">构造数据传播流图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E8%B0%83%E7%94%A8%E5%9B%BE"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">构造调用图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Source-%E7%82%B9%E6%8E%A2%E6%B5%8B"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">Source 点探测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gadget-Chain-%E6%9E%84%E9%80%A0"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">Gadget Chain 构造</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Arliya"
      src="/images/dayu/avatar.png">
  <p class="site-author-name" itemprop="name">Arliya</p>
  <div class="site-description" itemprop="description">主要从事Web漏洞挖掘工作，涉猎编程语言包括Java、Scala、C/C++、PHP、Python、C#、Golang，涉及领域包括Web以及二进制漏洞挖掘，二进制比较菜，平时喜欢在金融市场消费</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">105</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">194</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dayutech" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dayutech" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:test@qq.com" title="E-Mail → mailto:test@qq.com" rel="noopener external nofollow noreferrer" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/yourname" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;yourname" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/yourname" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;yourname" rel="noopener external nofollow noreferrer" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener external nofollow noreferrer" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
	  
		<div class="links-of-blogroll scroll" style="margin-top:20px; border-style:dotted none none none; padding-top:5px; text-align:left;padding-left: 20px; padding-right: 10px; padding-bottom: 5px;">
		  <div class="links-of-blogroll-title" style="padding-bottom: 5px; padding-top: 5px; padding-left: 0px; padding-right: 20px; font-size: 1.6em; argin-right: 5px;">
		<!-- 选择合适的icon --><i class="fab fa-markdown" aria-hidden="true"></i>
			<b style="font-size: 0.65em; padding-left: 8px; position: relative; top: -2px;">文章列表</b>
		  </div>
		  <ul class="links-of-blogroll-list">
		<!-- 文章排序规格,-updated 按照文章更新时间倒排 -->
			
		<!-- 显示10数目的文章 -->
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/19883263.html" title="机器学习-线性回归" target="_blank">机器学习-线性回归</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/ec714069.html" title="'一种隐藏在JWT解析中的绕过漏洞'" target="_blank">'一种隐藏在JWT解析中的绕过漏洞'</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/324e0c68.html" title="C Sharp程序漏洞挖掘过程中一些框架、技巧、逻辑、流程、特性、Sink点、设计模式等知识点记录" target="_blank">C Sharp程序漏洞挖掘过程中一些框架、技巧、逻辑、流程、特性、Sink点、设计模式等知识点记录</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/6e27d7b9.html" title=".Net Remoting 导致的反序列化漏洞" target="_blank">.Net Remoting 导致的反序列化漏洞</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/42eb2c82.html" title="动态代理在java反序列化中的应用" target="_blank">动态代理在java反序列化中的应用</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/6f1feaf8.html" title="BinaryFormatter反序列化漏洞之ActivitySurrogateSelector利用链" target="_blank">BinaryFormatter反序列化漏洞之ActivitySurrogateSelector利用链</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/323962a4.html" title="从三味书屋到百草堂、从XmlSerializer到BinnaryFormatter之BinaryFormatter反序列化漏洞TextFormattingRunProperties利用链" target="_blank">从三味书屋到百草堂、从XmlSerializer到BinnaryFormatter之BinaryFormatter反序列化漏洞TextFormattingRunProperties利用链</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/ff457959.html" title="从三味书屋到百草堂，从XmlSerializer到BinnaryFormatter之XmlSerializer反序列化漏洞ObjectDataProvider利用链" target="_blank">从三味书屋到百草堂，从XmlSerializer到BinnaryFormatter之XmlSerializer反序列化漏洞ObjectDataProvider利用链</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/3792a892.html" title="Java动态代理在反序列化漏洞中的应用" target="_blank">Java动态代理在反序列化漏洞中的应用</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/31bfcb8f.html" title="Java HashMap 实现方法" target="_blank">Java HashMap 实现方法</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/b83d1f32.html" title="从头开始挖掘Java RMI漏洞" target="_blank">从头开始挖掘Java RMI漏洞</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/66a16759.html" title="Apache Struts2 原理学习" target="_blank">Apache Struts2 原理学习</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/60a726cc.html" title="Apache Struts2 S2-067 任意文件上传漏洞（CVE-2024-53677）" target="_blank">Apache Struts2 S2-067 任意文件上传漏洞（CVE-2024-53677）</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/f9ff5c36.html" title="CrushFTP 认证绕过（CVE-2025-2825）" target="_blank">CrushFTP 认证绕过（CVE-2025-2825）</a>
			  </li>
			
			  <li class="postsSidebarNumb" style="text-indent: -1em;">
				<a href="/archives/fe8a0a5d.html" title="Apache Struts2 S2-066 任意文件上传漏洞（CVE-2023-50164）" target="_blank">Apache Struts2 S2-066 任意文件上传漏洞（CVE-2023-50164）</a>
			  </li>
			
		  </ul>
		</div>
	  
	 
    </div>
	
  </aside>
  <div id="sidebar-dimmer"></div>
 


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arliya</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">207k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">12:32</span>
</div>
  <div class="powered-by">由 <a href="https://github.com/dayutech" class="theme-link" rel="noopener external nofollow noreferrer" target="_blank">DayuTech</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  
<div id="needsharebutton-float">
      <span class="btn">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </span>
    </div>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
      flOptions = {};
        flOptions.iconStyle = "box";
        flOptions.boxForm = "horizontal";
        flOptions.position = "middleRight";
        flOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-float', flOptions);
  </script>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'Ov23li28mRRYx9D76aAJ',
      clientSecret: '8f7211d1bd039050ed40345ddf60273d6626ad6f',
      repo        : 'dayutech.github.io',
      owner       : 'dayutech',
      admin       : ['dayutech'],
      id          : '68fe71fc78dcf34056e79245a2c478df',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>
<style>
#custom_bar {
  float: right;
  font-style: italic;
  background-color: lightgray;
  position: fixed;
  top: 20%;
  right: 50px;
  box-shadow: 15px 10px 10px gray;
}
/* 新年侧边栏 */
#newYear {
  color: white;
  padding: 0 !important;
}

#newYear p,
#newYear h3 {
  font-weight: normal;
  color: inherit;
  margin: 0;
}

#newYear .item-headline {
  display: none;
}

.newYear-slider {
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 100%;
}

.newYear-slider .swiper-slide {
  min-height: 160px;
  min-width: 210px;
  background-size: cover;
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 100%;
}

#newYear-main {
  width: 100%;
  pointer-events: none;
  padding: 1rem;
  position: relative;
  left: 0;
  top: 0;
  z-index: 1;
}

#newYear-main * {
  position: relative;
  line-height: 1.3;
}

#newYear-main .time,
#newYear-main .happyNewYear {
  font-size: 3rem;
  margin: 8px 0;
  display: block;
}

#newYear-main .newYear-time {
  font-weight: bold;
  text-align: center;
}

#newYear-main .day {
  font-size: 4rem;
  letter-spacing: 6px;
  margin-right: -6px;
}

#newYear-main .unit {
  font-size: 1rem;
}

#newYear-main .mask {
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 100%;
  background-color: rgba(0, 0, 0, .2);
}

[data-theme=dark] #newYear-main .mask {
  background-color: rgba(0, 0, 0, .3);
}
</style>
<link data-pjax rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.css">
<aside id="custom_bar">
    <div id="newYear">
        <div class="newYear-slider">
            <div class="swiper-wrapper">
                <div class="swiper-slide" style="background-image:url(/images/ma1.jpg)"></div>
                <div class="swiper-slide" style="background-image:url(/images/ma2.jpg)"></div>
                <div class="swiper-slide" style="background-image:url(/images/ma3.jpg)"></div>
                <div class="swiper-slide" style="background-image:url(/images/ma4.jpg)"></div>
            </div>
        </div>
        <div id="newYear-main">
            <div class="mask"></div>
            <p class="title"></p>
            <div class="newYear-time"></div>
            <p class="today" style="text-align: right;"></p>
        </div>
    </div>
</aside>
<script data-pjax src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/Swiper/8.0.6/swiper-bundle.min.js"></script>
<script data-pjax>
    function newYear() {
    if (!document.querySelector('#newYear')) return;
    // 新年时间戳 and 星期对象
    let SpringFestival = new Date('2026-02-17 00:00:00')
    let newYear = SpringFestival.getTime() / 1000,
        week = { 0: '周日', 1: '周一', 2: '周二', 3: '周三', 4: '周四', 5: '周五', 6: '周六' }
    function nol(h) { h = Number(h); return h > 9 ? h : '0' + h; }
    time();

    function time() {
        // 现在 时间对象
        let now = new Date();

        // 右下角 今天
        document.querySelector('#newYear .today').innerHTML = now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + week[now.getDay()]

        // 现在与新年相差秒数
        let second = newYear - Math.round(now.getTime() / 1000);

        // 小于0则表示已经过年
        if (second < 0) {
        window.newYearTimer = null
        document.querySelector('#newYear .title').innerHTML = 'Happy New Year!';
        document.querySelector('#newYear .newYear-time').innerHTML = '<span class="happyNewYear">新年快乐</span>';
        } else {
        // 大于0则还未过年
        document.querySelector('#newYear .title').innerHTML = '距离' + SpringFestival.getFullYear() + '年春节：'
        // 大于一天则直接渲染天数
        if (second > 86400) {
            document.querySelector('#newYear .newYear-time').innerHTML = `<span class="day">${Math.ceil(second / 86400)}</span><span class="unit">天</span>`
        } else {
            // 小于一天则使用时分秒计时。
            let h = nol(parseInt(second / 3600));
            second %= 3600;
            let m = nol(parseInt(second / 60));
            second %= 60;
            let s = nol(second);
            document.querySelector('#newYear .newYear-time').innerHTML = `<span class="time">${h}:${m}:${s}</span></span>`;
            // 计时
            if (!window.newYearTimer) window.newYearTimer = setInterval(time, 1000);
        }
        }
    }
    }

    function newYearSwiper() {
    var swiper = new Swiper('.newYear-slider', {
        passiveListeners: true,
        loop: true,
        // autoplay: false,
        autoplay: {
        disableOnInteraction: true,
        delay: 5000
        },
        effect: 'fade',
        mousewheel: true,
        autoHeight: true
    });

    var comtainer = document.querySelector('.newYear-slider');
    if (comtainer !== null) {
        comtainer.onmouseenter = () => { swiper.autoplay.stop() };
        comtainer.onmouseleave = () => { swiper.autoplay.start() };
    }
    }

    // 适配了pjax
    function whenDOMReady() {
    // pjax加载完成（切换页面）后需要执行的函数和代码
    newYear()
    newYearSwiper()
    }

    whenDOMReady() // 打开网站先执行一次
    document.addEventListener("pjax:complete", whenDOMReady) // pjax加载完成（切换页面）后再执行一次
</script>

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
